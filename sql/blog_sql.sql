-- MySQL dump 10.13  Distrib 8.0.26, for Win64 (x86_64)
--
-- Host: localhost    Database: blog_db
-- ------------------------------------------------------
-- Server version	8.0.26

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `blog_db`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `blog_db` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `blog_db`;

--
-- Table structure for table `ms_admin`
--

DROP TABLE IF EXISTS `ms_admin`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_admin` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_admin`
--

LOCK TABLES `ms_admin` WRITE;
/*!40000 ALTER TABLE `ms_admin` DISABLE KEYS */;
INSERT INTO `ms_admin` VALUES (1,'admin','$2a$10$eUI4Nx0t0SnE2xDiuSrGCexI2S9ranFLwMZZUYOsXlBnKHDJpeJhe'),(2,'mszlu','$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW'),(3,'liubai','$2a$10$eUI4Nx0t0SnE2xDiuSrGCexI2S9ranFLwMZZUYOsXlBnKHDJpeJhe');
/*!40000 ALTER TABLE `ms_admin` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_admin_permission`
--

DROP TABLE IF EXISTS `ms_admin_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_admin_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `admin_id` bigint NOT NULL,
  `permission_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_admin_permission`
--

LOCK TABLES `ms_admin_permission` WRITE;
/*!40000 ALTER TABLE `ms_admin_permission` DISABLE KEYS */;
INSERT INTO `ms_admin_permission` VALUES (1,1,1),(2,2,1),(3,3,1);
/*!40000 ALTER TABLE `ms_admin_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_article`
--

DROP TABLE IF EXISTS `ms_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_article` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `comment_counts` int DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标题',
  `view_counts` int DEFAULT NULL COMMENT '浏览数量',
  `weight` int NOT NULL COMMENT '是否置顶',
  `author_id` bigint DEFAULT NULL COMMENT '作者id',
  `body_id` bigint DEFAULT NULL COMMENT '内容id',
  `category_id` int DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1534903377091194882 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_article`
--

LOCK TABLES `ms_article` WRITE;
/*!40000 ALTER TABLE `ms_article` DISABLE KEYS */;
INSERT INTO `ms_article` VALUES (1534438376886841346,1,1654673592186,'redis基础入门介绍，适用于新手小伙伴，教程简单易懂，希望对大家有所帮助。','Redis 基础入门',4,0,1,1405916999854342207,2),(1534439635018657793,1,1654673892155,'消息中间件可以提供一个可靠的环境用于数据的传输，消息中间件可以帮助我们的程序实现流量消峰、应用解耦、异步处理等功能，在分布式应用中使用的非常多。','RabbitMQ 基本介绍',4,0,1,1405916999854342209,2),(1534440888750649346,0,1654674191069,'在现在的前端工程中，Vue 是一门应用非常广泛的框架，使用 Vue 后我们可以不再那么关注 DOM 操作，而专心于数据的处理，是前端工程师必备的一项技能。','Vue 基础入门',3,0,1404446129264832513,1405916999854342211,1),(1534441901578596354,1,1654674432550,'SpringBoot框架可以帮助我们快速的整合其他框架，使用起来也十分简单，不过建议大家在学习的过程中了解一些源码的自动配置，可以帮助我们更好的认识这个框架。','SpringBoot 如何进行 Web 开发',6,0,1,1405916999854342212,2),(1534442912082898945,1,1654674673469,'一些npm的基础命令，可是常常用来复习','npm 基础命令',8,0,1404446129264832513,1405916999854342214,1);
/*!40000 ALTER TABLE `ms_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_article_body`
--

DROP TABLE IF EXISTS `ms_article_body`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_article_body` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `article_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1405916999854342222 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_article_body`
--

LOCK TABLES `ms_article_body` WRITE;
/*!40000 ALTER TABLE `ms_article_body` DISABLE KEYS */;
INSERT INTO `ms_article_body` VALUES (1405916999854342207,'# 引入\n\n在学习这门课程之前，大家可能或多或少了解过 Redis，它是一门 NoSQL 数据库，在引入部分，我们可以先了解以下这么技术是做什么的。\n\n## Web 1.0 时代\n\nWeb1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。\n\n![image-20220428161938450](http://img.liubaiblog.top/img/image-20220428161938450.png)\n\n## Web 2.0 时代\n\n随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。\n\n![image-20220428162220231](http://img.liubaiblog.top/img/image-20220428162220231.png)\n\n所以我们就需要解决这些压力。\n\n### 解决 CPU 及内存压力\n\n![1](http://img.liubaiblog.top/img/1.jpg)\n\n可以看出来，使用缓存数据库是这几种方案中，最合适的一种方式。而 Redis 就是缓存数据库，可以缓存各个服务器中的 `Session` ，各个服务器都可以来读取这个缓存服务器中的 `Session` ，从而降低应用服务器中的 CPU 及内存压力。\n\n\n\n### 解决 IO 压力\n\n![image-20220428162827989](http://img.liubaiblog.top/img/image-20220428162827989.png)\n\n缓存数据库中，还可以将关系数据库中存储的数据，缓存到缓存数据库中，这样用户下次访问的时候，就可以到缓存数据库中取，所以也可以降低关系数据库 IO 压力。\n\n\n\n# NoSQL 数据库\n\n## 概述\n\nNoSQL(Not Only SQL)，意为“不仅仅是SQL”，泛指非关系型数据库，我们现在要学的 Redis 就是非关系型数据库；而之前学习的 MySQL 就是关系型数据库。\n\nNoSQL 不依赖业务逻辑方式存储，而是以简单的 key-value 模式存储，因此大大的增加了数据库的扩展能力。\n\n\n\n**NoSQL 数据库的特点是**：\n\n- 不遵循 SQL 标准。\n- 不支持 ACID (但不是不支持事务!)\n- 远超于 SQL 的性能。\n\n**NoSQL 使用场景**\n\n- 对数据高并发的读写\n\n- 海量数据的读写\n\n- 对数据高可扩展性的\n\n\n**NoSQL 不适用场景**\n\n- 需要事务支持\n- 基于 SQL 的结构化查询存储，处理复杂的关系，需要即席查询\n\n**注意：用不着 SQL 和用了 SQL 也不行的情况，请考虑使用 NoSQL。**\n\n常见的 NoSQL 数据库有 `memcached` 、`redis` 、`mongodb` ，我们这门课程主要学习 `redis` ，其他数据库可以自行简单了解。\n\n\n\n# `Redis` 介绍\n\n> **redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。**\n\n使用 `redis` 可以做： \n\n- 高频次，热门访问的数据，降低数据库IO\n\n- 分布式架构，做session共享\n\n![image-20220428210459141](http://img.liubaiblog.top/img/image-20220428210459141.png)\n\n**多样的数据结构存储持久化数据**\n\n![image-20220428210526370](http://img.liubaiblog.top/img/image-20220428210526370.png)\n\n\n\n# 下载\n\n访问 `redis` [官网](https://redis.io/download/)，点击如下位置链接即可下载：\n\n![image-20220428210732298](http://img.liubaiblog.top/img/image-20220428210732298.png)\n\n需要注意的是，`redis` 官网中是下载不到 `Windows` 系统中使用的版本的，这种方式下载的只是 `.tar.gz` 的压缩包，这个压缩包是给 `Linux` 平台使用的，通常，我们也不再 `Windows` 平台中使用 `redis` 。\n\n如果非要在 `Windows` 中下载 `redis` ，也是有方式的，微软在 `Github` 中帮我们打包了 `redis` ，我们可以[访问其 `Github` ](https://github.com/MicrosoftArchive/redis/releases)下载 `Windows` 平台下 `redis` 的压缩包。\n\n![image-20220428211130210](http://img.liubaiblog.top/img/image-20220428211130210.png)\n\n下载后直接解压即可在 `Windows` 中使用 `redis` 了。\n\n![image-20220428211441456](http://img.liubaiblog.top/img/image-20220428211441456.png)\n\n不过建议还是要学习下面的方法，也要会在 `Linux` 平台中安装 `redis` ，下面我们以 `CentOs7` 为例，演示 `Linux` 中安装 `redis` 的方式。\n\n\n\n# 安装\n\n## 下载 `gcc` 编译器\n\n由于 redis 是用 C 语言编写的，所以 Linux 中要先有 C 语言的编译环境，所以我们需要下载最新的 `gcc ` 编译器。\n\n下载 `gcc` 编译器的方式非常简单，依次输入以下命令即可：\n\n```bash\n$ yum install centos-release-scl scl-utils-build\n$ yum install -y devtoolset-8-toolchain\n$ scl enable devtoolset-8 bash\n```\n\n安装完成后，使用以下命令，可以查看 `gcc` 版本：\n\n```bash\n[root@localhost opt]# gcc --version\ngcc (GCC) 8.3.1 20190311 (Red Hat 8.3.1-3)\nCopyright (C) 2018 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n```\n\n\n\n## 安装 `Redis` \n\n在官网下载 `redis` 的 `.tar.gz` 包后，我们需要把这个包上传到 `Linux` 服务器的 `/opt` 目录下，上传的方式有很多，在学习 `Linux` 阶段应该以及学过，这里不再赘述。\n\n然后我们在 `/opt` 目录下，执行如下命令解压这个压缩包：\n\n```bash\n[root@localhost opt]# tar -zxvf redis-7.0.0.tar.gz \n```\n\n解压完成后，在 `/opt` 目录下就会多一个解压后的包，我们进入该目录，并且执行 `make` 命令编译程序：\n\n```bash\n[root@localhost opt]# cd redis-7.0.0/\n[root@localhost redis-7.0.0]# make\n```\n\n编译需要一段时间，耐心等待即可，如果 C 语言编译环境出现问题，`make` 会报错— `Jemalloc/jemalloc.h：没有那个文件` ，解决方案就是再运行以下 `make distclean` ，然后再 `redis` 的目录下再次执行 `make` 命令即可。\n\n执行完以上的步骤，只是编译好了 `redis` 相关的文件，但是我们还要进行安装，执行 `make install` 命令即可完成安装\n\n```bash\n[root@localhost redis-7.0.0]# make install\n```\n\n等待一段时间安装完成后，`redis` 会默认安装再 `/usr/local/bin` 目录中，我们可以切换到该目录查看其目录结构。\n\n```bash\n[root@localhost redis-7.0.0]# cd /usr/local/bin/\n[root@localhost bin]# ls\nredis-benchmark  redis-check-rdb  redis-sentinel\nredis-check-aof  redis-cli        redis-server\n```\n\n查看默认安装目录：\n\n- `redis-benchmark` ：性能测试工具，可以在自己本子运行，看看自己本子性能如何\n- `redis-check-aof` ：修复有问题的AOF文件，rdb和aof后面讲\n- `redis-check-dump` ：修复有问题的dump.rdb文件\n- `redis-sentinel` ：Redis集群使用\n- **`redis-server` ：Redis服务器启动命令**\n- **`redis-cli` ：客户端，操作入口\n\n\n\n## 启动 `Redis`\n\n启动 `Redis` 的方式有两种，分别是前台启动和后台启动。\n\n### 前台启动\n\n我们不推荐使用前台启动的方式，因为前台启动当终端关闭后，则该服务也会停止，并且前台运行会占用整个终端页面，让该终端无法执行任何操作。\n\n![image-20220428204629343](http://img.liubaiblog.top/img/image-20220428204629343.png)\n\n\n\n### 后台启动(推荐)\n\n后台启动是比较推荐的方式，`redis` 会在后台运行，而不会在终端中直接显示。\n\n但是后台启动需要操作 `redis` 的配置文件，我们建议先备份一下配置文件，以防配置错误不好还原。\n\n```bash\n[root@localhost bin]# mkdir /my_redis_bak\n[root@localhost bin]# cp /opt/redis-7.0.0/redis.conf /my_redis_bak/\n[root@localhost bin]# ls /my_redis_bak/\nredis.conf\n```\n\n然后到 `/opt/redis-7.0.0/` 目录下，修改配置文件，将文件将里面的 `daemonize no` 改成 `yes`，让服务在后台启动。\n\n```bash\n[root@localhost bin]# cd /opt/redis-7.0.0/\n[root@localhost redis-7.0.0]# vim redis.conf \n```\n\n![image-20220428205057627](http://img.liubaiblog.top/img/image-20220428205057627.png)\n\n**注意，配置文件一定要保存，保存方式是 `ESC` 后输出 `:wq` 。**\n\n然后我们就可以启动服务了，不过启动服务时还需要指定配置文件，不然默认是前台启动。\n\n```bash\n[root@localhost redis-7.0.0]# redis-server /opt/redis-7.0.0/redis.conf \n```\n\n这个时候程序就后台启动了，在前台页面是看不出来的，我们可以进行 `redis` 客户端来测试，客户端中输入 `ping` 会显示 `PONG` 则启动成功\n\n```bash\n[root@localhost redis-7.0.0]# redis-cli \n127.0.0.1:6379> ping\nPONG\n```\n\n\n\n## 关闭 `Redis`\n\n如果是前台启动，按 `Ctrl+C` 或者关闭终端，都可以关闭 `redis` 。\n\n但是如果是后台启动，就需要用命令关闭，我们可以不进入 `redis` 客户端关闭：\n\n```bash\n[root@localhost redis-7.0.0]# redis-cli shutdown\n```\n\n也可以进入终端后关闭：\n\n```bash\n[root@localhost redis-7.0.0]# redis-cli \n127.0.0.1:6379> shutdown\n```\n\n如果开启了多个实例，需要指定端口进行关闭：\n\n```bash\n[root@localhost redis-7.0.0]# redis-cli -p 6379 shutdown\n```\n\n我们还可以使用 `linux` 为我们提供的 `ps -ef` 命令查看进程，然后使用 `kill -9` 杀死进程的方式关闭 `redis` 。\n\n\n\n# `Redis` 相关知识\n\n`redis` 的端口默认是 `6379` ，并且默认有 16 个数据库，默认选择的是 0 数据库，使用命令 `select <dbid>` 来切换数据库，这 16 个数据库使用相同的密码。\n\n```bash\n127.0.0.1:6379> SELECT 1\nOK\n127.0.0.1:6379[1]> SELECT 0\nOK\n127.0.0.1:6379> \n```\n\n\n\n`redis` 和其他 NoSQL 数据库的不同，**`redis` 采用的是单线程 + 多路IO复用技术**，而如 `Memcache` 采用的是多线程 + 锁的方式。\n\n多路复用是指使用一个线程来检查多个文件描述符（ `Socket` ）的就绪状态，比如调用 `select` 和 `poll` 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。\n\n与 `Memcache` 的三点不同: \n\n- 支持多数据类型。\n- 支持持久化。\n- 单线程+多路IO复用。\n\n\n\n# 常用五大数据类型和命令\n\n本课程仅介绍一些简单的 `redis` 命令，关于 `redis` 的更多命令，可以见：http://www.redis.cn/commands.html#\n\n## `Redis` 键( `key` )\n\n`keys *` ：查看当前库中的所有 `key` ，如果需要模糊匹配，可如 `keys a*` ，表示匹配所有以 `a` 开头的键。\n\n`exists <key>` ：判断某个 `key` 是否存在。\n\n`type <key>` ：查看你的 `key` 是什么数据类型。\n\n`del <key>` ：删除指定的 `key` 及其值。\n\n`unlink <key>` ：根据 `value` 选择非阻塞删除。仅将 `keys` 从 `keyspace` 元数据中删除，真正的删除会在后续异步操作。\n\n`expire <key> <seconds>` ：为给定的 `key` 设置过期时间，单位：秒。\n\n`ttl <key>` ：查看还有多少秒过期，-1 表示永不过期，-2 表示已过期。\n\n`dbsize` ：查看当前数据库的 `key` 数量。\n\n`flushdb` ：清空当前数据库。\n\n`flushall` ：清空全部库！\n\n\n\n## 字符串类型( `String` )\n\n### 简介\n\n`String` 是 `redis` 最基本的类型，你可以理解成与 `Memcached` 一模一样的类型，一个 `key` 对应一个 `value` 。\n\n`String` 类型是二进制安全的。意味着 `redis` 的 `String` 可以包含任何数据。比如 `jpg` 图片或者序列化的对象。\n\n`String` 类型是 ` Redis` 最基本的数据类型，一个 `redis` 中字符串 `value` 最多可以是**512M**。\n\n\n\n### 常用命令\n\n**`set <key> <val>` ：以键值对的形式插入新的数据。当数据库 `key` 存在时，再执行 `set` 命令会覆盖原来的值。**\n\n**`get <key>` ：根据 `key` 获取对应的值。**\n\n`append <key> <val>` ：将 `key` 对应的值后追加 `value` 值，返回最终字符串的长度。\n\n**`strlen <key>` ：获取指定 `key` 的值的字符串长度。**\n\n`setnx <key> <val>` ：只有当 `key` 不存在时，设置 `key` 的值。\n\n**`setex <key> <seconds> <val>` ：设置键值对同时指定 `key` 的过期时间，单位：秒。**\n\n`getset <key> <val>` ：以新值换旧值，也就是这个方法会返回 `key` 原来的值，方法执行完后 `key` 的值被替换成新 `val` 值。\n\n`mset <key> <val> <key> <val> ...` ：同时设置一个或多个键值对。\n\n`msetnx <key> <val> <key> <val> ...` ：同时设置一个或多个键值对，当其中一个 `key` 已存在，则整行插入失效(原子性)。\n\n`getrange <key> <start> <end> ` ：`start` 和 `end` 需要是数值，表示截取 `key` 的值从 `start` 开始到 `end` 结束的子字符串。\n\n`setrange <key> <start> <val>` ：`start` 需要是数值，表示将 `key` 的值从 `start` 开始覆写 `val` 长度的字符串。=\n\n`incr <key>` ：只能对纯数字字符串操作，将 `key` 中存储的值自增1。\n\n`decr <key>` ：只能对纯数字字符串操作，将 `key` 中存储的值自减1。\n\n`incrby <key> <val>`  ：只能对纯数字字符串操作，将 `key` 中存储的值自增 `val` 值。\n\n`decrby <key> <val>`  ：只能对纯数字字符串操作，将 `key` 中存储的值自减 `val` 值。\n\n注意，这里的自增和自减是原子性的操作，但是这里的原子性操作不是关系型数据库中的原子性操作，这里的原子性操作是指一个操作不会被线程调度机制打断，也就是这种操作一旦开始，就会一直运行到结束，中间不会切换到另一个线程。\n\n- 在单线程中， 能够在单条指令中完成的操作都可以认为是\"原子操作\"，因为中断只能发生于指令之间。\n\n- 在多线程中，不能被其它进程(线程)打断的操作就叫原子操作。\n\nRedis单命令的原子性主要得益于Redis的单线程。\n\n\n\n### 数据结构\n\nString的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。\n\n![image-20220428225142790](http://img.liubaiblog.top/img/image-20220428225142790.png)\n\n如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。==需要注意的是字符串最大长度为512M。==\n\n\n\n## 列表类型( `List` )\n\n### 简介\n\n通过 `redis` 的列表，可以实现单键多值的操作，和 `Java` 的 `List` 集合类似。\n\n`redis` 列表是简单的字符串列表，按照插入顺序，我们可以添加一个元素到元素的**头部(左边)**或者**尾部(右边)**。\n\n它的底层实际上是个双向列表，对两端的操作性都很高，通过索引下标进行操作，所以操作中间结点的性能会较差。\n\n![image-20220429144434241](http://img.liubaiblog.top/img/image-20220429144434241.png)\n\n\n\n### 常用命令\n\n**`lpush/rpush <key> <val1> <val2> ...` ：从左边/右边为某个键插入多个值，左边插入使用的是头插法，右边插入使用的是尾插法。**\n\n**`lpop/rpop <key> [count]` ：从左边/右边为将某个键列表弹出 `count` 个值，`count` 可选，默认为1，返回值是弹出的值。当某个 `key` 列表值全部弹出，该列表则被销毁。**\n\n`rpoplpush <key1> <key2>` ：将 `key1` 列表从右边弹出一个值，并且插入到 `key2` 列表左边，返回值是弹出的这个值。\n\n**`lrange <key> <start> <stop>` ：按照索引从左到右获取元素，`start` 和 `stop` 表示起始和结束下标，`0` 到 `-1` 表示获取整个列表。**\n\n`lindex <key> <index>` ：从左到右获取 `key` 列表第 `index` 个元素。\n\n**`llen <key>` ：获取某个 `key` 列表长度。**\n\n`linsert <key> <before|after> <val> <newVal>` ：在某个 `key` 列表的 `val` 元素之前/之后插入新的值 `newVal` 。\n\n`lrem <key> <count> <val>` ：从左边开始删除 `key` 列表中 `count` 个 `val` 值。\n\n`lset <key> <index> <val>` ：将 `key` 列表下标为 `index` 的值替换成 `val` 。\n\n\n\n### 数据结构\n\n`redis` 中 `list` 的数据结构为快速链表 `quickList`.\n\n首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表，它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 `quicklist` 。\n\n因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。\n\n![image-20220429151712361](http://img.liubaiblog.top/img/image-20220429151712361.png)\n\n`Redis` 将链表和 `ziplist` 结合起来组成了 `quicklist` 。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。\n\n\n\n## 集合类型 ( `Set` )\n\n### 简介\n\n`Redis set` 对外提供的功能与 `list` 类似是一个列表的功能，特殊之处在于 `set` 是可以**自动排重**的，当你需要存储一个列表数据，又不希望出现重复数据时，`set` 是一个很好的选择，并且 `set` 提供了判断某个成员是否在一个 `set` 集合内的重要接口，这个也是list所不能提供的。\n\n`redis` 的 `set` 是一个字符串类型的无序集合，它底层其实是一个 `value` 为 `null` 的 `Hash` 表，所以添加、删除、查找的时间复杂度都是 O(1)。\n\nO(1) 是指一个算法，随着数据的增加，执行时间的长度，如果是 O(1)，数据增加，查找数据的时间不变。\n\n\n\n### 常用命令\n\n**`sadd <key> <val1> <val2> ...` ：将一个或多个元素添加到 `key` 集合当中，已经存在的元素会被忽略。**\n\n**`smembers <key>` ：取出该集合的所有值(值是无序的)。**\n\n**`sismember<key> <val>` ：判断 `key` 集合中是否包含 `val` 值，若有返回1，否则返回0。**\n\n**`scard <key>` ：返回该集合的元素个数。**\n\n`srem <key> <val1> <val2> ...` ：从 `key` 集合中删除一个或多个 `val` 元素。\n\n`spop <key> [count]` ：随机从 `key` 集合中弹出 `count` 个元素，`count` 可选，默认为1。\n\n`srandmember <key> [count]` ：随机从 `key` 集合中获取 `count` 个元素，`count` 可选，默认为1，此操作并不会让元素从集合中删除。\n\n`smove <source> <dest> <val>` ：从 `source` 集合中取出 `val` 值，并移动到 `dest` 集合中，此操作会使 `source` 集合失去 `val` 元素。\n\n`sinter <key1> <key2> ...` ： 返回多个 `key` 集合中的交集。\n\n`sunion <key1> <key2> ...` ：返回多个 `key` 集合中的并集，重合部分会被忽略。\n\n`sdiff <key1> <key2> ...` ：返回 `key1` 集合与其他集合差集( `key1` 集合存在的，其他集合不存在的)。\n\n\n\n### 数据结构\n\n`Set` 数据结构是 `dict` 字典，字典是用哈希表实现的。`Java` 中 `HashSet` 的内部实现使用的是 `HashMap`，只不过所有的value都指向同一个对象。`Redis` 的 `set` 结构也是一样，它的内部也使用 `hash` 结构，所有的 `value` 都指向同一个内部值。\n\n\n\n## 有序集合( `Zset` )\n\n### 简介\n\n`Redis` 有序集合 `zset` 与普通集合 `set` 非常相似，是一个没有重复元素的字符串集合。\n\n不同之处是有序集合的每个成员都关联了一个**评分( `score`)**，这个评分( `score` )被用来按照从最低分到最高分的方式排序集合中的成员。**集合的成员是唯一的，但是评分可以是重复的 。**\n\n因为元素是有序的, 所以你也可以很快的根据评分( `score` )或者次序( `position` )来获取一个范围的元素。\n\n访问有序集合的中间元素也是非常快的,因此你能够使用有序集合**作为一个没有重复成员的智能列表**。\n\n\n\n### 常用命令\n\n`zadd <key> <score1> <member1> <score2> <member2> ...` ：将一个或多个元素 `member` 加入到有序集合 `key` 中，`score` 必须为整形。\n\n`zrange <key> <start> <stop> [withscores]` ：返回有序集合 `key` 的 `start` 到 `stop` 位置的元素，默认按 `score` 从小到大排序，`withscores` 参数可选，可以让显示元素的同时显示 `score` ，当 `start` 和 `stop` 为 `0` 和 `-1` 表示返回全部结果。\n\n`zrangebyscore <key> <min> <max> [withscores] ` ：返回有序集合 `key` 中介于 `min` 和 `max` 评分之间(含两者)的元素，按照从小到大排序，`withscores` 参数同上。\n\n`zrevrangebyscore <key> <max> <min> [withscores]` ：效果同上，但是按照从大到小排序。\n\n`zincrby <key> <increment> <member>` ：将有序集合 `key` 的 `member` 元素的评分 `score` 增加上 `increment` 。\n\n`zrem <key> <member1> <member2> ...` ：删除有序集合`key` 的一个或多个 `member` 元素。\n\n`zcount <key> <min> <max>` ：统计该集合 `key` 中，介于 `min` 和 `max` 评分(含两者)的元素个数。\n\n`zrank <key> <member>` ：返回该 `member` 元素在 `key` 集合中的排名，排名从0开始。\n\n\n\n**范例：如何利用 `Zset` 实现排行榜的功能？**\n\n![image-20220429170317106](http://img.liubaiblog.top/img/image-20220429170317106.png)\n\n### 数据结构\n\n`SortedSet(zset)` 是 `Redis` 提供的一个非常特别的数据结构，一方面它等价于 `Java` 的数据结构 `Map<String, Double>` ，可以给每一个元素 `value` 赋予一个权重 `score` ，另一方面它又类似于 `TreeSet` ，内部的元素会按照权重 `score` 进行排序，可以得到每个元素的名次，还可以通过 `score` 的范围来获取元素的列表。\n\n`zset` 底层使用了两个数据结构\n\n- `hash` ，`hash` 的作用就是关联元素 `value` 和权重 `score` ，保障元素 `value` 的唯一性，可以通过元素 `value` 找到相应的 `score` 值。\n\n- 跳跃表，跳跃表的目的在于给元素 `value` 排序，根据 `score` 的范围获取元素列表。\n\n\n\n### [扩展阅读] 跳跃表\n\n有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。\n\n对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。`Redis` 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。\n\n\n\n**实例**\n\n对比有序链表和跳跃表，从链表中查询出：\n\n> **有序链表**\n\n![image-20220429170756860](http://img.liubaiblog.top/img/image-20220429170756860.png)\n\n要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。\n\n> **跳跃表**\n\n![image-20220429170839022](http://img.liubaiblog.top/img/image-20220429170839022.png)\n\n从第2层开始，1节点比51节点小，向后比较。\n\n21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层\n\n在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下\n\n在第0层，51节点为要查找的节点，节点被找到，共查找4次。\n\n从此可以看出跳跃表比有序链表效率要高。\n\n\n\n## 哈希表( `Hash` )\n\n### 简介\n\n`redis` 的 `hash` 是一个键值对的集合，由一个字符串类型的 `field` 和 `value` 的映射表，`hash` 特别适合存储对象，类似于 `Java` 中的 `Map<String, Object>` 。\n\n比如我们存储一个用户对象通常有如下三种方式：\n\n- 将用户对象序列化成 `json` 格式的字符串，以字符串方式存储用户对象，`key` 可以为用户ID。缺点：需要频繁的序列化和反序列化。\n- 将用户对象的属性以 `userId:field` 的形式作为 `key` ，而用户属性值作为该 `key` 的值。缺点：用户ID数据冗余。\n- **将用户对象存储为 `hash` 的形式，用户ID作为 `hash` 表的 `key` 。这样既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。**\n\n\n\n### 常用命令\n\n**`hset <key> <field> <val>` ：将 `key` 表中的 `field` 字段赋值为 `val` 。**\n\n`hsetnx <key> <field> <val>` ：将 `key` 表中的 `field` 字段赋值为 `val` ，但是若 `field` 字段已存在，则不执行操作。\n\n**`hget <key> <field>` ：从 `key` 表中获取 `field` 字段的值。**\n\n**`hmset <key> <field1> <val1> <filed2> <val2> ...` ：批量给 `key` 表中添加键值对。**\n\n**`hdel <key> <field1> <field2> ...` ：为 `key` 表删除一个或多个 `field` 。**\n\n`hexists <key> <field>` ：判断 `key` 表中 `field` 字段是否存在，若存在则返回1，否则返回0。\n\n`hkeys <key>` ：查看 `key` 表的所有 `field` 字段。\n\n`hvals <key>` ：查看 `key` 表的所有 `value` 值。\n\n`hincrby <key> <field> <increment>` ：为 `key` 表的 `field` 字段自增 `increment` 值，`field` 字段必须为整形。\n\n\n\n### 数据结构\n\nHash类型对应的数据结构是两种：\n\n- `ziplist` (压缩列表)。\n\n- `hashtable` (哈希表)。\n\n当 `field` - `value` 长度较短且个数较少时，使用 `ziplist` ，否则使用 `hashtable` 。\n\n\n\n# `Redis` 配置文件介绍\n\n`redis` 的配置文件分成了好几个部分，每个部分前面官方都用多个 `###` 进行了标识，下面我们就对于这些部分依次进行讲解。\n\n如果对配置文件进行了修改，我们保存文件后，需要重新启动 `redis` 服务才能生效。\n\n\n\n## Units (单位)\n\n配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit，并且大小写不敏感。\n\n```\n# Note on units: when memory size is needed, it is possible to specify\n# it in the usual form of 1k 5GB 4M and so forth:\n#\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n```\n\n\n\n## INCLUDE (包含)\n\n在这个部分我们可以将其他配置文件的内容包含到此配置文件，类似 `jsp` 中的 `include` ，多实例的情况可以把公用的配置文件提取出来。\n\n```\n################ INCLUDE ################\n# 表示包含 /etc/myredis/ 目录下的所有 `.conf` 配置文件\ninclude /etc/myredis/*.conf\n```\n\n\n\n## NETWORK (网络)\n\n**常用配置**：\n\n- `bind` ：绑定允许访问的 `ip` ，默认为 `127.0.0.1` ，即只允许本机访问， 我们注释掉这行代码即可允许任何 `ip` 地址访问。\n- `protected-mode` ：将本机访问保护模式设置 `no` 。如果需要任何机器都能访问，需要设置为 `yes` 。\n\n- `port` ：`redis` 占用的端口号。\n\n- `tcp-backlog` ：设置 `tcp` 的 `backlog` ，`backlog` 其实是一个连接队列，`backlog` 队列总和 = 未完成三次握手队列 + 已经完成三次握手队列。\n\n    - 在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。\n\n    - 注意Linux内核会将这个值减小 `/proc/sys/net/core/somaxconn` 到的值(128)，所以需要确认增大 `/proc/sys/net/core/somaxconn` 和 `/proc/sys/net/ipv4/tcp_max_syn_backlog` (128)两个值来达到想要的效果。\n\n- `timeout` ：一个空闲的客户端维持多少秒关闭会话，默认为0表示关闭该功能，即永不关闭。\n- `tcp-keepalive` ：对访问的客户端进行心跳检测，每 n 秒检测一次。单位为秒，如果设置为0，则不会进行 `Keepalive` 检测，建议设置成60 。\n\n\n\n## GENERAL (通用)\n\n常用配置：\n\n- `daemonize` ：是否为后台进程，设置为 `yes` ，表示守护进程，后台启动。\n- `pidfile` ：存放 `pid` 文件的位置，每个实例会产生一个不同的 `pid` 文件。\n- `loglevel` ：指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice。\n\n```\n# debug (a lot of information, useful for development/testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged)\n```\n\n- `logfile` ：日志文件名称，默认为空\n- `databases 16` ：设定库的数量默认16，默认数据库为0，可以使用 `SELECT <dbid>` 命令在连接上指定数据库id。\n\n\n\n## SECURITY (安全)\n\n常用配置：\n\n- `requirepass` ：配置项后可以设置密码，这是永久设置密码，默认无密码。\n\n```bash\n# 如果我们不需要永久设置密码，我们可以设置临时密码\n# 这个临时密码仅对当次服务生效，重启redis服务后失效\n127.0.0.1:6379> config get requirepass # 获取密码\n127.0.0.1:6379> config set requirepass \"123456\"	# 设置临时密码\n127.0.0.1:6379> auth 123456	# 进行密码认证\n```\n\n\n\n## LIMITS (限制)\n\n常用配置：\n\n- `maxclients` ：设置 `redis` 同时可以与多少个客户端进行连接，默认为1000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。\n- `maxmemory` ：建议**必须设置**，否则，将内存占满，造成服务器宕机。\n    - 设置 `redis` 可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过 `maxmemory-policy` 来指定。\n    - 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。\n    - 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。\n- `maxmemory-policy` ：\n    - `volatile-lru`：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）\n    - `allkeys-lru`：在所有集合key中，使用LRU算法移除key\n    - `volatile-random`：在过期集合中移除随机的key，只对设置了过期时间的键\n    - `allkeys-random`：在所有集合key中，移除随机的key\n    - `volatile-ttl`：移除那些TTL值最小的key，即那些最近要过期的key\n    - `noeviction`：不进行移除。针对写操作，只是返回错误信息\n- `maxmemory-samples` ：\n    - 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。\n    - 一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。\n\n\n\n# 发布和订阅\n\n## 什么是发布和订阅\n\n`redis` 发布订阅 (pub/sub) 是一种消息通信模式，发送者 (pub) 发送消息，`redis` 客户端可以订阅任意数量的频道。\n\n\n\n## `Redis` 的发布和订阅\n\n客户端可以订阅频道，如下图：\n\n![image-20220429201755048](http://img.liubaiblog.top/img/image-20220429201755048.png)\n\n当给这个评到发布消息后，消息就会发送给订阅的客户端。\n\n![image-20220429201823601](http://img.liubaiblog.top/img/image-20220429201823601.png)\n\n\n\n## 命令行实现\n\n**订阅**：打开客户端A，输入如下命令订阅 `channel1` 。\n\n```sh\n127.0.0.1:6379> subscribe channel1\n```\n\n![image-20220429202105743](http://img.liubaiblog.top/img/image-20220429202105743.png)\n\n**发布**：打开客户端B，给 `channel1` 发布一个消息 `hello` 。\n\n```sh\n127.0.0.1:6379> publish channel1 hello\n(integer) 1\n```\n\n![image-20220429202156606](http://img.liubaiblog.top/img/image-20220429202156606.png)\n\n**结果**：返回第一个客户端，可以看到客户端B发布的消息 `hello` 。\n\n![image-20220429202256271](http://img.liubaiblog.top/img/image-20220429202256271.png)\n\n注意：发布的消息没有持久化，如果在订阅的客户端收不到 `hello` ，只能收到订阅后发布消息。\n\n\n\n# 新数据类型\n\n## `BitMaps`\n\n### 简介\n\n`bitmaps` 也叫位图，也就是用一个bit位来表示一个东西的状态，我们都知道bit位是二进制，所以只有两种状态，0和1。\n\n但 `bitmaps` 实际上也是字符串，只不过它可以单独对字符串进行位操作。\n\n我们也可以把 `bitmaps` 想象成一个数组，但是数组的每个单元只能存储0和1，数组的下标在 `bitmaps` 中叫做便宜量。所以 `bitmaps` 就适合存储只有两种状态的数据，比如用户是否登录，用户是否签到...\n\n\n\n### 常用命令\n\n`setbit <key> <offset> <val>` ：设置 `bitmaps` 的键为 `key` ，在 `offset` 偏移量中的值为 `val` ，注意，这个值只能为 0 或 1。\n\n`getbit <key> <offset>` ：获取 `key` 表的 `offset` 偏移量中的值。\n\n`bitcount <key> [start] [end] [byte|bit]` ：获取 `key` 表中被设置为 1 的 `bit` 个数。通过 `start` 和 `end` 可以设置需要统计的位数，单位默认是 `byte` ，也可以设置为 `bit` (我的版本是 `redis7.0`，较低版本可能无法设置单位，故默认单位为 `byte` ) 。\n\n`bittop <operation> <destkey> <key1> <key2> ...` ：这是一个复合操作，可以把多个 `key` 表进行与( `and` )、或( `or` )、非( `not` ) 、异或( `xor` ) 操作，操作方式放在 `operation` 位置，并且把操作的结构放在 `destkey` 表。\n\n\n\n### 简单应用\n\n统计某天登录的用户，我们可以以当天的日期作为键，以用户的id作为偏移量，用户登录则记为1，否则记为0。\n\n当用户登录后，我们可以将该用户的id作为偏移量，并设置该位为1。\n\n```sh\n127.0.0.1:6379> setbit users:20221102 10 1\n(integer) 0\n127.0.0.1:6379> setbit users:20221102 12 1\n(integer) 0\n127.0.0.1:6379> setbit users:20221102 7 1\n(integer) 0\n127.0.0.1:6379> setbit users:20221102 15 1\n(integer) 0\n127.0.0.1:6379> setbit users:20221102 20 1\n(integer) 0\n```\n\n如果需要查询某个用户是否登录，我们只需要查询其id的偏移量是否为1\n\n```sh\n127.0.0.1:6379> getbit users:20221102 7	\n(integer) 1		# 已登录\n127.0.0.1:6379> getbit users:20221102 28\n(integer) 0		# 未登录\n```\n\n如果需要统计该天在线的用户数量，我们使用 `bitcount` ：\n\n```sh\n127.0.0.1:6379> bitcount users:20221102 # 统计全部\n(integer) 4\n127.0.0.1:6379> bitcount users:20221102 0 1	# 表示统计0字节组和1字节组的bit为1的个数\n(integer) 4	\n```\n\n第二天，又有一些登录用户，我们和往常一样，记录下这些用户的登录状态。\n\n```sh\n127.0.0.1:6379> getbit users:and:20221103 10\n(integer) 1\n127.0.0.1:6379> getbit users:and:20221103 20\n(integer) 1\n```\n\n然后我们需要统计两天都登录的用户个数，那么我们就可以对两个表进行与操作。\n\n```sh\n127.0.0.1:6379> bitop and users:and:20221104 users:20221102 users:20221103 users:and:20221103\n(integer) 3\n127.0.0.1:6379> bitcount users:and:20221103\n(integer) 2		# 两天都登录的用户只有两个\n```\n\n如果只要统计这两天中，任意一天登录过的用户，那么就使用或操作。\n\n> **注意：很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。**\n>\n> **在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。**\n\n\n\n## `HyperLogLog`\n\n### 简介\n\n在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 `PV` ( `PageView` 页面访问量)，可以使用 `Redis` 的 `incr` 、`incrby` 轻松实现。\n\n但像 `UV` ( `UniqueVisitor` ，独立访客)、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。\n\n解决基数问题有很多种方案：\n\n- 数据存储在MySQL表中，使用distinct count计算不重复个数\n\n- 使用Redis提供的hash、set、bitmaps等数据结构来处理\n\n以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。\n\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n\n**什么是基数**?\n\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。\n\n\n\n### 常用命令\n\n`pfadd <key> <element1> <element2> ...` ：添加一个或多个元素到 `HLL` 当中，重复的 `element` 会被忽略，并且只统计 `element` 的基数。\n\n`pfcount <key1> <key2> ... ` ：计算 `HLL` 的基数，可以计算多个 `HLL` 。\n\n`pfmerge <destkey> <sourcekey1> <sourcekey2> ...` ：将多个 `sourcekey` 表合并到 `destkey` 表当中。\n\n\n\n## `Geospatial`\n\n### 简介\n\nRedis 3.2 中增加了对GEO类型的支持。GEO (Geographic) 地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。`redis` 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。\n\n\n\n### 常用命令\n\n`geoadd <key> <longitude> <latitude> <member> ...` ：向 `key` 表中添加一个地理位置，根据经度、纬度、名称。经纬度为 `double` 类型。\n\n`geopos <key> <member1> <member2> ... ` ：获取指定地区的坐标值(经度、纬度) 。\n\n`geodist <key> <member1> <member2> [m|km|ft|mi]` ：获取两个地址之间的直线距离，后面可以跟上单位。\n\n`georadius <key> <longitude> <latitude> <radius> [m|km|ft|mi]` ： 以给定的经纬度为中心，找出 `radius` 半径范围内的所有元素，`radius` 需要是整形，后面可以跟上单位。\n\n**单位**\n\n- m 表示单位为米[默认值]。\n- km 表示单位为千米。\n- mi 表示单位为英里。\n- ft 表示单位为英尺。\n\n如果用户没有显式地指定单位参数， 那么默认使用米作为单位。\n\n\n\n### 范例\n\n```sh\n# 创建坐标\n127.0.0.1:6379> geoadd china:city 121.47 31.23 shanghai\n(integer) 1\n127.0.0.1:6379> geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing\n(integer) 3\n# 查询坐标\n127.0.0.1:6379> geopos china:city shanghai\n1) 1) \"121.47000163793563843\"\n   2) \"31.22999903975783553\"\n127.0.0.1:6379> geopos china:city beijing\n1) 1) \"116.38000041246414185\"\n   2) \"39.90000009167092543\"\n# 获取两地直线距离\n127.0.0.1:6379> geodist china:city shanghai beijing km\n\"1068.1535\"\n127.0.0.1:6379> geodist china:city shanghai chongqing m\n\"1447673.6920\"\n# 获取指定坐标1000km半径范围的城市\n127.0.0.1:6379> georadius china:city 110 30 1000 km\n1) \"chongqing\"\n2) \"shenzhen\"\n```\n\n\n\n---\n\n**本章完。**\n','<h1><a id=\"_0\"></a>引入</h1>\n<p>在学习这门课程之前，大家可能或多或少了解过 Redis，它是一门 NoSQL 数据库，在引入部分，我们可以先了解以下这么技术是做什么的。</p>\n<h2><a id=\"Web_10__4\"></a>Web 1.0 时代</h2>\n<p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428161938450.png\" alt=\"image-20220428161938450\" /></p>\n<h2><a id=\"Web_20__10\"></a>Web 2.0 时代</h2>\n<p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428162220231.png\" alt=\"image-20220428162220231\" /></p>\n<p>所以我们就需要解决这些压力。</p>\n<h3><a id=\"_CPU__18\"></a>解决 CPU 及内存压力</h3>\n<p><img src=\"http://img.liubaiblog.top/img/1.jpg\" alt=\"1\" /></p>\n<p>可以看出来，使用缓存数据库是这几种方案中，最合适的一种方式。而 Redis 就是缓存数据库，可以缓存各个服务器中的 <code>Session</code> ，各个服务器都可以来读取这个缓存服务器中的 <code>Session</code> ，从而降低应用服务器中的 CPU 及内存压力。</p>\n<h3><a id=\"_IO__26\"></a>解决 IO 压力</h3>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428162827989.png\" alt=\"image-20220428162827989\" /></p>\n<p>缓存数据库中，还可以将关系数据库中存储的数据，缓存到缓存数据库中，这样用户下次访问的时候，就可以到缓存数据库中取，所以也可以降低关系数据库 IO 压力。</p>\n<h1><a id=\"NoSQL__34\"></a>NoSQL 数据库</h1>\n<h2><a id=\"_36\"></a>概述</h2>\n<p>NoSQL(Not Only SQL)，意为“不仅仅是SQL”，泛指非关系型数据库，我们现在要学的 Redis 就是非关系型数据库；而之前学习的 MySQL 就是关系型数据库。</p>\n<p>NoSQL 不依赖业务逻辑方式存储，而是以简单的 key-value 模式存储，因此大大的增加了数据库的扩展能力。</p>\n<p><strong>NoSQL 数据库的特点是</strong>：</p>\n<ul>\n<li>不遵循 SQL 标准。</li>\n<li>不支持 ACID (但不是不支持事务!)</li>\n<li>远超于 SQL 的性能。</li>\n</ul>\n<p><strong>NoSQL 使用场景</strong></p>\n<ul>\n<li>\n<p>对数据高并发的读写</p>\n</li>\n<li>\n<p>海量数据的读写</p>\n</li>\n<li>\n<p>对数据高可扩展性的</p>\n</li>\n</ul>\n<p><strong>NoSQL 不适用场景</strong></p>\n<ul>\n<li>需要事务支持</li>\n<li>基于 SQL 的结构化查询存储，处理复杂的关系，需要即席查询</li>\n</ul>\n<p><strong>注意：用不着 SQL 和用了 SQL 也不行的情况，请考虑使用 NoSQL。</strong></p>\n<p>常见的 NoSQL 数据库有 <code>memcached</code> 、<code>redis</code> 、<code>mongodb</code> ，我们这门课程主要学习 <code>redis</code> ，其他数据库可以自行简单了解。</p>\n<h1><a id=\"Redis__70\"></a><code>Redis</code> 介绍</h1>\n<blockquote>\n<p><strong>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</strong></p>\n</blockquote>\n<p>使用 <code>redis</code> 可以做：</p>\n<ul>\n<li>\n<p>高频次，热门访问的数据，降低数据库IO</p>\n</li>\n<li>\n<p>分布式架构，做session共享</p>\n</li>\n</ul>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428210459141.png\" alt=\"image-20220428210459141\" /></p>\n<p><strong>多样的数据结构存储持久化数据</strong></p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428210526370.png\" alt=\"image-20220428210526370\" /></p>\n<h1><a id=\"_88\"></a>下载</h1>\n<p>访问 <code>redis</code> <a href=\"https://redis.io/download/\" target=\"_blank\">官网</a>，点击如下位置链接即可下载：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428210732298.png\" alt=\"image-20220428210732298\" /></p>\n<p>需要注意的是，<code>redis</code> 官网中是下载不到 <code>Windows</code> 系统中使用的版本的，这种方式下载的只是 <code>.tar.gz</code> 的压缩包，这个压缩包是给 <code>Linux</code> 平台使用的，通常，我们也不再 <code>Windows</code> 平台中使用 <code>redis</code> 。</p>\n<p>如果非要在 <code>Windows</code> 中下载 <code>redis</code> ，也是有方式的，微软在 <code>Github</code> 中帮我们打包了 <code>redis</code> ，我们可以<a href=\"https://github.com/MicrosoftArchive/redis/releases\" target=\"_blank\">访问其 <code>Github</code> </a>下载 <code>Windows</code> 平台下 <code>redis</code> 的压缩包。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428211130210.png\" alt=\"image-20220428211130210\" /></p>\n<p>下载后直接解压即可在 <code>Windows</code> 中使用 <code>redis</code> 了。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428211441456.png\" alt=\"image-20220428211441456\" /></p>\n<p>不过建议还是要学习下面的方法，也要会在 <code>Linux</code> 平台中安装 <code>redis</code> ，下面我们以 <code>CentOs7</code> 为例，演示 <code>Linux</code> 中安装 <code>redis</code> 的方式。</p>\n<h1><a id=\"_108\"></a>安装</h1>\n<h2><a id=\"_gcc__110\"></a>下载 <code>gcc</code> 编译器</h2>\n<p>由于 redis 是用 C 语言编写的，所以 Linux 中要先有 C 语言的编译环境，所以我们需要下载最新的 <code>gcc </code> 编译器。</p>\n<p>下载 <code>gcc</code> 编译器的方式非常简单，依次输入以下命令即可：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ yum install centos-release-scl scl-utils-build\n$ yum install -y devtoolset-8-toolchain\n$ scl <span class=\"hljs-built_in\">enable</span> devtoolset-8 bash\n</code></div></pre>\n<p>安装完成后，使用以下命令，可以查看 <code>gcc</code> 版本：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost opt]<span class=\"hljs-comment\"># gcc --version</span>\ngcc (GCC) 8.3.1 20190311 (Red Hat 8.3.1-3)\nCopyright (C) 2018 Free Software Foundation, Inc.\nThis is free software; see the <span class=\"hljs-built_in\">source</span> <span class=\"hljs-keyword\">for</span> copying conditions.  There is NO\nwarranty; not even <span class=\"hljs-keyword\">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></div></pre>\n<h2><a id=\"_Redis_134\"></a>安装 <code>Redis</code></h2>\n<p>在官网下载 <code>redis</code> 的 <code>.tar.gz</code> 包后，我们需要把这个包上传到 <code>Linux</code> 服务器的 <code>/opt</code> 目录下，上传的方式有很多，在学习 <code>Linux</code> 阶段应该以及学过，这里不再赘述。</p>\n<p>然后我们在 <code>/opt</code> 目录下，执行如下命令解压这个压缩包：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost opt]<span class=\"hljs-comment\"># tar -zxvf redis-7.0.0.tar.gz </span>\n</code></div></pre>\n<p>解压完成后，在 <code>/opt</code> 目录下就会多一个解压后的包，我们进入该目录，并且执行 <code>make</code> 命令编译程序：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost opt]<span class=\"hljs-comment\"># cd redis-7.0.0/</span>\n[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># make</span>\n</code></div></pre>\n<p>编译需要一段时间，耐心等待即可，如果 C 语言编译环境出现问题，<code>make</code> 会报错— <code>Jemalloc/jemalloc.h：没有那个文件</code> ，解决方案就是再运行以下 <code>make distclean</code> ，然后再 <code>redis</code> 的目录下再次执行 <code>make</code> 命令即可。</p>\n<p>执行完以上的步骤，只是编译好了 <code>redis</code> 相关的文件，但是我们还要进行安装，执行 <code>make install</code> 命令即可完成安装</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># make install</span>\n</code></div></pre>\n<p>等待一段时间安装完成后，<code>redis</code> 会默认安装再 <code>/usr/local/bin</code> 目录中，我们可以切换到该目录查看其目录结构。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># cd /usr/local/bin/</span>\n[root@localhost bin]<span class=\"hljs-comment\"># ls</span>\nredis-benchmark  redis-check-rdb  redis-sentinel\nredis-check-aof  redis-cli        redis-server\n</code></div></pre>\n<p>查看默认安装目录：</p>\n<ul>\n<li><code>redis-benchmark</code> ：性能测试工具，可以在自己本子运行，看看自己本子性能如何</li>\n<li><code>redis-check-aof</code> ：修复有问题的AOF文件，rdb和aof后面讲</li>\n<li><code>redis-check-dump</code> ：修复有问题的dump.rdb文件</li>\n<li><code>redis-sentinel</code> ：Redis集群使用</li>\n<li><strong><code>redis-server</code> ：Redis服务器启动命令</strong></li>\n<li>**<code>redis-cli</code> ：客户端，操作入口</li>\n</ul>\n<h2><a id=\"_Redis_179\"></a>启动 <code>Redis</code></h2>\n<p>启动 <code>Redis</code> 的方式有两种，分别是前台启动和后台启动。</p>\n<h3><a id=\"_183\"></a>前台启动</h3>\n<p>我们不推荐使用前台启动的方式，因为前台启动当终端关闭后，则该服务也会停止，并且前台运行会占用整个终端页面，让该终端无法执行任何操作。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428204629343.png\" alt=\"image-20220428204629343\" /></p>\n<h3><a id=\"_191\"></a>后台启动(推荐)</h3>\n<p>后台启动是比较推荐的方式，<code>redis</code> 会在后台运行，而不会在终端中直接显示。</p>\n<p>但是后台启动需要操作 <code>redis</code> 的配置文件，我们建议先备份一下配置文件，以防配置错误不好还原。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost bin]<span class=\"hljs-comment\"># mkdir /my_redis_bak</span>\n[root@localhost bin]<span class=\"hljs-comment\"># cp /opt/redis-7.0.0/redis.conf /my_redis_bak/</span>\n[root@localhost bin]<span class=\"hljs-comment\"># ls /my_redis_bak/</span>\nredis.conf\n</code></div></pre>\n<p>然后到 <code>/opt/redis-7.0.0/</code> 目录下，修改配置文件，将文件将里面的 <code>daemonize no</code> 改成 <code>yes</code>，让服务在后台启动。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost bin]<span class=\"hljs-comment\"># cd /opt/redis-7.0.0/</span>\n[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># vim redis.conf </span>\n</code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428205057627.png\" alt=\"image-20220428205057627\" /></p>\n<p><strong>注意，配置文件一定要保存，保存方式是 <code>ESC</code> 后输出 <code>:wq</code> 。</strong></p>\n<p>然后我们就可以启动服务了，不过启动服务时还需要指定配置文件，不然默认是前台启动。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># redis-server /opt/redis-7.0.0/redis.conf </span>\n</code></div></pre>\n<p>这个时候程序就后台启动了，在前台页面是看不出来的，我们可以进行 <code>redis</code> 客户端来测试，客户端中输入 <code>ping</code> 会显示 <code>PONG</code> 则启动成功</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># redis-cli </span>\n127.0.0.1:6379&gt; ping\nPONG\n</code></div></pre>\n<h2><a id=\"_Redis_231\"></a>关闭 <code>Redis</code></h2>\n<p>如果是前台启动，按 <code>Ctrl+C</code> 或者关闭终端，都可以关闭 <code>redis</code> 。</p>\n<p>但是如果是后台启动，就需要用命令关闭，我们可以不进入 <code>redis</code> 客户端关闭：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># redis-cli shutdown</span>\n</code></div></pre>\n<p>也可以进入终端后关闭：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># redis-cli </span>\n127.0.0.1:6379&gt; shutdown\n</code></div></pre>\n<p>如果开启了多个实例，需要指定端口进行关闭：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">[root@localhost redis-7.0.0]<span class=\"hljs-comment\"># redis-cli -p 6379 shutdown</span>\n</code></div></pre>\n<p>我们还可以使用 <code>linux</code> 为我们提供的 <code>ps -ef</code> 命令查看进程，然后使用 <code>kill -9</code> 杀死进程的方式关闭 <code>redis</code> 。</p>\n<h1><a id=\"Redis__258\"></a><code>Redis</code> 相关知识</h1>\n<p><code>redis</code> 的端口默认是 <code>6379</code> ，并且默认有 16 个数据库，默认选择的是 0 数据库，使用命令 <code>select &lt;dbid&gt;</code> 来切换数据库，这 16 个数据库使用相同的密码。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">127.0.0.1:6379&gt; SELECT 1\nOK\n127.0.0.1:6379[1]&gt; SELECT 0\nOK\n127.0.0.1:6379&gt; \n</code></div></pre>\n<p><code>redis</code> 和其他 NoSQL 数据库的不同，<strong><code>redis</code> 采用的是单线程 + 多路IO复用技术</strong>，而如 <code>Memcache</code> 采用的是多线程 + 锁的方式。</p>\n<p>多路复用是指使用一个线程来检查多个文件描述符（ <code>Socket</code> ）的就绪状态，比如调用 <code>select</code> 和 <code>poll</code> 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p>\n<p>与 <code>Memcache</code> 的三点不同:</p>\n<ul>\n<li>支持多数据类型。</li>\n<li>支持持久化。</li>\n<li>单线程+多路IO复用。</li>\n</ul>\n<h1><a id=\"_284\"></a>常用五大数据类型和命令</h1>\n<p>本课程仅介绍一些简单的 <code>redis</code> 命令，关于 <code>redis</code> 的更多命令，可以见：http://www.redis.cn/commands.html#</p>\n<h2><a id=\"Redis__key__288\"></a><code>Redis</code> 键( <code>key</code> )</h2>\n<p><code>keys *</code> ：查看当前库中的所有 <code>key</code> ，如果需要模糊匹配，可如 <code>keys a*</code> ，表示匹配所有以 <code>a</code> 开头的键。</p>\n<p><code>exists &lt;key&gt;</code> ：判断某个 <code>key</code> 是否存在。</p>\n<p><code>type &lt;key&gt;</code> ：查看你的 <code>key</code> 是什么数据类型。</p>\n<p><code>del &lt;key&gt;</code> ：删除指定的 <code>key</code> 及其值。</p>\n<p><code>unlink &lt;key&gt;</code> ：根据 <code>value</code> 选择非阻塞删除。仅将 <code>keys</code> 从 <code>keyspace</code> 元数据中删除，真正的删除会在后续异步操作。</p>\n<p><code>expire &lt;key&gt; &lt;seconds&gt;</code> ：为给定的 <code>key</code> 设置过期时间，单位：秒。</p>\n<p><code>ttl &lt;key&gt;</code> ：查看还有多少秒过期，-1 表示永不过期，-2 表示已过期。</p>\n<p><code>dbsize</code> ：查看当前数据库的 <code>key</code> 数量。</p>\n<p><code>flushdb</code> ：清空当前数据库。</p>\n<p><code>flushall</code> ：清空全部库！</p>\n<h2><a id=\"_String__312\"></a>字符串类型( <code>String</code> )</h2>\n<h3><a id=\"_314\"></a>简介</h3>\n<p><code>String</code> 是 <code>redis</code> 最基本的类型，你可以理解成与 <code>Memcached</code> 一模一样的类型，一个 <code>key</code> 对应一个 <code>value</code> 。</p>\n<p><code>String</code> 类型是二进制安全的。意味着 <code>redis</code> 的 <code>String</code> 可以包含任何数据。比如 <code>jpg</code> 图片或者序列化的对象。</p>\n<p><code>String</code> 类型是 <code> Redis</code> 最基本的数据类型，一个 <code>redis</code> 中字符串 <code>value</code> 最多可以是<strong>512M</strong>。</p>\n<h3><a id=\"_324\"></a>常用命令</h3>\n<p><strong><code>set &lt;key&gt; &lt;val&gt;</code> ：以键值对的形式插入新的数据。当数据库 <code>key</code> 存在时，再执行 <code>set</code> 命令会覆盖原来的值。</strong></p>\n<p><strong><code>get &lt;key&gt;</code> ：根据 <code>key</code> 获取对应的值。</strong></p>\n<p><code>append &lt;key&gt; &lt;val&gt;</code> ：将 <code>key</code> 对应的值后追加 <code>value</code> 值，返回最终字符串的长度。</p>\n<p><strong><code>strlen &lt;key&gt;</code> ：获取指定 <code>key</code> 的值的字符串长度。</strong></p>\n<p><code>setnx &lt;key&gt; &lt;val&gt;</code> ：只有当 <code>key</code> 不存在时，设置 <code>key</code> 的值。</p>\n<p><strong><code>setex &lt;key&gt; &lt;seconds&gt; &lt;val&gt;</code> ：设置键值对同时指定 <code>key</code> 的过期时间，单位：秒。</strong></p>\n<p><code>getset &lt;key&gt; &lt;val&gt;</code> ：以新值换旧值，也就是这个方法会返回 <code>key</code> 原来的值，方法执行完后 <code>key</code> 的值被替换成新 <code>val</code> 值。</p>\n<p><code>mset &lt;key&gt; &lt;val&gt; &lt;key&gt; &lt;val&gt; ...</code> ：同时设置一个或多个键值对。</p>\n<p><code>msetnx &lt;key&gt; &lt;val&gt; &lt;key&gt; &lt;val&gt; ...</code> ：同时设置一个或多个键值对，当其中一个 <code>key</code> 已存在，则整行插入失效(原子性)。</p>\n<p><code>getrange &lt;key&gt; &lt;start&gt; &lt;end&gt; </code> ：<code>start</code> 和 <code>end</code> 需要是数值，表示截取 <code>key</code> 的值从 <code>start</code> 开始到 <code>end</code> 结束的子字符串。</p>\n<p><code>setrange &lt;key&gt; &lt;start&gt; &lt;val&gt;</code> ：<code>start</code> 需要是数值，表示将 <code>key</code> 的值从 <code>start</code> 开始覆写 <code>val</code> 长度的字符串。=</p>\n<p><code>incr &lt;key&gt;</code> ：只能对纯数字字符串操作，将 <code>key</code> 中存储的值自增1。</p>\n<p><code>decr &lt;key&gt;</code> ：只能对纯数字字符串操作，将 <code>key</code> 中存储的值自减1。</p>\n<p><code>incrby &lt;key&gt; &lt;val&gt;</code>  ：只能对纯数字字符串操作，将 <code>key</code> 中存储的值自增 <code>val</code> 值。</p>\n<p><code>decrby &lt;key&gt; &lt;val&gt;</code>  ：只能对纯数字字符串操作，将 <code>key</code> 中存储的值自减 <code>val</code> 值。</p>\n<p>注意，这里的自增和自减是原子性的操作，但是这里的原子性操作不是关系型数据库中的原子性操作，这里的原子性操作是指一个操作不会被线程调度机制打断，也就是这种操作一旦开始，就会一直运行到结束，中间不会切换到另一个线程。</p>\n<ul>\n<li>\n<p>在单线程中， 能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中断只能发生于指令之间。</p>\n</li>\n<li>\n<p>在多线程中，不能被其它进程(线程)打断的操作就叫原子操作。</p>\n</li>\n</ul>\n<p>Redis单命令的原子性主要得益于Redis的单线程。</p>\n<h3><a id=\"_366\"></a>数据结构</h3>\n<p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220428225142790.png\" alt=\"image-20220428225142790\" /></p>\n<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。<mark>需要注意的是字符串最大长度为512M。</mark></p>\n<h2><a id=\"_List__376\"></a>列表类型( <code>List</code> )</h2>\n<h3><a id=\"_378\"></a>简介</h3>\n<p>通过 <code>redis</code> 的列表，可以实现单键多值的操作，和 <code>Java</code> 的 <code>List</code> 集合类似。</p>\n<p><code>redis</code> 列表是简单的字符串列表，按照插入顺序，我们可以添加一个元素到元素的<strong>头部(左边)<strong>或者</strong>尾部(右边)</strong>。</p>\n<p>它的底层实际上是个双向列表，对两端的操作性都很高，通过索引下标进行操作，所以操作中间结点的性能会较差。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429144434241.png\" alt=\"image-20220429144434241\" /></p>\n<h3><a id=\"_390\"></a>常用命令</h3>\n<p><strong><code>lpush/rpush &lt;key&gt; &lt;val1&gt; &lt;val2&gt; ...</code> ：从左边/右边为某个键插入多个值，左边插入使用的是头插法，右边插入使用的是尾插法。</strong></p>\n<p><strong><code>lpop/rpop &lt;key&gt; [count]</code> ：从左边/右边为将某个键列表弹出 <code>count</code> 个值，<code>count</code> 可选，默认为1，返回值是弹出的值。当某个 <code>key</code> 列表值全部弹出，该列表则被销毁。</strong></p>\n<p><code>rpoplpush &lt;key1&gt; &lt;key2&gt;</code> ：将 <code>key1</code> 列表从右边弹出一个值，并且插入到 <code>key2</code> 列表左边，返回值是弹出的这个值。</p>\n<p><strong><code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code> ：按照索引从左到右获取元素，<code>start</code> 和 <code>stop</code> 表示起始和结束下标，<code>0</code> 到 <code>-1</code> 表示获取整个列表。</strong></p>\n<p><code>lindex &lt;key&gt; &lt;index&gt;</code> ：从左到右获取 <code>key</code> 列表第 <code>index</code> 个元素。</p>\n<p><strong><code>llen &lt;key&gt;</code> ：获取某个 <code>key</code> 列表长度。</strong></p>\n<p><code>linsert &lt;key&gt; &lt;before|after&gt; &lt;val&gt; &lt;newVal&gt;</code> ：在某个 <code>key</code> 列表的 <code>val</code> 元素之前/之后插入新的值 <code>newVal</code> 。</p>\n<p><code>lrem &lt;key&gt; &lt;count&gt; &lt;val&gt;</code> ：从左边开始删除 <code>key</code> 列表中 <code>count</code> 个 <code>val</code> 值。</p>\n<p><code>lset &lt;key&gt; &lt;index&gt; &lt;val&gt;</code> ：将 <code>key</code> 列表下标为 <code>index</code> 的值替换成 <code>val</code> 。</p>\n<h3><a id=\"_412\"></a>数据结构</h3>\n<p><code>redis</code> 中 <code>list</code> 的数据结构为快速链表 <code>quickList</code>.</p>\n<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表，它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 <code>quicklist</code> 。</p>\n<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429151712361.png\" alt=\"image-20220429151712361\" /></p>\n<p><code>Redis</code> 将链表和 <code>ziplist</code> 结合起来组成了 <code>quicklist</code> 。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>\n<h2><a id=\"__Set__426\"></a>集合类型 ( <code>Set</code> )</h2>\n<h3><a id=\"_428\"></a>简介</h3>\n<p><code>Redis set</code> 对外提供的功能与 <code>list</code> 类似是一个列表的功能，特殊之处在于 <code>set</code> 是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，<code>set</code> 是一个很好的选择，并且 <code>set</code> 提供了判断某个成员是否在一个 <code>set</code> 集合内的重要接口，这个也是list所不能提供的。</p>\n<p><code>redis</code> 的 <code>set</code> 是一个字符串类型的无序集合，它底层其实是一个 <code>value</code> 为 <code>null</code> 的 <code>Hash</code> 表，所以添加、删除、查找的时间复杂度都是 O(1)。</p>\n<p>O(1) 是指一个算法，随着数据的增加，执行时间的长度，如果是 O(1)，数据增加，查找数据的时间不变。</p>\n<h3><a id=\"_438\"></a>常用命令</h3>\n<p><strong><code>sadd &lt;key&gt; &lt;val1&gt; &lt;val2&gt; ...</code> ：将一个或多个元素添加到 <code>key</code> 集合当中，已经存在的元素会被忽略。</strong></p>\n<p><strong><code>smembers &lt;key&gt;</code> ：取出该集合的所有值(值是无序的)。</strong></p>\n<p><strong><code>sismember&lt;key&gt; &lt;val&gt;</code> ：判断 <code>key</code> 集合中是否包含 <code>val</code> 值，若有返回1，否则返回0。</strong></p>\n<p><strong><code>scard &lt;key&gt;</code> ：返回该集合的元素个数。</strong></p>\n<p><code>srem &lt;key&gt; &lt;val1&gt; &lt;val2&gt; ...</code> ：从 <code>key</code> 集合中删除一个或多个 <code>val</code> 元素。</p>\n<p><code>spop &lt;key&gt; [count]</code> ：随机从 <code>key</code> 集合中弹出 <code>count</code> 个元素，<code>count</code> 可选，默认为1。</p>\n<p><code>srandmember &lt;key&gt; [count]</code> ：随机从 <code>key</code> 集合中获取 <code>count</code> 个元素，<code>count</code> 可选，默认为1，此操作并不会让元素从集合中删除。</p>\n<p><code>smove &lt;source&gt; &lt;dest&gt; &lt;val&gt;</code> ：从 <code>source</code> 集合中取出 <code>val</code> 值，并移动到 <code>dest</code> 集合中，此操作会使 <code>source</code> 集合失去 <code>val</code> 元素。</p>\n<p><code>sinter &lt;key1&gt; &lt;key2&gt; ...</code> ： 返回多个 <code>key</code> 集合中的交集。</p>\n<p><code>sunion &lt;key1&gt; &lt;key2&gt; ...</code> ：返回多个 <code>key</code> 集合中的并集，重合部分会被忽略。</p>\n<p><code>sdiff &lt;key1&gt; &lt;key2&gt; ...</code> ：返回 <code>key1</code> 集合与其他集合差集( <code>key1</code> 集合存在的，其他集合不存在的)。</p>\n<h3><a id=\"_464\"></a>数据结构</h3>\n<p><code>Set</code> 数据结构是 <code>dict</code> 字典，字典是用哈希表实现的。<code>Java</code> 中 <code>HashSet</code> 的内部实现使用的是 <code>HashMap</code>，只不过所有的value都指向同一个对象。<code>Redis</code> 的 <code>set</code> 结构也是一样，它的内部也使用 <code>hash</code> 结构，所有的 <code>value</code> 都指向同一个内部值。</p>\n<h2><a id=\"_Zset__470\"></a>有序集合( <code>Zset</code> )</h2>\n<h3><a id=\"_472\"></a>简介</h3>\n<p><code>Redis</code> 有序集合 <code>zset</code> 与普通集合 <code>set</code> 非常相似，是一个没有重复元素的字符串集合。</p>\n<p>不同之处是有序集合的每个成员都关联了一个<strong>评分( <code>score</code>)</strong>，这个评分( <code>score</code> )被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复的 。</strong></p>\n<p>因为元素是有序的, 所以你也可以很快的根据评分( <code>score</code> )或者次序( <code>position</code> )来获取一个范围的元素。</p>\n<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合<strong>作为一个没有重复成员的智能列表</strong>。</p>\n<h3><a id=\"_484\"></a>常用命令</h3>\n<p><code>zadd &lt;key&gt; &lt;score1&gt; &lt;member1&gt; &lt;score2&gt; &lt;member2&gt; ...</code> ：将一个或多个元素 <code>member</code> 加入到有序集合 <code>key</code> 中，<code>score</code> 必须为整形。</p>\n<p><code>zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</code> ：返回有序集合 <code>key</code> 的 <code>start</code> 到 <code>stop</code> 位置的元素，默认按 <code>score</code> 从小到大排序，<code>withscores</code> 参数可选，可以让显示元素的同时显示 <code>score</code> ，当 <code>start</code> 和 <code>stop</code> 为 <code>0</code> 和 <code>-1</code> 表示返回全部结果。</p>\n<p><code>zrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt; [withscores] </code> ：返回有序集合 <code>key</code> 中介于 <code>min</code> 和 <code>max</code> 评分之间(含两者)的元素，按照从小到大排序，<code>withscores</code> 参数同上。</p>\n<p><code>zrevrangebyscore &lt;key&gt; &lt;max&gt; &lt;min&gt; [withscores]</code> ：效果同上，但是按照从大到小排序。</p>\n<p><code>zincrby &lt;key&gt; &lt;increment&gt; &lt;member&gt;</code> ：将有序集合 <code>key</code> 的 <code>member</code> 元素的评分 <code>score</code> 增加上 <code>increment</code> 。</p>\n<p><code>zrem &lt;key&gt; &lt;member1&gt; &lt;member2&gt; ...</code> ：删除有序集合<code>key</code> 的一个或多个 <code>member</code> 元素。</p>\n<p><code>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</code> ：统计该集合 <code>key</code> 中，介于 <code>min</code> 和 <code>max</code> 评分(含两者)的元素个数。</p>\n<p><code>zrank &lt;key&gt; &lt;member&gt;</code> ：返回该 <code>member</code> 元素在 <code>key</code> 集合中的排名，排名从0开始。</p>\n<p><strong>范例：如何利用 <code>Zset</code> 实现排行榜的功能？</strong></p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429170317106.png\" alt=\"image-20220429170317106\" /></p>\n<h3><a id=\"_508\"></a>数据结构</h3>\n<p><code>SortedSet(zset)</code> 是 <code>Redis</code> 提供的一个非常特别的数据结构，一方面它等价于 <code>Java</code> 的数据结构 <code>Map&lt;String, Double&gt;</code> ，可以给每一个元素 <code>value</code> 赋予一个权重 <code>score</code> ，另一方面它又类似于 <code>TreeSet</code> ，内部的元素会按照权重 <code>score</code> 进行排序，可以得到每个元素的名次，还可以通过 <code>score</code> 的范围来获取元素的列表。</p>\n<p><code>zset</code> 底层使用了两个数据结构</p>\n<ul>\n<li>\n<p><code>hash</code> ，<code>hash</code> 的作用就是关联元素 <code>value</code> 和权重 <code>score</code> ，保障元素 <code>value</code> 的唯一性，可以通过元素 <code>value</code> 找到相应的 <code>score</code> 值。</p>\n</li>\n<li>\n<p>跳跃表，跳跃表的目的在于给元素 <code>value</code> 排序，根据 <code>score</code> 的范围获取元素列表。</p>\n</li>\n</ul>\n<h3><a id=\"__520\"></a>[扩展阅读] 跳跃表</h3>\n<p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。</p>\n<p>对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。<code>Redis</code> 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>\n<p><strong>实例</strong></p>\n<p>对比有序链表和跳跃表，从链表中查询出：</p>\n<blockquote>\n<p><strong>有序链表</strong></p>\n</blockquote>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429170756860.png\" alt=\"image-20220429170756860\" /></p>\n<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>\n<blockquote>\n<p><strong>跳跃表</strong></p>\n</blockquote>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429170839022.png\" alt=\"image-20220429170839022\" /></p>\n<p>从第2层开始，1节点比51节点小，向后比较。</p>\n<p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p>\n<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>\n<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>\n<p>从此可以看出跳跃表比有序链表效率要高。</p>\n<h2><a id=\"_Hash__554\"></a>哈希表( <code>Hash</code> )</h2>\n<h3><a id=\"_556\"></a>简介</h3>\n<p><code>redis</code> 的 <code>hash</code> 是一个键值对的集合，由一个字符串类型的 <code>field</code> 和 <code>value</code> 的映射表，<code>hash</code> 特别适合存储对象，类似于 <code>Java</code> 中的 <code>Map&lt;String, Object&gt;</code> 。</p>\n<p>比如我们存储一个用户对象通常有如下三种方式：</p>\n<ul>\n<li>将用户对象序列化成 <code>json</code> 格式的字符串，以字符串方式存储用户对象，<code>key</code> 可以为用户ID。缺点：需要频繁的序列化和反序列化。</li>\n<li>将用户对象的属性以 <code>userId:field</code> 的形式作为 <code>key</code> ，而用户属性值作为该 <code>key</code> 的值。缺点：用户ID数据冗余。</li>\n<li><strong>将用户对象存储为 <code>hash</code> 的形式，用户ID作为 <code>hash</code> 表的 <code>key</code> 。这样既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</strong></li>\n</ul>\n<h3><a id=\"_568\"></a>常用命令</h3>\n<p><strong><code>hset &lt;key&gt; &lt;field&gt; &lt;val&gt;</code> ：将 <code>key</code> 表中的 <code>field</code> 字段赋值为 <code>val</code> 。</strong></p>\n<p><code>hsetnx &lt;key&gt; &lt;field&gt; &lt;val&gt;</code> ：将 <code>key</code> 表中的 <code>field</code> 字段赋值为 <code>val</code> ，但是若 <code>field</code> 字段已存在，则不执行操作。</p>\n<p><strong><code>hget &lt;key&gt; &lt;field&gt;</code> ：从 <code>key</code> 表中获取 <code>field</code> 字段的值。</strong></p>\n<p><strong><code>hmset &lt;key&gt; &lt;field1&gt; &lt;val1&gt; &lt;filed2&gt; &lt;val2&gt; ...</code> ：批量给 <code>key</code> 表中添加键值对。</strong></p>\n<p><strong><code>hdel &lt;key&gt; &lt;field1&gt; &lt;field2&gt; ...</code> ：为 <code>key</code> 表删除一个或多个 <code>field</code> 。</strong></p>\n<p><code>hexists &lt;key&gt; &lt;field&gt;</code> ：判断 <code>key</code> 表中 <code>field</code> 字段是否存在，若存在则返回1，否则返回0。</p>\n<p><code>hkeys &lt;key&gt;</code> ：查看 <code>key</code> 表的所有 <code>field</code> 字段。</p>\n<p><code>hvals &lt;key&gt;</code> ：查看 <code>key</code> 表的所有 <code>value</code> 值。</p>\n<p><code>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</code> ：为 <code>key</code> 表的 <code>field</code> 字段自增 <code>increment</code> 值，<code>field</code> 字段必须为整形。</p>\n<h3><a id=\"_590\"></a>数据结构</h3>\n<p>Hash类型对应的数据结构是两种：</p>\n<ul>\n<li>\n<p><code>ziplist</code> (压缩列表)。</p>\n</li>\n<li>\n<p><code>hashtable</code> (哈希表)。</p>\n</li>\n</ul>\n<p>当 <code>field</code> - <code>value</code> 长度较短且个数较少时，使用 <code>ziplist</code> ，否则使用 <code>hashtable</code> 。</p>\n<h1><a id=\"Redis__602\"></a><code>Redis</code> 配置文件介绍</h1>\n<p><code>redis</code> 的配置文件分成了好几个部分，每个部分前面官方都用多个 <code>###</code> 进行了标识，下面我们就对于这些部分依次进行讲解。</p>\n<p>如果对配置文件进行了修改，我们保存文件后，需要重新启动 <code>redis</code> 服务才能生效。</p>\n<h2><a id=\"Units__610\"></a>Units (单位)</h2>\n<p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit，并且大小写不敏感。</p>\n<pre><code class=\"lang-\"># Note on units: when memory size is needed, it is possible to specify\n# it in the usual form of 1k 5GB 4M and so forth:\n#\n# 1k =&gt; 1000 bytes\n# 1kb =&gt; 1024 bytes\n# 1m =&gt; 1000000 bytes\n# 1mb =&gt; 1024*1024 bytes\n# 1g =&gt; 1000000000 bytes\n# 1gb =&gt; 1024*1024*1024 bytes\n</code></pre>\n<h2><a id=\"INCLUDE__628\"></a>INCLUDE (包含)</h2>\n<p>在这个部分我们可以将其他配置文件的内容包含到此配置文件，类似 <code>jsp</code> 中的 <code>include</code> ，多实例的情况可以把公用的配置文件提取出来。</p>\n<pre><code class=\"lang-\">################ INCLUDE ################\n# 表示包含 /etc/myredis/ 目录下的所有 `.conf` 配置文件\ninclude /etc/myredis/*.conf\n</code></pre>\n<h2><a id=\"NETWORK__640\"></a>NETWORK (网络)</h2>\n<p><strong>常用配置</strong>：</p>\n<ul>\n<li>\n<p><code>bind</code> ：绑定允许访问的 <code>ip</code> ，默认为 <code>127.0.0.1</code> ，即只允许本机访问， 我们注释掉这行代码即可允许任何 <code>ip</code> 地址访问。</p>\n</li>\n<li>\n<p><code>protected-mode</code> ：将本机访问保护模式设置 <code>no</code> 。如果需要任何机器都能访问，需要设置为 <code>yes</code> 。</p>\n</li>\n<li>\n<p><code>port</code> ：<code>redis</code> 占用的端口号。</p>\n</li>\n<li>\n<p><code>tcp-backlog</code> ：设置 <code>tcp</code> 的 <code>backlog</code> ，<code>backlog</code> 其实是一个连接队列，<code>backlog</code> 队列总和 = 未完成三次握手队列 + 已经完成三次握手队列。</p>\n<ul>\n<li>\n<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>\n</li>\n<li>\n<p>注意Linux内核会将这个值减小 <code>/proc/sys/net/core/somaxconn</code> 到的值(128)，所以需要确认增大 <code>/proc/sys/net/core/somaxconn</code> 和 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> (128)两个值来达到想要的效果。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>timeout</code> ：一个空闲的客户端维持多少秒关闭会话，默认为0表示关闭该功能，即永不关闭。</p>\n</li>\n<li>\n<p><code>tcp-keepalive</code> ：对访问的客户端进行心跳检测，每 n 秒检测一次。单位为秒，如果设置为0，则不会进行 <code>Keepalive</code> 检测，建议设置成60 。</p>\n</li>\n</ul>\n<h2><a id=\"GENERAL__660\"></a>GENERAL (通用)</h2>\n<p>常用配置：</p>\n<ul>\n<li><code>daemonize</code> ：是否为后台进程，设置为 <code>yes</code> ，表示守护进程，后台启动。</li>\n<li><code>pidfile</code> ：存放 <code>pid</code> 文件的位置，每个实例会产生一个不同的 <code>pid</code> 文件。</li>\n<li><code>loglevel</code> ：指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice。</li>\n</ul>\n<pre><code class=\"lang-\"># debug (a lot of information, useful for development/testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged)\n</code></pre>\n<ul>\n<li><code>logfile</code> ：日志文件名称，默认为空</li>\n<li><code>databases 16</code> ：设定库的数量默认16，默认数据库为0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库id。</li>\n</ul>\n<h2><a id=\"SECURITY__680\"></a>SECURITY (安全)</h2>\n<p>常用配置：</p>\n<ul>\n<li><code>requirepass</code> ：配置项后可以设置密码，这是永久设置密码，默认无密码。</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-comment\"># 如果我们不需要永久设置密码，我们可以设置临时密码</span>\n<span class=\"hljs-comment\"># 这个临时密码仅对当次服务生效，重启redis服务后失效</span>\n127.0.0.1:6379&gt; config get requirepass <span class=\"hljs-comment\"># 获取密码</span>\n127.0.0.1:6379&gt; config <span class=\"hljs-built_in\">set</span> requirepass <span class=\"hljs-string\">\"123456\"</span>	<span class=\"hljs-comment\"># 设置临时密码</span>\n127.0.0.1:6379&gt; auth 123456	<span class=\"hljs-comment\"># 进行密码认证</span>\n</code></div></pre>\n<h2><a id=\"LIMITS__696\"></a>LIMITS (限制)</h2>\n<p>常用配置：</p>\n<ul>\n<li><code>maxclients</code> ：设置 <code>redis</code> 同时可以与多少个客户端进行连接，默认为1000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</li>\n<li><code>maxmemory</code> ：建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。\n<ul>\n<li>设置 <code>redis</code> 可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过 <code>maxmemory-policy</code> 来指定。</li>\n<li>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li>\n<li>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</li>\n</ul>\n</li>\n<li><code>maxmemory-policy</code> ：\n<ul>\n<li><code>volatile-lru</code>：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</li>\n<li><code>allkeys-lru</code>：在所有集合key中，使用LRU算法移除key</li>\n<li><code>volatile-random</code>：在过期集合中移除随机的key，只对设置了过期时间的键</li>\n<li><code>allkeys-random</code>：在所有集合key中，移除随机的key</li>\n<li><code>volatile-ttl</code>：移除那些TTL值最小的key，即那些最近要过期的key</li>\n<li><code>noeviction</code>：不进行移除。针对写操作，只是返回错误信息</li>\n</ul>\n</li>\n<li><code>maxmemory-samples</code> ：\n<ul>\n<li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</li>\n<li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</li>\n</ul>\n</li>\n</ul>\n<h1><a id=\"_718\"></a>发布和订阅</h1>\n<h2><a id=\"_720\"></a>什么是发布和订阅</h2>\n<p><code>redis</code> 发布订阅 (pub/sub) 是一种消息通信模式，发送者 (pub) 发送消息，<code>redis</code> 客户端可以订阅任意数量的频道。</p>\n<h2><a id=\"Redis__726\"></a><code>Redis</code> 的发布和订阅</h2>\n<p>客户端可以订阅频道，如下图：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429201755048.png\" alt=\"image-20220429201755048\" /></p>\n<p>当给这个评到发布消息后，消息就会发送给订阅的客户端。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429201823601.png\" alt=\"image-20220429201823601\" /></p>\n<h2><a id=\"_738\"></a>命令行实现</h2>\n<p><strong>订阅</strong>：打开客户端A，输入如下命令订阅 <code>channel1</code> 。</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">127.0.0.1:6379&gt; subscribe channel1\n</code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429202105743.png\" alt=\"image-20220429202105743\" /></p>\n<p><strong>发布</strong>：打开客户端B，给 <code>channel1</code> 发布一个消息 <code>hello</code> 。</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">127.0.0.1:6379&gt; publish channel1 hello\n(<span class=\"hljs-built_in\">integer</span>) 1\n</code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429202156606.png\" alt=\"image-20220429202156606\" /></p>\n<p><strong>结果</strong>：返回第一个客户端，可以看到客户端B发布的消息 <code>hello</code> 。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220429202256271.png\" alt=\"image-20220429202256271\" /></p>\n<p>注意：发布的消息没有持久化，如果在订阅的客户端收不到 <code>hello</code> ，只能收到订阅后发布消息。</p>\n<h1><a id=\"_765\"></a>新数据类型</h1>\n<h2><a id=\"BitMaps_767\"></a><code>BitMaps</code></h2>\n<h3><a id=\"_769\"></a>简介</h3>\n<p><code>bitmaps</code> 也叫位图，也就是用一个bit位来表示一个东西的状态，我们都知道bit位是二进制，所以只有两种状态，0和1。</p>\n<p>但 <code>bitmaps</code> 实际上也是字符串，只不过它可以单独对字符串进行位操作。</p>\n<p>我们也可以把 <code>bitmaps</code> 想象成一个数组，但是数组的每个单元只能存储0和1，数组的下标在 <code>bitmaps</code> 中叫做便宜量。所以 <code>bitmaps</code> 就适合存储只有两种状态的数据，比如用户是否登录，用户是否签到…</p>\n<h3><a id=\"_779\"></a>常用命令</h3>\n<p><code>setbit &lt;key&gt; &lt;offset&gt; &lt;val&gt;</code> ：设置 <code>bitmaps</code> 的键为 <code>key</code> ，在 <code>offset</code> 偏移量中的值为 <code>val</code> ，注意，这个值只能为 0 或 1。</p>\n<p><code>getbit &lt;key&gt; &lt;offset&gt;</code> ：获取 <code>key</code> 表的 <code>offset</code> 偏移量中的值。</p>\n<p><code>bitcount &lt;key&gt; [start] [end] [byte|bit]</code> ：获取 <code>key</code> 表中被设置为 1 的 <code>bit</code> 个数。通过 <code>start</code> 和 <code>end</code> 可以设置需要统计的位数，单位默认是 <code>byte</code> ，也可以设置为 <code>bit</code> (我的版本是 <code>redis7.0</code>，较低版本可能无法设置单位，故默认单位为 <code>byte</code> ) 。</p>\n<p><code>bittop &lt;operation&gt; &lt;destkey&gt; &lt;key1&gt; &lt;key2&gt; ...</code> ：这是一个复合操作，可以把多个 <code>key</code> 表进行与( <code>and</code> )、或( <code>or</code> )、非( <code>not</code> ) 、异或( <code>xor</code> ) 操作，操作方式放在 <code>operation</code> 位置，并且把操作的结构放在 <code>destkey</code> 表。</p>\n<h3><a id=\"_791\"></a>简单应用</h3>\n<p>统计某天登录的用户，我们可以以当天的日期作为键，以用户的id作为偏移量，用户登录则记为1，否则记为0。</p>\n<p>当用户登录后，我们可以将该用户的id作为偏移量，并设置该位为1。</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">127.0.0.1:6379&gt; setbit users:20221102 10 1\n(<span class=\"hljs-built_in\">integer</span>) 0\n127.0.0.1:6379&gt; setbit users:20221102 12 1\n(<span class=\"hljs-built_in\">integer</span>) 0\n127.0.0.1:6379&gt; setbit users:20221102 7 1\n(<span class=\"hljs-built_in\">integer</span>) 0\n127.0.0.1:6379&gt; setbit users:20221102 15 1\n(<span class=\"hljs-built_in\">integer</span>) 0\n127.0.0.1:6379&gt; setbit users:20221102 20 1\n(<span class=\"hljs-built_in\">integer</span>) 0\n</code></div></pre>\n<p>如果需要查询某个用户是否登录，我们只需要查询其id的偏移量是否为1</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">127.0.0.1:6379&gt; getbit users:20221102 7	\n(<span class=\"hljs-built_in\">integer</span>) 1		<span class=\"hljs-comment\"># 已登录</span>\n127.0.0.1:6379&gt; getbit users:20221102 28\n(<span class=\"hljs-built_in\">integer</span>) 0		<span class=\"hljs-comment\"># 未登录</span>\n</code></div></pre>\n<p>如果需要统计该天在线的用户数量，我们使用 <code>bitcount</code> ：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">127.0.0.1:6379&gt; bitcount users:20221102 <span class=\"hljs-comment\"># 统计全部</span>\n(<span class=\"hljs-built_in\">integer</span>) 4\n127.0.0.1:6379&gt; bitcount users:20221102 0 1	<span class=\"hljs-comment\"># 表示统计0字节组和1字节组的bit为1的个数</span>\n(<span class=\"hljs-built_in\">integer</span>) 4	\n</code></div></pre>\n<p>第二天，又有一些登录用户，我们和往常一样，记录下这些用户的登录状态。</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">127.0.0.1:6379&gt; getbit users:and:20221103 10\n(<span class=\"hljs-built_in\">integer</span>) 1\n127.0.0.1:6379&gt; getbit users:and:20221103 20\n(<span class=\"hljs-built_in\">integer</span>) 1\n</code></div></pre>\n<p>然后我们需要统计两天都登录的用户个数，那么我们就可以对两个表进行与操作。</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">127.0.0.1:6379&gt; bitop and users:and:20221104 users:20221102 users:20221103 users:and:20221103\n(<span class=\"hljs-built_in\">integer</span>) 3\n127.0.0.1:6379&gt; bitcount users:and:20221103\n(<span class=\"hljs-built_in\">integer</span>) 2		<span class=\"hljs-comment\"># 两天都登录的用户只有两个</span>\n</code></div></pre>\n<p>如果只要统计这两天中，任意一天登录过的用户，那么就使用或操作。</p>\n<blockquote>\n<p><strong>注意：很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</strong></p>\n<p><strong>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</strong></p>\n</blockquote>\n<h2><a id=\"HyperLogLog_854\"></a><code>HyperLogLog</code></h2>\n<h3><a id=\"_856\"></a>简介</h3>\n<p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 <code>PV</code> ( <code>PageView</code> 页面访问量)，可以使用 <code>Redis</code> 的 <code>incr</code> 、<code>incrby</code> 轻松实现。</p>\n<p>但像 <code>UV</code> ( <code>UniqueVisitor</code> ，独立访客)、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>\n<p>解决基数问题有很多种方案：</p>\n<ul>\n<li>\n<p>数据存储在MySQL表中，使用distinct count计算不重复个数</p>\n</li>\n<li>\n<p>使用Redis提供的hash、set、bitmaps等数据结构来处理</p>\n</li>\n</ul>\n<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>\n<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>\n<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>\n<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>\n<p><strong>什么是基数</strong>?</p>\n<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>\n<h3><a id=\"_882\"></a>常用命令</h3>\n<p><code>pfadd &lt;key&gt; &lt;element1&gt; &lt;element2&gt; ...</code> ：添加一个或多个元素到 <code>HLL</code> 当中，重复的 <code>element</code> 会被忽略，并且只统计 <code>element</code> 的基数。</p>\n<p><code>pfcount &lt;key1&gt; &lt;key2&gt; ... </code> ：计算 <code>HLL</code> 的基数，可以计算多个 <code>HLL</code> 。</p>\n<p><code>pfmerge &lt;destkey&gt; &lt;sourcekey1&gt; &lt;sourcekey2&gt; ...</code> ：将多个 <code>sourcekey</code> 表合并到 <code>destkey</code> 表当中。</p>\n<h2><a id=\"Geospatial_892\"></a><code>Geospatial</code></h2>\n<h3><a id=\"_894\"></a>简介</h3>\n<p>Redis 3.2 中增加了对GEO类型的支持。GEO (Geographic) 地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。<code>redis</code> 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>\n<h3><a id=\"_900\"></a>常用命令</h3>\n<p><code>geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt; ...</code> ：向 <code>key</code> 表中添加一个地理位置，根据经度、纬度、名称。经纬度为 <code>double</code> 类型。</p>\n<p><code>geopos &lt;key&gt; &lt;member1&gt; &lt;member2&gt; ... </code> ：获取指定地区的坐标值(经度、纬度) 。</p>\n<p><code>geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; [m|km|ft|mi]</code> ：获取两个地址之间的直线距离，后面可以跟上单位。</p>\n<p><code>georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;radius&gt; [m|km|ft|mi]</code> ： 以给定的经纬度为中心，找出 <code>radius</code> 半径范围内的所有元素，<code>radius</code> 需要是整形，后面可以跟上单位。</p>\n<p><strong>单位</strong></p>\n<ul>\n<li>m 表示单位为米[默认值]。</li>\n<li>km 表示单位为千米。</li>\n<li>mi 表示单位为英里。</li>\n<li>ft 表示单位为英尺。</li>\n</ul>\n<p>如果用户没有显式地指定单位参数， 那么默认使用米作为单位。</p>\n<h3><a id=\"_921\"></a>范例</h3>\n<pre><div class=\"hljs\"><code class=\"lang-sh\"><span class=\"hljs-comment\"># 创建坐标</span>\n127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai\n(<span class=\"hljs-built_in\">integer</span>) 1\n127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing\n(<span class=\"hljs-built_in\">integer</span>) 3\n<span class=\"hljs-comment\"># 查询坐标</span>\n127.0.0.1:6379&gt; geopos china:city shanghai\n1) 1) <span class=\"hljs-string\">\"121.47000163793563843\"</span>\n   2) <span class=\"hljs-string\">\"31.22999903975783553\"</span>\n127.0.0.1:6379&gt; geopos china:city beijing\n1) 1) <span class=\"hljs-string\">\"116.38000041246414185\"</span>\n   2) <span class=\"hljs-string\">\"39.90000009167092543\"</span>\n<span class=\"hljs-comment\"># 获取两地直线距离</span>\n127.0.0.1:6379&gt; geodist china:city shanghai beijing km\n<span class=\"hljs-string\">\"1068.1535\"</span>\n127.0.0.1:6379&gt; geodist china:city shanghai chongqing m\n<span class=\"hljs-string\">\"1447673.6920\"</span>\n<span class=\"hljs-comment\"># 获取指定坐标1000km半径范围的城市</span>\n127.0.0.1:6379&gt; georadius china:city 110 30 1000 km\n1) <span class=\"hljs-string\">\"chongqing\"</span>\n2) <span class=\"hljs-string\">\"shenzhen\"</span>\n</code></div></pre>\n<hr />\n<p><strong>本章完。</strong></p>\n',1534438376886841346),(1405916999854342209,'# MQ 简介\n\nMQ 全称 Message Queue，也就是消息队列，遵循 FIFO 原则(先进先出)，消息队列，顾名思义，这个队列中存放的就是各种消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦“的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。\n\n\n\n## MQ 的作用\n\n### 流量消峰\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。\n\n\n\n### 应用解耦\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。\n\n当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，下单用户感受不到物流系统的故障，提升系统的可用性。\n\n![image-20220511203808531](http://img.liubaiblog.top/img/image-20220511203808531.png)\n\n\n\n### 异步处理\n\n有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式：\n\n- A 过一段时间去调用 B 的查询 api 查询。\n\n- 或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。\n\n这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。\n\n\n\n## MQ 的分类\n\n### ActiveMQ\n\n优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较高，较低的概率丢失数据。\n\n缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。\n\n\n\n### Kafka\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。\n\n**优点**：\n\n- 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。\n- 时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次。\n\n- 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager。\n- 在日志领域比较成熟，被多家公司和多个开源项目使用。\n- 功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。\n\n**缺点**：\n\n- Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长。\n- 使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试。\n- 支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢。\n\n\n\n### RocketMQ\n\nRocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。\n\n**优点**：\n\n- 单机吞吐量十万级，可用性非常高。\n\n- 分布式架构,消息可以做到 0 丢失。\n- MQ 功能较为完善，还是分布式的。\n- 扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降。\n- 源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。\n\n**缺点**：\n\n- 支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟。\n- 社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。\n\n\n\n### RabbitMQ\n\n2007 年发布，是一个在 AMQP(高级消息队列协议) 基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n\n**优点**：\n\n- 由于 erlang 语言的高并发特性，性能较好。\n- 吞吐量到万级，MQ 功能比较完备。\n- 健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全。\n- 开源提供的管理界面非常棒，用起来很好用，社区活跃度高。\n- 更新频率相当高。\n\n**缺点**：商业版需要收费，学习成本较高。\n\n\n\n## MQ 的选择\n\n### Kafka\n\nKafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。\n\n\n\n### RocketMQ\n\n天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n\n\n\n### RabbitMQ\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。\n\n\n\n# RabbitMQ 简介\n\n## 概述\n\nRabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。\n\n![image-20220511213222787](http://img.liubaiblog.top/img/image-20220511213222787.png)\n\n\n\n## 四大核心概念\n\n**生产者**：产生数据发送消息的程序是生产者。\n\n**交换机**：交换机是 RabbitMQ 中非常重要的一个部件，一方面它接收来自生产者的消息，另以方面它将消息推送到队列中。交换机必须确切的知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定。\n\n**队列**：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。\n\n**消费者**：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者、消费者和消息中间件很多时候并不在同一台机器上。同一个应用程序既可以是生产者也可以是消费者。\n\n\n\n## Rabbit 核心部分\n\n![image-20220511213906770](http://img.liubaiblog.top/img/image-20220511213906770.png)\n\n\n\n## 各个名词介绍\n\n![image-20220511213933082](http://img.liubaiblog.top/img/image-20220511213933082.png)\n\n**Broker**\n\n接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。\n\n**Virtual Host**\n\n出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ Server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange / queue 等。\n\n**Connection**\n\npublisher / consumer 和 broker 之间的 TCP 连接。\n\n**Channel**\n\n如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。\n\nChannel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。\n\n==Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。==\n\n**Exchange**\n\nmessage 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct(point-to-point)、topic(publish-subscribe)、fanout(multicast)。\n\n**Queue**\n\n消息最终被送到这里等待 consumer 取走。\n\n**Binding**\n\nexchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 的查询表中，用于 message 的分发依据。\n\n\n\n# 安装\n\n> **Tip：以下演示的是如何在 CentOS7 中安装 RabbitMQ。**\n\n由于 RabbitMQ 是基于 erlang 语言编写的，所以安装 RabbitMQ 之前，我们需要让我们的虚拟机有 erlang 语言的环境。\n\n**erlang 下载地址**：https://github.com/rabbitmq/erlang-rpm/releases。\n\n**RabbitMQ 下载地址**：https://github.com/rabbitmq/rabbitmq-server/releases。\n\n不同 RabbitMQ 的版本对应不同的 erlang 版本，具体的对应关系可以见：https://www.rabbitmq.com/which-erlang.html。\n\n我们下载 `rpm` 后缀的即可：\n\n![image-20220512151829069](http://img.liubaiblog.top/img/image-20220512151829069.png)\n\n![image-20220512151915323](http://img.liubaiblog.top/img/image-20220512151915323.png)\n\n\n\n安装完成之后，我们可以需要把两个文件上传到服务器，我将其上传到了 `/opt/rabbitMQ` 目录下：\n\n```bash\n$ mkdir /opt/rabbitMQ\n$ cd /opt/rabbitMQ/\n$ ls\nerlang-23.3.4.11-1.el7.x86_64.rpm  rabbitmq-server-3.10.1-1.el8.noarch.rpm\n```\n\n分别输入如下命令安装：\n\n```bash\n$ rpm -ivh erlang-23.3.4.11-1.el7.x86_64.rpm\n$ yum install socat -y\n$ rpm -ivh rabbitmq-server-3.10.1-1.el8.noarch.rpm\n```\n\n常用命令：\n\n```bash\n# 添加开机启动 RabbitMQ 服务\n$ chkconfig rabbitmq-server on\n# 启动服务\n$ /sbin/service rabbitmq-server start\n# 查看服务状态\n$ /sbin/service rabbitmq-server status\n# 停止服务\n$ /sbin/service rabbitmq-server stop\n```\n\n启动服务后，查看服务状态如果为 `active(running)` ，说明安装成功！\n\n![image-20220512152619241](http://img.liubaiblog.top/img/image-20220512152619241.png)\n\n\n\n# 开启 Web 管理界面\n\n我们通常通过 Web 管理界面来管理 RabbitMQ，执行如下命令安装 RabbitMQ 的 Web 管理插件。\n\n```bash\n$ rabbitmq-plugins enable rabbitmq_management\n```\n\n安装完服务后需要重启 RabbitMQ，并且如果防火墙没有关闭，还需要关闭防火墙。\n\n```bash\n$ systemctl stop firewall		# 关闭防火墙\n$ systemctl disable firewalld	# 关闭防火墙开机自启动\n```\n\n访问地址 `http://服务器IP:15672`  进入 Web 网管界面，默认账号和密码都为 `grant` 。\n\n![image-20220512153746162](http://img.liubaiblog.top/img/image-20220512153746162.png)\n\n不过是进不去，这是权限的问题。\n\n**用户配置常用命令**：\n\n```bash\n# 创建用户\n$ rabbitmqctl add_user <username> <password>\n# 设置用户角色\n$ rabbitmqctl set_user_tags <username> <role>\n# 设置用户权限\n$ rabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\n# 查看所有用户及其角色\n$ rabbitmqctl list_users\n```\n\n所以我们可以通过如下命令，创建一个 `admin` 用户，密码为 `123456` 。\n\n```bash\n# 创建用户并设置密码\n$ rabbitmqctl add_user admin 123456\n# 将admin用户的角色设置为administrator\n$ rabbitmqctl set_user_tags admin administrator\n# admin用户具有 \"/\" 这个vhost中的配置、写、读的全部权限\n$ rabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\"\n```\n\n然后我们再使用 `admin` 用户登录，应该是没问题的\n\n![image-20220512160640450](http://img.liubaiblog.top/img/image-20220512160640450.png)\n\n**其他相关命令**\n\n```bash\n# 关闭Web应用\n$ rabbitmqctl stop_app\n# 清除应用信息\n$ rabbitmqctl reset\n# 重新启动Web应用\n$ rabbitmqctl start_app\n```\n\n\n\n---\n\n**本章完。**','<h1><a id=\"MQ__0\"></a>MQ 简介</h1>\n<p>MQ 全称 Message Queue，也就是消息队列，遵循 FIFO 原则(先进先出)，消息队列，顾名思义，这个队列中存放的就是各种消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦“的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p>\n<h2><a id=\"MQ__6\"></a>MQ 的作用</h2>\n<h3><a id=\"_8\"></a>流量消峰</h3>\n<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p>\n<h3><a id=\"_14\"></a>应用解耦</h3>\n<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。</p>\n<p>当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，下单用户感受不到物流系统的故障，提升系统的可用性。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220511203808531.png\" alt=\"image-20220511203808531\" /></p>\n<h3><a id=\"_24\"></a>异步处理</h3>\n<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式：</p>\n<ul>\n<li>\n<p>A 过一段时间去调用 B 的查询 api 查询。</p>\n</li>\n<li>\n<p>或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。</p>\n</li>\n</ul>\n<p>这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>\n<h2><a id=\"MQ__36\"></a>MQ 的分类</h2>\n<h3><a id=\"ActiveMQ_38\"></a>ActiveMQ</h3>\n<p>优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较高，较低的概率丢失数据。</p>\n<p>缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p>\n<h3><a id=\"Kafka_46\"></a>Kafka</h3>\n<p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>\n<p>性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。</p>\n</li>\n<li>\n<p>时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次。</p>\n</li>\n<li>\n<p>有优秀的第三方 Kafka Web 管理界面 Kafka-Manager。</p>\n</li>\n<li>\n<p>在日志领域比较成熟，被多家公司和多个开源项目使用。</p>\n</li>\n<li>\n<p>功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p>\n</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长。</li>\n<li>使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试。</li>\n<li>支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢。</li>\n</ul>\n<h3><a id=\"RocketMQ_67\"></a>RocketMQ</h3>\n<p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>\n<p>单机吞吐量十万级，可用性非常高。</p>\n</li>\n<li>\n<p>分布式架构,消息可以做到 0 丢失。</p>\n</li>\n<li>\n<p>MQ 功能较为完善，还是分布式的。</p>\n</li>\n<li>\n<p>扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降。</p>\n</li>\n<li>\n<p>源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</p>\n</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟。</li>\n<li>社区活跃度一般，没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。</li>\n</ul>\n<h3><a id=\"RabbitMQ_87\"></a>RabbitMQ</h3>\n<p>2007 年发布，是一个在 AMQP(高级消息队列协议) 基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>由于 erlang 语言的高并发特性，性能较好。</li>\n<li>吞吐量到万级，MQ 功能比较完备。</li>\n<li>健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全。</li>\n<li>开源提供的管理界面非常棒，用起来很好用，社区活跃度高。</li>\n<li>更新频率相当高。</li>\n</ul>\n<p><strong>缺点</strong>：商业版需要收费，学习成本较高。</p>\n<h2><a id=\"MQ__103\"></a>MQ 的选择</h2>\n<h3><a id=\"Kafka_105\"></a>Kafka</h3>\n<p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。</p>\n<h3><a id=\"RocketMQ_111\"></a>RocketMQ</h3>\n<p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>\n<h3><a id=\"RabbitMQ_117\"></a>RabbitMQ</h3>\n<p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p>\n<h1><a id=\"RabbitMQ__123\"></a>RabbitMQ 简介</h1>\n<h2><a id=\"_125\"></a>概述</h2>\n<p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220511213222787.png\" alt=\"image-20220511213222787\" /></p>\n<h2><a id=\"_133\"></a>四大核心概念</h2>\n<p><strong>生产者</strong>：产生数据发送消息的程序是生产者。</p>\n<p><strong>交换机</strong>：交换机是 RabbitMQ 中非常重要的一个部件，一方面它接收来自生产者的消息，另以方面它将消息推送到队列中。交换机必须确切的知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定。</p>\n<p><strong>队列</strong>：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。</p>\n<p><strong>消费者</strong>：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者、消费者和消息中间件很多时候并不在同一台机器上。同一个应用程序既可以是生产者也可以是消费者。</p>\n<h2><a id=\"Rabbit__145\"></a>Rabbit 核心部分</h2>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220511213906770.png\" alt=\"image-20220511213906770\" /></p>\n<h2><a id=\"_151\"></a>各个名词介绍</h2>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220511213933082.png\" alt=\"image-20220511213933082\" /></p>\n<p><strong>Broker</strong></p>\n<p>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。</p>\n<p><strong>Virtual Host</strong></p>\n<p>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ Server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange / queue 等。</p>\n<p><strong>Connection</strong></p>\n<p>publisher / consumer 和 broker 之间的 TCP 连接。</p>\n<p><strong>Channel</strong></p>\n<p>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。</p>\n<p>Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。</p>\n<p><mark>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</mark></p>\n<p><strong>Exchange</strong></p>\n<p>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct(point-to-point)、topic(publish-subscribe)、fanout(multicast)。</p>\n<p><strong>Queue</strong></p>\n<p>消息最终被送到这里等待 consumer 取走。</p>\n<p><strong>Binding</strong></p>\n<p>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 的查询表中，用于 message 的分发依据。</p>\n<h1><a id=\"_189\"></a>安装</h1>\n<blockquote>\n<p><strong>Tip：以下演示的是如何在 CentOS7 中安装 RabbitMQ。</strong></p>\n</blockquote>\n<p>由于 RabbitMQ 是基于 erlang 语言编写的，所以安装 RabbitMQ 之前，我们需要让我们的虚拟机有 erlang 语言的环境。</p>\n<p><strong>erlang 下载地址</strong>：https://github.com/rabbitmq/erlang-rpm/releases。</p>\n<p><strong>RabbitMQ 下载地址</strong>：https://github.com/rabbitmq/rabbitmq-server/releases。</p>\n<p>不同 RabbitMQ 的版本对应不同的 erlang 版本，具体的对应关系可以见：https://www.rabbitmq.com/which-erlang.html。</p>\n<p>我们下载 <code>rpm</code> 后缀的即可：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220512151829069.png\" alt=\"image-20220512151829069\" /></p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220512151915323.png\" alt=\"image-20220512151915323\" /></p>\n<p>安装完成之后，我们可以需要把两个文件上传到服务器，我将其上传到了 <code>/opt/rabbitMQ</code> 目录下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ mkdir /opt/rabbitMQ\n$ <span class=\"hljs-built_in\">cd</span> /opt/rabbitMQ/\n$ ls\nerlang-23.3.4.11-1.el7.x86_64.rpm  rabbitmq-server-3.10.1-1.el8.noarch.rpm\n</code></div></pre>\n<p>分别输入如下命令安装：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ rpm -ivh erlang-23.3.4.11-1.el7.x86_64.rpm\n$ yum install socat -y\n$ rpm -ivh rabbitmq-server-3.10.1-1.el8.noarch.rpm\n</code></div></pre>\n<p>常用命令：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-comment\"># 添加开机启动 RabbitMQ 服务</span>\n$ chkconfig rabbitmq-server on\n<span class=\"hljs-comment\"># 启动服务</span>\n$ /sbin/service rabbitmq-server start\n<span class=\"hljs-comment\"># 查看服务状态</span>\n$ /sbin/service rabbitmq-server status\n<span class=\"hljs-comment\"># 停止服务</span>\n$ /sbin/service rabbitmq-server stop\n</code></div></pre>\n<p>启动服务后，查看服务状态如果为 <code>active(running)</code> ，说明安装成功！</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220512152619241.png\" alt=\"image-20220512152619241\" /></p>\n<h1><a id=\"_Web__245\"></a>开启 Web 管理界面</h1>\n<p>我们通常通过 Web 管理界面来管理 RabbitMQ，执行如下命令安装 RabbitMQ 的 Web 管理插件。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ rabbitmq-plugins <span class=\"hljs-built_in\">enable</span> rabbitmq_management\n</code></div></pre>\n<p>安装完服务后需要重启 RabbitMQ，并且如果防火墙没有关闭，还需要关闭防火墙。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\">$ systemctl stop firewall		<span class=\"hljs-comment\"># 关闭防火墙</span>\n$ systemctl <span class=\"hljs-built_in\">disable</span> firewalld	<span class=\"hljs-comment\"># 关闭防火墙开机自启动</span>\n</code></div></pre>\n<p>访问地址 <code>http://服务器IP:15672</code>  进入 Web 网管界面，默认账号和密码都为 <code>grant</code> 。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220512153746162.png\" alt=\"image-20220512153746162\" /></p>\n<p>不过是进不去，这是权限的问题。</p>\n<p><strong>用户配置常用命令</strong>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-comment\"># 创建用户</span>\n$ rabbitmqctl add_user &lt;username&gt; &lt;password&gt;\n<span class=\"hljs-comment\"># 设置用户角色</span>\n$ rabbitmqctl set_user_tags &lt;username&gt; &lt;role&gt;\n<span class=\"hljs-comment\"># 设置用户权限</span>\n$ rabbitmqctl set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class=\"hljs-built_in\">read</span>&gt;\n<span class=\"hljs-comment\"># 查看所有用户及其角色</span>\n$ rabbitmqctl list_users\n</code></div></pre>\n<p>所以我们可以通过如下命令，创建一个 <code>admin</code> 用户，密码为 <code>123456</code> 。</p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-comment\"># 创建用户并设置密码</span>\n$ rabbitmqctl add_user admin 123456\n<span class=\"hljs-comment\"># 将admin用户的角色设置为administrator</span>\n$ rabbitmqctl set_user_tags admin administrator\n<span class=\"hljs-comment\"># admin用户具有 \"/\" 这个vhost中的配置、写、读的全部权限</span>\n$ rabbitmqctl set_permissions -p <span class=\"hljs-string\">\"/\"</span> admin <span class=\"hljs-string\">\".*\"</span> <span class=\"hljs-string\">\".*\"</span> <span class=\"hljs-string\">\".*\"</span>\n</code></div></pre>\n<p>然后我们再使用 <code>admin</code> 用户登录，应该是没问题的</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220512160640450.png\" alt=\"image-20220512160640450\" /></p>\n<p><strong>其他相关命令</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-bash\"><span class=\"hljs-comment\"># 关闭Web应用</span>\n$ rabbitmqctl stop_app\n<span class=\"hljs-comment\"># 清除应用信息</span>\n$ rabbitmqctl reset\n<span class=\"hljs-comment\"># 重新启动Web应用</span>\n$ rabbitmqctl start_app\n</code></div></pre>\n<hr />\n<p><strong>本章完。</strong></p>\n',1534439635018657793),(1405916999854342211,'# 应用 & 组件实例\n\n## 创建一个应用实例\n\n每个 Vue 应用都是通过用 `createApp` 函数创建一个新的**应用实例**开始的：\n\n```js\ndadaconst app = Vue.createApp({\n  /* 选项 */\n})\n```\n\n该应用实例是用来在应用中注册“全局”组件的。应用实例暴露的大多数方法都会返回该同一实例，允许链式：\n\n```js\nVue.createApp({})\n  .component(\'SearchInput\', SearchInputComponent)\n  .directive(\'focus\', FocusDirective)\n  .use(LocalePlugin)\n```\n\n\n\n## 根组件\n\n传递给 `createApp` 的选项用于配置**根组件**。当我们**挂载**应用时，该组件被用作渲染的起点。\n\n一个应用需要被挂载到一个 DOM 元素中。例如，如果你想把一个 Vue 应用挂载到 `<div id=\"app\"></div>`，应该传入 `#app`：\n\n```js\n// 根组件\nconst RootComponent = { \n  /* 选项 */ \n}\n// 根据根组件创建应用\nconst app = Vue.createApp(RootComponent)\n// 挂载应用，返回根组件实例\nconst vm = app.mount(\'#app\')\n```\n\n与大多数应用方法不同的是，`mount` 不返回应用本身。相反，它返回的是根组件实例。\n\n尽管本页面上的所有示例都只需要一个单一的组件就可以，但是大多数的真实应用都是被组织成一个嵌套的、可重用的组件树。举个例子，一个 todo 应用组件树可能是这样的：\n\n```\nRoot Component\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ DeleteTodoButton\n   │  └─ EditTodoButton\n   └─ TodoListFooter\n      ├─ ClearTodosButton\n      └─ TodoListStatistics\n```\n\n每个组件将有自己的组件实例 `vm`。对于一些组件，如 `TodoItem`，在任何时候都可能有多个实例渲染。这个应用中的所有组件实例将共享同一个应用实例。\n\n\n\n## 组件实例 property\n\n在前面的指南中，我们认识了 `data` property。在 `data` 中定义的 property 是通过组件实例暴露的：\n\n```js\nconst app = Vue.createApp({\n  data() {\n    return { count: 4 }\n  }\n})\n\nconst vm = app.mount(\'#app\')\n\nconsole.log(vm.count) // => 4\n```\n\n还有各种其他的组件选项，可以将用户定义的 property 添加到组件实例中，例如 `methods`，`props`，`computed`，`inject` 和 `setup`。我们将在后面的指南中深入讨论它们。组件实例的所有 property，无论如何定义，都可以在组件的模板中访问。\n\nVue 还通过组件实例暴露了一些内置 property，如 `$attrs` 和 `$emit`。这些 property 都有一个 `$` 前缀，以避免与用户定义的 property 名冲突。\n\n\n\n## 生命周期\n\n下图展示了实例的生命周期。我们不需要立马弄明白所有的东西，不过随着不断学习和使用，它的参考价值会越来越高。\n\n![image-20220402151731184](http://img.liubaiblog.top/img/image-20220402151731184.png)\n\n每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做**生命周期钩子**的函数，这给了用户在不同阶段添加自己的代码的机会。\n\n```html\n<!-- html代码 -->\n<div id=\"life-cycle\">\n    <p id=\"p1\">p标签</p>\n</div>\n```\n\n```html\n<!-- js代码 -->\n<script>\n    // 创建Vue应用\n    const app = Vue.createApp({\n        // Vue应用创建前执行\n        beforeCreate() {\n            console.log(\'--------- beforeCreate ---------\')\n            console.log(this.book)\n            console.log(document.querySelector(\"#p1\"))\n            console.log(\'--------- beforeCreate ---------\')\n            console.log(\'\')\n        },\n        // Vue应用创建后执行(应用创建之后，才能获取到data()中的数据)\n        created() {\n            console.log(\'--------- created ---------\')\n            console.log(this.book)\n            console.log(document.querySelector(\"#p1\"))\n            console.log(\'--------- created ---------\')\n            console.log(\'\')\n        },\n        // Vue应该挂载前执行\n        beforeMount() {\n            console.log(\'--------- beforeMount ---------\')\n            console.log(this.book)\n            console.log(document.querySelector(\"#p1\"))\n            console.log(\'--------- beforeMount ---------\')\n            console.log(\'\')\n        },\n        // Vue应该挂载后执行(再挂载完成之后，才能获取到DOM对象)\n        mounted() {\n            console.log(\'--------- mounted ---------\')\n            console.log(this.book)\n            console.log(document.querySelector(\"#p1\"))\n            console.log(\'--------- mounted ---------\')\n            console.log(\'\')\n        },\n        data() {\n            return {\n                book: \'哈利波特\'\n            }\n        }\n    })\n\n    app.mount(\'#life-cycle\')\n</script>\n```\n\n![image-20220402152256778](http://img.liubaiblog.top/img/image-20220402152256778.png)\n\n\n\n---\n\n\n\n# 模板语法\n\nVue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层组件实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。\n\n在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应性系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。\n\n## 插值\n\n###  文本\n\n数据绑定最常见的就是使用 ` {{ message }}`  双大括号的语法赋值，双大括号中的内容会被替换为对应实例中的属性值，如果属性值发生了改变，则插值处也会被改变。\n\n如果不想插值后的数据被改变，则可以使用 `v-once` 指令执行一次性插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定。\n\n```html\n<!-- html代码 -->\n<div id=\"app\">\n    <span>渲染后可能被改变: {{ message }}</span><br>\n    <span v-once>渲染后不再改变: {{ message }}</span><br>\n    <button v-on:click=\"this.message=\'Hello JavaScript!\'\">修改</button>\n</div>\n```\n\n```html\n<!-- js代码 -->\n<script>\n    // 根组件\n    let Root = {\n        data() {\n            return {\n                message: \'Hello Vue!\'\n            }\n        }\n    }\n	// 创建应用\n    const app = Vue.createApp(Root)\n	// 挂载应用\n    const vm = app.mount(\'#app\')\n</script>\n```\n\n![image-20220402154611877](http://img.liubaiblog.top/img/image-20220402154611877.png)\n\n下面内容中的js部分代码会适当减少，基本都是基于以上的模板，不过是在data()中添加适当的数据。\n\n\n\n### 原始HTML\n\n双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用`v-html` 指令：\n\n```html\n<p>普通文本: {{ html }}</p>\n<p>原始HTML文本: <span v-html=\"html\"></span></p>\n```\n\n![image-20220402155055197](http://img.liubaiblog.top/img/image-20220402155055197.png)\n\n这个 `span` 的内容将会被替换成为 `html` 属性值，直接作为 HTML。会忽略解析 property 值中的数据绑定。\n\n\n\n### Attribute\n\n使用vue提供的 `v-bind` 指令可以为HTML标签绑定任意的vue应用中的属性值。\n\n```html\n<input type=\"text\" v-bind:placeholder=\"t_val\">\n<input type=\"button\" v-bind:disabled=\"btn_dis\" value=\"提交\">\n```\n\n如果绑定的值是 `null` 或 `undefined`，那么该 attribute 将不会被包含在渲染的元素上。\n\n![image-20220402160006070](http://img.liubaiblog.top/img/image-20220402160006070.png)\n\n\n\n### 使用JavaScript表达式\n\n迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。\n\n```html\n<p>{{ message.length === 3 }}</p>\n<p>{{ message.split(\' \')[0] }}</p>\n<p>{{ message.length > 5 ? \'big\' : \'small\' }}</p>\n<p v-bind:id=\"\'list-\' + id\">{{ id}}</p>\n```\n\n这些表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含**单个表达式**，所以下面的例子都**不会**生效。\n\n```html\n<!--  这是语句，不是表达式：-->\n{{ var a = 1 }}\n\n<!-- 流程控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n```\n\n\n\n## 指令\n\n指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。指令 attribute 的值预期是**单个 JavaScript 表达式** (`v-for` 和 `v-on` 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：\n\n```html\n<p v-if=\"seen\">现在你看到我了</p>\n```\n\n这里，`v-if` 指令将根据表达式 `seen` 的值的真假来插入/移除 `<p>` 元素。\n\n\n\n###  参数\n\n一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML 属性：\n\n```html\n<a v-bind:href=\"url\">跳转</a>\n```\n\n这里的 `href` 是参数，告知 `v-bind` 指令将该元素的 `href` 属性和表达式的 `url` 值绑定，最后显示的效果就是 `<a href=\'url绑定的内容\'>跳转</a>` 。\n\n\n\n### 动态参数\n\n也可以在指令参数中使用 JavaScript 表达式，方法是用方括号括起来：\n\n```html\n<!--\n注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。\n-->\n<a v-bind:[attr_name]=\"url\"> ... </a>\n```\n\n这里的 `attr_name` 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。\n\n比如组件实例中data()中绑定的 `attr_name` 值为 ` \"href\"` ，那么这个绑定等价于 ` v-bind:href=\"url\"` 。\n\n==**注意**：动态参数中绑定的标签需要避免大写，因为浏览器会把标签中所有大写的标签属性全部转换为小写，那么在vue解析的时候，还是只能解析到小写的参数。==	\n\n\n\n### 修饰符\n\n修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：\n\n```html\n<form v-on:submit.prevent=\"onSubmit\">...</form>\n```\n\n在接下来对 `v-on`和 `v-for` 等功能的探索中，你会看到修饰符的其它例子。\n\n\n\n## 缩写\n\n`v-` 前缀作为一种视觉提示，用来识别模板中 Vue 特定的属性。然而，对于一些频繁用到的指令来说，就会感到使用繁琐。所以Vue.js提供了一套缩写的方式来简化开发，实现的效果和带 `v-` 前缀的效果一致。\n\n\n\n**`v-bind`  缩写**\n\n```html\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"> ... </a>\n\n<!-- 缩写 -->\n<a :href=\"url\"> ... </a>\n\n<!-- 动态参数的缩写 -->\n<a :[key]=\"url\"> ... </a>\n```\n\n\n\n**`v-on` 缩写**\n\n```html\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- 缩写 -->\n<a @click=\"doSomething\"> ... </a>\n\n<!-- 动态参数的缩写 -->\n<a @[event]=\"doSomething\"> ... </a>\n```\n\n它们看起来可能与普通的 HTML 略有不同，但 `:` 与 `@` 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。\n\n\n\n---\n\n\n\n# Data Property和方法\n\n组件的 `data` 选项是一个函数。Vue 会在创建新组件实例的过程中调用此函数。通过data()函数创建的对象，会以 `$data` 的形式存储在组件实例当中。\n\n用 `methods` 选项可以向组件实例中添加方法，Vue 自动为 `methods` 绑定 `this`，以便于它始终指向组件实例。这将确保方法在用作事件监听或回调时保持正确的 `this` 指向。\n\n外部的Js程序，可以通过调用挂载的实例获取系列参数，或者\n\n```js\nlet Root = {\n    data() {\n        return {\n            count: 1\n        }\n    },\n    methods: {\n        add() {\n            this.count++;\n        }\n    }\n}\n\nconst app = Vue.createApp(Root)\nconst vm = app.mount(\'#app\')\n\nconsole.log(vm.$data.count) // => 4\nconsole.log(vm.count)       // => 4\n\n// 可以调用挂载实例的方法\nvm.add()\nconsole.log(vm.$data.count) // => 5\n\n// 修改 vm.count 的值也会更新 $data.count\nvm.count = 5\nconsole.log(vm.$data.count) // => 5\n```\n\n==注意：在定义 `methods` 时应避免使用箭头函数，因为这会阻止 Vue 绑定恰当的 `this` 指向。==\n\n\n\n---\n\n\n\n# 计算属性和侦听器\n\n## 计算属性\n\n模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。\n\n```html\n<!-- html代码 -->\n<div id=\"app\">\n    <p>name: {{ person.name }}</p>\n    <p>birthday: {{ new Date().getFullYear() - person.age }}</p>\n</div>\n```\n\n```html\n<!-- js代码 -->\n<script>\n    let Root = {\n        data() {\n            return {\n                person: {\n                    name: \'Mary\',\n                    age: 17\n                }\n            }\n        }\n    }\n\n    const app = Vue.createApp(Root)\n\n    const vm = app.mount(\'#app\')\n</script>\n```\n\n根据上面的代码，可以根据年龄来查询用户的出生年份。\n\n![image-20220402172519406](http://img.liubaiblog.top/img/image-20220402172519406.png)\n\n虽然可以实现结果，但是如果在模板中需要多次包含此计算，问题就会变得很糟，而且不利于复用。\n\n所以，对于任何包含响应式数据的复杂逻辑，你都应该使用**计算属性**。\n\n\n\n### 基本例子\n\n```html\n<!-- html代码 -->\n<div id=\"app\">\n    <p>name: {{ person.name }}</p>\n    <p>birthday: {{ getBirthday }}</p>\n</div>\n```\n\n```html\n<!-- js代码 -->\n<script>\n    let Root = {\n        data() {\n            return {\n                person: {\n                    name: \'Mary\',\n                    age: 17\n                }\n            }\n        },\n        computed: {\n            getBirthday() {\n                return new Date().getFullYear() - this.person.age\n            }\n        }\n    }\n\n    const app = Vue.createApp(Root)\n\n    const vm = app.mount(\'#app\')\n</script>\n```\n\n结果和之前是一致的：\n\n![image-20220402172519406](http://img.liubaiblog.top/img/image-20220402172519406.png)\n\n这里声明了一个计算属性 ` getBirthday`，更改person中age的值，对应的 ` getBirthday` 也会修改。和原先相比，这种方式更利于代码的维护和复用。\n\n\n\n### 计算属性缓存 vs 方法\n\n你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：\n\n```html\n<p>birthday: {{ calcBirthday() }}</p>\n```\n\n```js\n// 在组件中\nmethods: {\n    calcBirthday() {\n        return new Date().getFullYear() - this.person.age \n    }\n}\n```\n\n我们可以将同样的函数定义为一个方法，而不是一个计算属性。从最终结果来说，这两种实现方式确实是完全相同的。然而，不同的是**计算属性将基于它们的响应依赖关系缓存**。\n\n这就意味着只要 ` this.person.age ` 没有发生改变，多次访问 `getBirthday`  时计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n这也同样意味着下面的计算属性将永远不会更新，因为 `Date.now ()` 不是响应式依赖：\n\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n\n相比之下，每当触发重新渲染时，调用方法将**始终**会再次执行函数。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 `list`，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 `list`。如果没有缓存，我们将不可避免的多次执行 `list` 的 getter！如果你不希望有缓存，请用 `method` 来替代。\n\n\n\n## 侦听器\n\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 `watch` 选项提供了一个更通用的方法来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n\n例如：\n\n```html\n<!-- html代码 -->\n<div id=\"app\">\n    <input type=\"text\" v-model=\"question\"><br>\n    <p>{{ answer }}</p>\n</div>\n```\n\n```html\n<!-- js代码 -->\n<script>\n    let Root = {\n        data() {\n            return {\n                question: \'\',\n                answer: \'null\'\n            }\n        },\n        computed: {\n            getDate() {\n                return Date.now();\n            }\n        },\n        watch: {\n            question(newQuestion, OldQuestion) {\n                if (newQuestion.indexOf(\'?\') > -1) {\n                    this.getAnswer(newQuestion)\n                }\n            }\n        },\n        methods: {\n            getAnswer(question) {\n                this.answer = question.length\n            }\n        }\n    }\n\n    const app = Vue.createApp(Root)\n\n    const vm = app.mount(\'#app\')\n</script>\n```\n\n通过上面的代码，可以实现用户输入?之后，计算出字符串的长度。\n\n![image-20220402175423295](http://img.liubaiblog.top/img/image-20220402175423295.png)\n\n\n\n### 计算属性 vs 侦听器\n\nVue 提供了一种更通用的方式来观察和响应当前活动的实例上的数据变动：**侦听属性**。当你有一些数据需要随着其它数据变动而变动时，`watch` 很容易被滥用，很多时候使用计算属性可以更方便的实现效果，包括上面的例子，用计算属性也可以实现效果\n\n```html\n<!-- html代码 -->\n<div id=\"demo\">\n    <p>姓: <input type=\"text\" v-model=\"firstname\"></p>\n    <p>名: <input type=\"text\" v-model=\"lastname\"></p>\n    <p>{{ fullname }}</p>\n</div>\n```\n\n```html\n<!-- js代码 -->\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                firstname: \'\',\n                lastname: \'\',\n                fullname: \'\'\n            }\n        },\n        watch: {\n            // 监听firstname\n            firstname(newFirstname, oldFirstname) {\n                this.fullname = newFirstname + this.lastname\n            },\n            // 监听lastname\n            lastname(newLastname, oldLastname) {\n                this.fullname = this.firstname + newLastname;\n            }\n        }\n    }).mount(\"#demo\")\n```\n\n![image-20220402180154156](http://img.liubaiblog.top/img/image-20220402180154156.png)\n\n上面代码是命令式且重复的。将它与计算属性的版本进行比较：\n\n```html\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                firstname: \'\',\n                lastname: \'\',\n            }\n        },\n        computed: {\n            fullname() {\n                return this.firstname + this.lastname\n            }\n        }\n    }).mount(\"#demo\")\n</script>\n```\n\n这样不是简单得多吗？\n\n\n\n---\n\n\n\n# Class 和 Style 绑定\n\n操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 `v-bind` 处理它们：只需要通过表达式计算出字符串结果即可。\n\n## 绑定 HTML Class\n\n### 对象语法\n\n我们可以传给 `:class` (`v-bind:class` 的简写) 一个对象，以动态地切换 class：\n\n```html\n<div :class=\"{active: isActive}\">{{ message }}</div>\n```\n\n上面的语法表示 `active` 这个 class 存在与否将取决于data()中返回的 `isActive` 的值为true还是false。\n\n你可以在对象中传入更多字段来动态切换多个 class。此外，`:class` 指令也可以与普通的 `class` 共存。当有如下模板：\n\n```html\n<div :class=\"{active: isActive, danger: isDanger}\" class=\"static\">{{ message }}</div>\n```\n\n和如下的data:\n\n```js\ndata() {\n    return {\n        message: \'Hello Vue!\',\n        isActive: true,\n        isDanger: true\n    }\n}\n```\n\n渲染的结果为:\n\n```html\n<div class=\"active danger static\">Hello Vue!</div>\n```\n\n当 `isActive` 或者 ` isDanger` 变化时，class列表将相应的更新。\n\n绑定的数据对象不必内联定义在模板里：\n\n```html\n<div :class=\"classObject\"></div>\n```\n\n```js\ndata() {\n    return {\n        classObj: {\n            active: true,\n            danger: false\n        }\n    }\n}\n```\n\n渲染的结果为：\n\n```html\n<div class=\"active\">Hello Vue!</div>\n```\n\n我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式：\n\n```html\n<div :class=\"{active: getActive}\" class=\"static\">{{ message }}</div>\n```\n\n```js\ncomputed: {\n    getActive() {\n        return this.message.length < 3\n    }\n}\n```\n\n\n\n### 数组语法\n\n我们可以把一个数组传给 `:class`，以应用一个 class 列表：\n\n```html\n<div :class=\"[activeClass, dangerClass]\">Hello JavaScript</div>\n```\n\n```js\ndata() {\n  return {\n      activeClass: \'active\',\n      dangerClass: \'danger\'\n  }\n}\n```\n\n渲染结果为：\n\n```html\n<div class=\"active danger\">Hello JavaScript</div>\n```\n\n不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：\n\n```html\n<div :class=\"[{active: isActive}, dangerClass]\">Hello JavaScript</div>\n```\n\n\n\n### 在组件上使用\n\n当你在带有单个根元素的自定义组件上使用 `class` 属性时，这些 class 将被添加到该元素中。此元素上的现有 class 将不会被覆盖。\n\n例如，如果你声明了这个组件：\n\n```js\nconst app = Vue.createApp({\n    data() {\n        return {\n            isActive: true\n        }\n    }\n})\n\napp.component(\'my-component\', {\n  template: `<p class=\"foo bar\">Hi!</p>`\n})\n\napp.mount(\'#app\');\n```\n\n这个组件的模板自带了 `class` 属性，但是我们使用的使用再添加一些class：\n\n```\n<my-component :class=\"{active: isActive}\"></my-component>\n```\n\n那么最终将被渲染为：\n\n```html\n<h1 class=\"foo box active\">Hi!</h1>\n```\n\n\n\n## 绑定内联样式\n\n### 对象语法\n\n`:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：\n\n```html\n<p :style=\"{color: fontColor, fontSize: fontSize + \'px\'}\">Hello</p>\n```\n\n```js\ndata() {\n    return {\n        fontColor: \'red\',\n        fontSize: 30\n    }\n}\n```\n\n渲染完成后：\n\n```html\n<p style=\"color: red; font-size: 30px;\">Hello</p>\n```\n\n直接绑定到一个样式对象通常更好，这会让模板更清晰：\n\n```html\n<p :style=\"styleObj\">Good</p>\n```\n\n```js\ndata() {\n    return {\n        styleObj: {\n            color: \'red\',\n            fontSize: \'30px\'\n        }\n    }\n}\n```\n\n渲染的效果和上方是一致的。\n\n\n\n### 数组语法\n\n`:style` 的数组语法可以将多个样式对象应用到同一个元素上：\n\n```html\n<p :style=\"[styleObj, styleObj2]\">Good Boy</p>\n```\n\n```js\ndata() {\n    return {\n        styleObj: {\n            color: \'red\',\n            fontSize: \'30px\'\n        },\n        styleObj2: {\n            background: \'green\'\n        }\n    }\n}\n```\n\n\n\n### 多重值\n\n可以为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：\n\n```html\n<p :style=\"{background: [\'red\', \'green\', \'yellow\']}\">Good girl</p>\n```\n\n==这样写只会渲染数组中最后一个被浏览器支持的值==。在本例中，最终生效的 `background` 实际上是 ` yellow` 。\n\n\n\n---\n\n\n\n# 条件渲染\n\n##  v-if\n\n`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。\n\n```html\n<h1 v-if=\"show\">Hello Vue</h1>\n```\n\n也可以用 `v-else` 添加一个“else 块”：\n\n```html\n<h1 v-if=\"show\">Hello Vue</h1>\n<h1 v-else>Hello JavaScript</h1>\n```\n\n还可以添加 ` v-else-if ` ，和条件判断语句一致：\n\n```html\n<div v-if=\"type === \'A\'\">\n    A\n</div>\n<div v-else-if=\"type === \'B\'\">\n    B\n</div>\n<div v-else-if=\"type === \'C\'\">\n    C\n</div>\n<div v-else>\n    Not A/B/C\n</div>\n```\n\n\n\n### 在 `<template>` 元素上使用 `v-if` 条件渲染分组\n\n因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。**最终的渲染结果将不包含 `<template>` 元素。**\n\n```html\n<template v-if=\"show\">\n    <h1>Title</h1>\n    <p>Paragraph 1</p>\n    <p>Paragraph 2</p>\n</template>\n<template v-else>\n    <h1>TitleElse</h1>\n    <p>Paragraph 3</p>\n    <p>Paragraph 4</p>\n</template>\n```\n\n\n\n## v-show\n\n另一个用于条件性展示元素的选项是 `v-show` 指令。用法大致一样：\n\n```html\n<h1 v-show=\"show\">Hello!</h1>\n```\n\n不同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 的原理只是简单的为标签添加 `display = \'none\'` 样式。\n\n注意，`v-show` 不支持 `<template>` 元素，也不支持 `v-else`。\n\n\n\n## v-if VS v-show\n\n`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\n\n`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\n\n\n\n## v-if 与 v-for 一起使用\n\n**不推荐**同时使用 `v-if` 和 `v-for`。当 `v-if` 与 `v-for` 一起使用时，`v-if` 具有比 `v-for` 更高的优先级。\n\n\n\n---\n\n\n\n# 列表渲染\n\n## 用 `v-for` 把一个数组映射为一组元素\n\n我们可以用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 items 是源数据数组，而 `item` 则是被迭代的数组元素的**别名**。\n\n```html\n<ul>\n    <li v-for=\"item in fruits\">水果名: {{ item.name }}, 价格: {{ item.price }}元/斤</li>\n</ul>\n```\n\n```js\ndata() {\n    return {\n        fruits: [\n            {name: \'苹果\', price: 4},\n            {name: \'橘子\', price: 3},\n            {name: \'香蕉\', price: 2},\n        ]\n    }\n}\n```\n\n结果：\n\n![image-20220402213950135](http://img.liubaiblog.top/img/image-20220402213950135.png)\n\n`v-for` 还支持一个可选的第二个参数，即当前项的索引。\n\n```html\n<ul>\n    <li v-for=\"(item, index) in fruits\">{{ index + 1 }}、水果名: {{ item.name }}, 价格: {{ item.price }}元/斤</li>\n</ul>\n```\n\n结果：\n\n![image-20220402214134885](http://img.liubaiblog.top/img/image-20220402214134885.png)\n\n也可以用 `of` 替代 `in` 作为分隔符，因为它更接近 JavaScript 迭代器的语法：\n\n```html\n<div v-for=\"item of items\"></div>\n```\n\n\n\n## 在 v-for 里使用对象\n\n你也可以用 `v-for` 来遍历一个对象的所有属性。\n\n```html\n<p>个人资料</p>\n<p v-for=\"value in person\">{{ value }}</p>\n```\n\n```js\ndata() {\n    return {\n        person: {\n            name: \'张三\',\n            age: 20,\n            address: \'北京市\'\n        }\n    }\n}\n```\n\n结果：\n\n![image-20220402214613197](http://img.liubaiblog.top/img/image-20220402214613197.png)\n\n同样，我们可以提供第二个参数(键名)，甚至第三个参数(索引)：\n\n```html\n<p>个人资料</p>\n<p v-for=\"(value, name, index) in person\">{{ index }}、{{ name }}: {{ value }}</p>\n```\n\n结果：\n\n![image-20220402214852779](http://img.liubaiblog.top/img/image-20220402214852779.png)\n\n\n\n## 维护状态\n\n为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 `key` 属性：\n\n```html\n<div v-for=\"item in items\" :key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n建议尽可能在使用 `v-for` 时提供 `key` attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。\n\n如果这个数据是从后端请求的，一般使用该数据的主键作为key。\n\n==注意：不要使用对象或数组之类的非基本类型值作为 `v-for` 的 key。请用字符串或数值类型的值。==\n\n\n\n## 在 v-for 里使用值的范围\n\n`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。\n\n```html\n<div>\n    <span v-for=\"n in 10\" :key=\"n\">{{ n }}&nbsp;</span>\n</div>\n```\n\n结果：\n\n![image-20220402215350477](http://img.liubaiblog.top/img/image-20220402215350477.png)\n\n\n\n## 在 \\<template\\> 中使用 v-for\n\n类似于 `v-if`，你也可以利用带有 `v-for` 的 `<template>` 来循环渲染一段包含多个元素的内容。比如：\n\n```html\n<ul>\n  <template v-for=\"item in items\" :key=\"item.msg\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n</ul>\n```\n\n\n\n## v-for 与 v-if 一同使用\n\n注意我们**不**推荐在同一元素上使用 `v-if` 和 `v-for`。当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：\n\n```html\n<!-- 注意：这里是一个错误演示 -->\n<ul>\n    <li v-for=\"item in fruits\" v-if=\"item.show\"></li>\n</ul>\n```\n\n可以把 `v-for` 移动到 `<template>` 标签中来修正：\n\n```html\n<ul>\n    <template v-for=\"item in fruits\">\n        <li v-if=\"item.show\">{{ item.name }}</li>\n    </template>\n</ul>\n```\n\n\n\n---\n\n\n\n# 事件处理\n\n## 监听事件\n\n我们可以使用 `v-on` 指令 (通常缩写为 `@` 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为 `v-on:click=\"methodName\"` 或使用快捷方式 `@click=\"methodName\"`\n\n例如：\n\n```html\n<div id=\"app\">\n    <p>number: {{ number }}</p>\n    <button @click=\"addNum\">增加</button>\n</div>\n```\n\n```html\n<script>\n    let Root = {\n        data() {\n            return {\n                number: 1\n            }\n        }, \n        methods: {\n            addNum() {\n                this.number++;\n            }\n        }\n    }\n\n    const app = Vue.createApp(Root)\n    const vm = app.mount(\'#app\')\n</script>\n```\n\n结果：\n\n![image-20220402222900074](http://img.liubaiblog.top/img/image-20220402222900074.png)\n\n当然，`@click` 中可以直接写一些简单的js语句执行，而不一定是方法，但是在业务逻辑更为复杂的时候，还是需要绑定一个方法。\n\n\n\n## 内联处理器中的方法\n\n除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：\n\n```html\n<div id=\"inline-handler\">\n  <button @click=\"say(\'hi\')\">Say hi</button>\n  <button @click=\"say(\'what\')\">Say what</button>\n</div>\n```\n\n```js\nVue.createApp({\n  methods: {\n    say(message) {\n      alert(message)\n    }\n  }\n}).mount(\'#inline-handler\')\n```\n\n结果：\n\n![image-20220402223516402](http://img.liubaiblog.top/img/image-20220402223516402.png)\n\n有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：\n\n```html\n<button @click=\"say(\'hi\', $event)\">sayHi</button>\n```\n\n```js\n// ...\nmethods: {\n    say(message, event) {\n        alert(message)\n        console.log(event.target)\n    }\n}\n```\n\n\n\n##  多事件处理器\n\n事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：\n\n```html\n<!-- 这两个 one() 和 two() 将执行按钮点击事件 -->\n<button @click=\"one($event), two($event)\">\n  Submit\n</button>\n```\n\n```js\n// ...\nmethods: {\n  one(event) {\n    // 第一个事件处理器逻辑...\n  },\n  two(event) {\n   // 第二个事件处理器逻辑...\n  }\n}\n```\n\n\n\n## 事件修饰符\n\n在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n\n为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**。之前提过，修饰符是由点开头的指令后缀来表示的。\n\n- `.stop`\n- `.prevent`\n- `.capture`\n- `.self`\n- `.once`\n- `.passive`\n\n```html\n<!-- 阻止单击事件继续冒泡 -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- 取消表单默认事件并执行指定函数 -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联 -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- 只有修饰符 -->\n<form @submit.prevent></form>\n\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->\n<!-- 即事件不是从内部元素触发的 -->\n<div @click.self=\"doThat\">...</div>\n```\n\n>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `@click.prevent.self` 会阻止**元素本身及其子元素的点击的默认行为**，而 `@click.self.prevent` 只会阻止对元素自身的点击的默认行为。\n\n```html\n<!-- 事件只会触发一次，之后不再生效 -->\n<button @click.once=\"say(\'hi\', $event)\">sayHi</button>\n\n<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发，   -->\n<!-- 而不会等待 `onScroll` 完成，                    -->\n<!-- 以防止其中包含 `event.preventDefault()` 的情况  -->\n<div @scroll.passive=\"onScroll\">...</div>\n```\n\n这个 `.passive` 修饰符尤其能够提升移动端的性能。\n\n==注意：**不要把 `.passive` 和 `.prevent` 一起使用**，因为 `.prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，`.passive` 会告诉浏览器你*不想*阻止事件的默认行为。==\n\n\n\n## 按键修饰符\n\n在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许为 `v-on` 或者 `@` 在监听键盘事件时添加按键修饰符：\n\n```html\n<!-- 当键盘按下 `enter` 键并弹起时调用 `vm.submit()` -->\n<input @keyup.enter=\"submit\" />\n```\n\n也可以为键盘绑定指定的按键来作为修饰符：\n\n```html\n<!-- 当用户y键弹起时 -->\n<input type=\"text\" @keyup.y=\"say(\'hello\')\">\n<!-- 当用户PageDown键弹起时 -->\n<input @keyup.page-down=\"onPageDown\" />\n```\n\n\n\n### 按键别名\n\nVue 为最常用的键提供了别名：\n\n- `.enter`\n- `.tab`\n- `.delete` (捕获“删除”和“退格”键)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n\n\n## 系统修饰键\n\n可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。\n\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n例如：\n\n```html\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n\n\n\n### .exact 修饰符\n\n`.exact` 修饰符允许你控制由精确的系统修饰符组合触发的事件。\n\n```html\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button @click.exact=\"onClick\">A</button>\n```\n\n\n\n### 鼠标按钮修饰符\n\n- `.left`\n- `.right`\n- `.middle`\n\n这些修饰符会限制处理函数仅响应特定的鼠标按钮。\n\n\n\n---\n\n\n\n# 表单输入绑定\n\n## 基础用法\n\n你可以用 v-model 指令在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\n`v-model` 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n\n- text 和 textarea 元素使用 `value` property 和 `input` 事件；\n- checkbox 和 radio 使用 `checked` property 和 `change` 事件；\n- select 字段将 `value` 作为 prop 并将 `change` 作为事件。\n\n\n\n### 文本框\n\n```html\n<!-- 单行文本框 -->\n<input type=\"text\" v-model=\"msg\"> \n<p>input message: {{ msg }}</p>\n<!-- 多行文本框 -->\n<textarea v-model=\"multiMsg\"></textarea>\n<p style=\"white-space: pre-line;\">textarea message: {{ multiMsg }}</p>\n```\n\n```js\ndata() {\n    return {\n        msg: \'\',\n        multiMsg: \'\'\n    }\n}\n```\n\n结果：\n\n![image-20220403151249796](http://img.liubaiblog.top/img/image-20220403151249796.png)\n\n\n\n注意：插值在 textarea 中不起作用，请使用 `v-model` 来代替。\n\n```html\n<!-- 错误 -->\n<textarea>{{ text }}</textarea>\n\n<!-- 正确 -->\n<textarea v-model=\"text\"></textarea>\n```\n\n\n\n### 复选框\n\n单个复选框，并且 `v-model` 绑定的是一个布尔值时，可以表示该复选框是否被选定：\n\n```html\n<p><input type=\"checkbox\" v-model=\"checked\">男{{checked}}</p>\n```\n\n```js\ndata() {\n    return {\n        checked: true,\n    }\n}\n```\n\n\n\n结果：\n\n![image-20220403152043642](http://img.liubaiblog.top/img/image-20220403152043642.png)\n\n多个复选框，可以绑定到同一个数组：\n\n```html\n<p>\n    <input type=\"checkbox\" value=\"Jack\" v-model=\"names\">Jack\n    <input type=\"checkbox\" value=\"Mary\" v-model=\"names\">Mary\n    <input type=\"checkbox\" value=\"Bob\" v-model=\"names\">Bob\n</p>\n<p>checked names: {{ names }}</p>\n```\n\n```js\ndata() {\n    return {\n        names: []\n    }\n}\n```\n\n结果：\n\n![image-20220403152255195](http://img.liubaiblog.top/img/image-20220403152255195.png)\n\n\n\n### 单选框\n\n单选框绑定是单选的value值：\n\n```html\n<p>\n    <input type=\"radio\" value=\"man\" v-model=\"picked\"> 男\n    <input type=\"radio\" value=\"woman\" v-model=\"picked\"> 女\n</p>\n<p>性别: {{ picked }}</p>\n```\n\n```js\ndata() {\n    return {\n        picked: \'\'\n    }\n}\n```\n\n结果：\n\n![image-20220403152603571](http://img.liubaiblog.top/img/image-20220403152603571.png)\n\n\n\n\n\n### 选择框\n\n```html\n<select v-model=\"city\">\n    <option disabled value=\"\">选择您的城市</option>\n    <option>北京</option>\n    <option>上海</option>\n    <option>广州</option>\n    <option>深圳</option>\n</select>\n<p>城市: {{ city }}</p>\n```\n\n```js\ndata() {\n    return {\n        city: \'\'\n    }\n}\n```\n\n结果：\n\n![image-20220403152956976](http://img.liubaiblog.top/img/image-20220403152956976.png)\n\n注意：如果 `v-model` 表达式的初始值未能匹配任何选项，`<select>` 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 `change` 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。\n\n如果选择框添加多选属性，则会绑定为一个数组：\n\n```html\n<select v-model=\"city\" multiple>\n    <option disabled value=\"\">select</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n    <option>D</option>\n</select>\n<p>selected: {{ city }}</p>\n```\n\n结果：\n\n![image-20220403153230398](http://img.liubaiblog.top/img/image-20220403153230398.png)\n\n\n\n## 值绑定\n\n对于单选按钮，复选框及选择框的选项，`v-model` 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)。\n\n但是有时我们可能想把值绑定到当前活动实例的一个动态 property 上，这时可以用 `v-bind` 实现，此外，使用 `v-bind` 可以将输入值绑定到非字符串。\n\n\n\n### 复选框\n\n```html\n<p><input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\" />toggle: {{ toggle }}</p>\n\n<!--\n当选中时，toggle === \'yes\'\n未选中时，toggle === \'no\'\n-->\n```\n\n![image-20220403153915628](http://img.liubaiblog.top/img/image-20220403153915628.png)\n\n\n\n### 单选框\n\n```html\n<input type=\"radio\" v-model=\"pick\" :value=\"a\" />\n<!-- 当选中时，vm.pick === vm.a -->\n```\n\n\n\n### 选择框\n\n```html\n<select v-model=\"selected\">\n  <!-- 内联对象字面量 -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>\n<!--\n	当选中时\n    typeof vm.selected // => \'object\'\n    vm.selected.number // => 123\n-->\n```\n\n\n\n## 修饰符\n\n### .lazy\n\n在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步：\n\n```html\n<!-- 一般在输入框失去焦点或者用户回车时，触发`change`事件 -->\n<input type=\"text\" v-model.lazy=\"msg\"> \n```\n\n\n\n### .number\n\n如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\n\n```html\n<input v-model.number=\"age\" type=\"text\" />\n```\n\n当输入类型为 `text` 时这通常很有用。如果输入类型是 `number`，Vue 能够自动将原始字符串转换为数字，无需为 `v-model` 添加 `.number` 修饰符。如果这个值无法被 `parseFloat()` 解析，则返回原始的值。\n\n\n\n### .trim\n\n如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n\n```html\n<input v-model.trim=\"msg\" />\n```\n\n\n\n---\n\n\n\n# 组合式 API\n\n> **Tips: 这一小节可能比较复杂，可以先学习后面内容再回来学习。**\n\n通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。\n\n假设我们的应用中有一个显示某个用户的仓库列表的视图。此外，我们还希望有搜索和筛选功能。实现此视图组件的代码可能如下所示：\n\n```js\n// src/components/UserRepositories.vue\n\nexport default {\n  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  props: {\n    user: { \n      type: String,\n      required: true\n    }\n  },\n  data () {\n    return {\n      repositories: [], // 1\n      filters: { ... }, // 3\n      searchQuery: \'\' // 2\n    }\n  },\n  computed: {\n    filteredRepositories () { ... }, // 3\n    repositoriesMatchingSearchQuery () { ... }, // 2\n  },\n  watch: {\n    user: \'getUserRepositories\' // 1\n  },\n  methods: {\n    getUserRepositories () {\n      // 使用 `this.user` 获取用户仓库\n    }, // 1\n    updateFilters () { ... }, // 3\n  },\n  mounted () {\n    this.getUserRepositories() // 1\n  }\n}\n```\n\n> **以上处理相似业务逻辑的部分标记了相同的数值。**\n\n该组件有以下几个职责：\n\n1. 从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新\n\n2. 使用 `searchQuery` 字符串搜索仓库\n\n3. 使用 `filters` 对象筛选仓库\n\n使用 (`data`、`computed`、`methods`、`watch`) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，**逻辑关注点**的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会**导致组件难以阅读和理解**。\n\n如果能够将同一个逻辑关注点相关代码收集在一起会更好。而这正是组合式 API 使我们能够做到的。\n\n\n\n## 组合式 API 基础\n\n既然我们知道了**为什么**，我们就可以知道**怎么做**。为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在 Vue 组件中，我们将此位置称为 `setup` 。\n\n### `setup` 组件选项\n\n新的 `setup` 选项在组件创建**之前**执行，一旦 `props` 被解析，就将作为组合式 API 的入口。\n\n> **注意：在 `setup` 中你应该避免使用 `this`，因为它不会找到组件实例。`setup` 的调用发生在 `data` property、`computed` property 或 `methods` 被解析之前，所以它们无法在 `setup` 中被获取。**\n\n`setup` 选项是一个接收 `props` 和 `context` 的函数，此外，我们将 `setup` 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。\n\n让我们把 `setup` 添加到组件中：\n\n```js\n// src/components/UserRepositories.vue\n\nexport default {\n  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  props: {\n    user: {\n      type: String,\n      required: true\n    }\n  },\n  setup(props) {\n    console.log(props) // { user: \'\' }\n\n    return {} // 这里返回的任何内容都可以用于组件的其余部分\n  }\n  // 组件的“其余部分”\n}\n```\n\n现在让我们从提取第一个逻辑关注点开始 (在原始代码段中标记为“1”)。\n\n\n\n>  **1、从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新**\n\n我们将从最明显的部分开始：\n\n- 仓库列表\n- 更新仓库列表的函数\n- 返回列表和函数，以便其他组件选项可以对它们进行访问\n\n```js\n// src/components/UserRepositories.vue `setup` function\nimport { fetchUserRepositories } from \'@/api/repositories\'\n\n// 在我们的组件内\nsetup (props) {\n  let repositories = []\n  const getUserRepositories = async () => {\n    repositories = await fetchUserRepositories(props.user)\n  }\n\n  return {\n    repositories,\n    getUserRepositories // 返回的函数与方法的行为相同\n  }\n}\n```\n\n这是我们的出发点，但它还无法生效，因为 `repositories` 变量是非响应式的。这意味着从用户的角度来看，仓库列表将始终为空。让我们来解决这个问题！\n\n\n\n### 带 `ref` 的响应式变量\n\n在 Vue 3.0 中，我们可以通过一个新的 `ref` 函数使任何响应式变量在任何地方起作用，如下所示：\n\n```js\nimport { ref } from \'vue\'\n\nsetup() {\n    const counter = ref(0)\n}\n```\n\n`ref` 接收参数并将其包裹在一个带有 `value` property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：\n\n```js\nimport { ref } from \'vue\'\n\nsetup() {\n    const counter = ref(0)\n\n    console.log(counter) // { value: 0 }\n    console.log(counter.value) // 0\n\n    counter.value++\n    console.log(counter.value) // 1\n}\n```\n\n`ref` 为我们的值创建了一个**响应式引用**。在整个组合式 API 中会经常使用**引用**的概念。\n\n回到我们的例子，让我们创建一个响应式的 `repositories` 变量：\n\n```js\n// src/components/UserRepositories.vue `setup` function\nimport { fetchUserRepositories } from \'@/api/repositories\'\nimport { ref } from \'vue\'\n\n// 在我们的组件中\nsetup (props) {\n  const repositories = ref([])\n  const getUserRepositories = async () => {\n    repositories.value = await fetchUserRepositories(props.user)\n  }\n\n  return {\n    repositories,\n    getUserRepositories\n  }\n}\n```\n\n完成！现在，每当我们调用 `getUserRepositories` 时，`repositories` 都将发生变化，视图也会更新以反映变化。我们的组件现在应该如下所示：\n\n```js\n// src/components/UserRepositories.vue\nimport { fetchUserRepositories } from \'@/api/repositories\'\nimport { ref } from \'vue\'\n\nexport default {\n  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  props: {\n    user: {\n      type: String,\n      required: true\n    }\n  },\n  setup (props) {\n    const repositories = ref([])\n    const getUserRepositories = async () => {\n      repositories.value = await fetchUserRepositories(props.user)\n    }\n\n    return {\n      repositories,\n      getUserRepositories\n    }\n  },\n  data () {\n    return {\n      filters: { ... }, // 3\n      searchQuery: \'\' // 2\n    }\n  },\n  computed: {\n    filteredRepositories () { ... }, // 3\n    repositoriesMatchingSearchQuery () { ... }, // 2\n  },\n  watch: {\n    user: \'getUserRepositories\' // 1\n  },\n  methods: {\n    updateFilters () { ... }, // 3\n  },\n  mounted () {\n    this.getUserRepositories() // 1\n  }\n}\n```\n\n我们已经将第一个逻辑关注点中的几个部分移到了 `setup` 方法中，它们彼此非常接近。剩下的就是在 `mounted` 钩子中调用 `getUserRepositories`，并设置一个监听器，以便在 `user` prop 发生变化时执行此操作。\n\n我们将从生命周期钩子开始。\n\n\n\n### 在 `setup` **内注册生命周期钩子**\n\n为了使组合式 API 的功能和选项式 API 一样完整，我们还需要一种在 `setup` 中注册生命周期钩子的方法。这要归功于 Vue 导出的几个新函数。组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 `on`：即 `mounted` 看起来会像 `onMounted`。\n\n这些函数接受一个回调，当钩子被组件调用时，该回调将被执行。\n\n让我们将其添加到 `setup` 函数中：\n\n```js\n// src/components/UserRepositories.vue `setup` function\nimport { fetchUserRepositories } from \'@/api/repositories\'\nimport { ref, onMounted } from \'vue\'\n\n// 在我们的组件中\nsetup (props) {\n  const repositories = ref([])\n  const getUserRepositories = async () => {\n    repositories.value = await fetchUserRepositories(props.user)\n  }\n\n  onMounted(getUserRepositories) // 在 `mounted` 时调用 `getUserRepositories`\n\n  return {\n    repositories,\n    getUserRepositories\n  }\n}\n```\n\n现在我们需要对 `user` prop 的变化做出反应。为此，我们将使用独立的 `watch` 函数。\n\n\n\n### `watch` 响应式更改\n\n就像我们在组件中使用 `watch` 选项并在 `user` property 上设置侦听器一样，我们也可以使用从 Vue 导入的 `watch` 函数执行相同的操作。它接受 3 个参数：\n\n- 一个想要侦听的**响应式引用**或 getter 函数\n- 一个回调\n- 可选的配置选项\n\n**下面让我们快速了解一下它是如何工作的**\n\n```js\nimport { ref, watch } from \'vue\'\n\nsetup() {\n    const counter = ref(0)\n    watch(counter, (newValue, oldValue) => {\n      console.log(\'The new counter value is: \' + counter.value)\n    })\n}\n```\n\n每当 `counter` 被修改时，例如 `counter.value=5`，侦听将触发并执行回调 (第二个参数)，在本例中，它将把 `\'The new counter value is:5\'` 记录到控制台中。\n\n**以下是等效的选项式 API：**\n\n```js\nexport default {\n  data() {\n    return {\n      counter: 0\n    }\n  },\n  watch: {\n    counter(newValue, oldValue) {\n      console.log(\'The new counter value is: \' + this.counter)\n    }\n  }\n}\n```\n\n**现在我们将其应用到我们的示例中：**\n\n```js\n// src/components/UserRepositories.vue `setup` function\nimport { fetchUserRepositories } from \'@/api/repositories\'\nimport { ref, onMounted, watch, toRefs } from \'vue\'\n\n// 在我们组件中\nsetup (props) {\n  // 使用 `toRefs` 创建对 `props` 中的 `user` property 的响应式引用\n  const { user } = toRefs(props)\n\n  const repositories = ref([])\n  const getUserRepositories = async () => {\n    // 更新 `prop.user` 到 `user.value` 访问引用值\n    repositories.value = await fetchUserRepositories(user.value)\n  }\n\n  onMounted(getUserRepositories)\n\n  // 在 user prop 的响应式引用上设置一个侦听器\n  watch(user, getUserRepositories)\n\n  return {\n    repositories,\n    getUserRepositories\n  }\n}\n```\n\n你可能已经注意到在我们的 `setup` 的顶部使用了 `toRefs`。这是为了确保我们的侦听器能够根据 `user` prop 的变化做出反应。\n\n有了这些变化，我们就把第一个逻辑关注点移到了一个地方。我们现在可以对第二个关注点执行相同的操作——基于 `searchQuery` 进行过滤，这次是使用计算属性。\n\n\n\n### 独立的 `computed` 属性\n\n与 `ref` 和 `watch` 类似，也可以使用从 Vue 导入的 `computed` 函数在 Vue 组件外部创建计算属性。让我们回到 counter 的例子：\n\n```js\nimport { ref, computed } from \'vue\'\n\nsetup() {\n    const counter = ref(0)\n    const twiceTheCounter = computed(() => counter.value * 2)\n\n    counter.value++\n    console.log(counter.value) // 1\n    console.log(twiceTheCounter.value) // 2\n    \n    return {\n        counter,\n        twiceTheCounter\n    }\n}\n```\n\n这里我们给 `computed` 函数传递了第一个参数，它是一个类似 getter 的回调函数，输出的是一个*只读*的**响应式引用**。为了访问新创建的计算变量的 **value**，我们需要像 `ref` 一样使用 `.value` property。\n\n让我们将搜索功能移到 `setup` 中：\n\n```js\n// src/components/UserRepositories.vue `setup` function\nimport { fetchUserRepositories } from \'@/api/repositories\'\nimport { ref, onMounted, watch, toRefs, computed } from \'vue\'\n\n// 在我们的组件中\nsetup (props) {\n  // 使用 `toRefs` 创建对 props 中的 `user` property 的响应式引用\n  const { user } = toRefs(props)\n\n  const repositories = ref([])\n  const getUserRepositories = async () => {\n    // 更新 `props.user ` 到 `user.value` 访问引用值\n    repositories.value = await fetchUserRepositories(user.value)\n  }\n\n  onMounted(getUserRepositories)\n\n  // 在 user prop 的响应式引用上设置一个侦听器\n  watch(user, getUserRepositories)\n\n  const searchQuery = ref(\'\')\n  const repositoriesMatchingSearchQuery = computed(() => {\n    return repositories.value.filter(\n      repository => repository.name.includes(searchQuery.value)\n    )\n  })\n\n  return {\n    repositories,\n    getUserRepositories,\n    searchQuery,\n    repositoriesMatchingSearchQuery\n  }\n}\n```\n\n对于其他的**逻辑关注点**我们也可以这样做，但是你可能已经在问这个问题了——*这不就是把代码移到 `setup` 选项并使它变得非常大吗*？嗯，确实是这样的。\n\n这就是为什么我们要在继续其他任务之前，我们首先要将上述代码提取到一个独立的**组合式函数**中。\n\n\n\n### 组合式函数\n\n让我们从创建 `useUserRepositories` 函数开始：\n\n```js\n// src/composables/useUserRepositories.js\n\nimport { fetchUserRepositories } from \'@/api/repositories\'\nimport { ref, onMounted, watch } from \'vue\'\n\nexport default function useUserRepositories(user) {\n  const repositories = ref([])\n  const getUserRepositories = async () => {\n    repositories.value = await fetchUserRepositories(user.value)\n  }\n\n  onMounted(getUserRepositories)\n  watch(user, getUserRepositories)\n\n  return {\n    repositories,\n    getUserRepositories\n  }\n}\n```\n\n然后是搜索功能：\n\n```js\n// src/composables/useRepositoryNameSearch.js\n\nimport { ref, computed } from \'vue\'\n\nexport default function useRepositoryNameSearch(repositories) {\n  const searchQuery = ref(\'\')\n  const repositoriesMatchingSearchQuery = computed(() => {\n    return repositories.value.filter(repository => {\n      return repository.name.includes(searchQuery.value)\n    })\n  })\n\n  return {\n    searchQuery,\n    repositoriesMatchingSearchQuery\n  }\n}\n```\n\n**现在我们有了两个单独的功能模块，接下来就可以开始在组件中使用它们了。以下是如何做到这一点：**\n\n```js\n// src/components/UserRepositories.vue\nimport useUserRepositories from \'@/composables/useUserRepositories\'\nimport useRepositoryNameSearch from \'@/composables/useRepositoryNameSearch\'\nimport { toRefs } from \'vue\'\n\nexport default {\n  components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  props: {\n    user: {\n      type: String,\n      required: true\n    }\n  },\n  setup (props) {\n    const { user } = toRefs(props)\n\n    const { repositories, getUserRepositories } = useUserRepositories(user)\n\n    const {\n      searchQuery,\n      repositoriesMatchingSearchQuery\n    } = useRepositoryNameSearch(repositories)\n\n    return {\n      // 因为我们并不关心未经过滤的仓库\n      // 我们可以在 `repositories` 名称下暴露过滤后的结果\n      repositories: repositoriesMatchingSearchQuery,\n      getUserRepositories,\n      searchQuery,\n    }\n  },\n  data () {\n    return {\n      filters: { ... }, // 3\n    }\n  },\n  computed: {\n    filteredRepositories () { ... }, // 3\n  },\n  methods: {\n    updateFilters () { ... }, // 3\n  }\n}\n```\n\n此时，你可能已经知道了其中的奥妙，其他功能也可以类似的迁移。\n\n\n\n---\n\n**本章完。**\n\n','<h1><a id=\"___0\"></a>应用 &amp; 组件实例</h1>\n<h2><a id=\"_2\"></a>创建一个应用实例</h2>\n<p>每个 Vue 应用都是通过用 <code>createApp</code> 函数创建一个新的<strong>应用实例</strong>开始的：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">dadaconst app = Vue.createApp({\n  <span class=\"hljs-comment\">/* 选项 */</span>\n})\n</code></div></pre>\n<p>该应用实例是用来在应用中注册“全局”组件的。应用实例暴露的大多数方法都会返回该同一实例，允许链式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">Vue.createApp({})\n  .component(<span class=\"hljs-string\">\'SearchInput\'</span>, SearchInputComponent)\n  .directive(<span class=\"hljs-string\">\'focus\'</span>, FocusDirective)\n  .use(LocalePlugin)\n</code></div></pre>\n<h2><a id=\"_23\"></a>根组件</h2>\n<p>传递给 <code>createApp</code> 的选项用于配置<strong>根组件</strong>。当我们<strong>挂载</strong>应用时，该组件被用作渲染的起点。</p>\n<p>一个应用需要被挂载到一个 DOM 元素中。例如，如果你想把一个 Vue 应用挂载到 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，应该传入 <code>#app</code>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// 根组件</span>\n<span class=\"hljs-keyword\">const</span> RootComponent = { \n  <span class=\"hljs-comment\">/* 选项 */</span> \n}\n<span class=\"hljs-comment\">// 根据根组件创建应用</span>\n<span class=\"hljs-keyword\">const</span> app = Vue.createApp(RootComponent)\n<span class=\"hljs-comment\">// 挂载应用，返回根组件实例</span>\n<span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n</code></div></pre>\n<p>与大多数应用方法不同的是，<code>mount</code> 不返回应用本身。相反，它返回的是根组件实例。</p>\n<p>尽管本页面上的所有示例都只需要一个单一的组件就可以，但是大多数的真实应用都是被组织成一个嵌套的、可重用的组件树。举个例子，一个 todo 应用组件树可能是这样的：</p>\n<pre><code class=\"lang-\">Root Component\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ DeleteTodoButton\n   │  └─ EditTodoButton\n   └─ TodoListFooter\n      ├─ ClearTodosButton\n      └─ TodoListStatistics\n</code></pre>\n<p>每个组件将有自己的组件实例 <code>vm</code>。对于一些组件，如 <code>TodoItem</code>，在任何时候都可能有多个实例渲染。这个应用中的所有组件实例将共享同一个应用实例。</p>\n<h2><a id=\"_property_59\"></a>组件实例 property</h2>\n<p>在前面的指南中，我们认识了 <code>data</code> property。在 <code>data</code> 中定义的 property 是通过组件实例暴露的：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp({\n  data() {\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">4</span> }\n  }\n})\n\n<span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n\n<span class=\"hljs-built_in\">console</span>.log(vm.count) <span class=\"hljs-comment\">// =&gt; 4</span>\n</code></div></pre>\n<p>还有各种其他的组件选项，可以将用户定义的 property 添加到组件实例中，例如 <code>methods</code>，<code>props</code>，<code>computed</code>，<code>inject</code> 和 <code>setup</code>。我们将在后面的指南中深入讨论它们。组件实例的所有 property，无论如何定义，都可以在组件的模板中访问。</p>\n<p>Vue 还通过组件实例暴露了一些内置 property，如 <code>$attrs</code> 和 <code>$emit</code>。这些 property 都有一个 <code>$</code> 前缀，以避免与用户定义的 property 名冲突。</p>\n<h2><a id=\"_81\"></a>生命周期</h2>\n<p>下图展示了实例的生命周期。我们不需要立马弄明白所有的东西，不过随着不断学习和使用，它的参考价值会越来越高。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402151731184.png\" alt=\"image-20220402151731184\" /></p>\n<p>每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- html代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"life-cycle\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"p1\"</span>&gt;</span>p标签<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- js代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-comment\">// 创建Vue应用</span>\n    <span class=\"hljs-keyword\">const</span> app = Vue.createApp({\n        <span class=\"hljs-comment\">// Vue应用创建前执行</span>\n        beforeCreate() {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- beforeCreate ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.book)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\"#p1\"</span>))\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- beforeCreate ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'\'</span>)\n        },\n        <span class=\"hljs-comment\">// Vue应用创建后执行(应用创建之后，才能获取到data()中的数据)</span>\n        created() {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- created ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.book)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\"#p1\"</span>))\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- created ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'\'</span>)\n        },\n        <span class=\"hljs-comment\">// Vue应该挂载前执行</span>\n        beforeMount() {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- beforeMount ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.book)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\"#p1\"</span>))\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- beforeMount ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'\'</span>)\n        },\n        <span class=\"hljs-comment\">// Vue应该挂载后执行(再挂载完成之后，才能获取到DOM对象)</span>\n        mounted() {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- mounted ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.book)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\"#p1\"</span>))\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'--------- mounted ---------\'</span>)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'\'</span>)\n        },\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">book</span>: <span class=\"hljs-string\">\'哈利波特\'</span>\n            }\n        }\n    })\n\n    app.mount(<span class=\"hljs-string\">\'#life-cycle\'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402152256778.png\" alt=\"image-20220402152256778\" /></p>\n<hr />\n<h1><a id=\"_152\"></a>模板语法</h1>\n<p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层组件实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>\n<p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应性系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p>\n<h2><a id=\"_158\"></a>插值</h2>\n<h3><a id=\"_160\"></a>文本</h3>\n<p>数据绑定最常见的就是使用 <code> {{ message }}</code>  双大括号的语法赋值，双大括号中的内容会被替换为对应实例中的属性值，如果属性值发生了改变，则插值处也会被改变。</p>\n<p>如果不想插值后的数据被改变，则可以使用 <code>v-once</code> 指令执行一次性插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- html代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>渲染后可能被改变: {{ message }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>渲染后不再改变: {{ message }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"this.message=\'Hello JavaScript!\'\"</span>&gt;</span>修改<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- js代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-comment\">// 根组件</span>\n    <span class=\"hljs-keyword\">let</span> Root = {\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue!\'</span>\n            }\n        }\n    }\n	<span class=\"hljs-comment\">// 创建应用</span>\n    <span class=\"hljs-keyword\">const</span> app = Vue.createApp(Root)\n	<span class=\"hljs-comment\">// 挂载应用</span>\n    <span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402154611877.png\" alt=\"image-20220402154611877\" /></p>\n<p>下面内容中的js部分代码会适当减少，基本都是基于以上的模板，不过是在data()中添加适当的数据。</p>\n<h3><a id=\"HTML_199\"></a>原始HTML</h3>\n<p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用<code>v-html</code> 指令：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>普通文本: {{ html }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>原始HTML文本: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"html\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402155055197.png\" alt=\"image-20220402155055197\" /></p>\n<p>这个 <code>span</code> 的内容将会被替换成为 <code>html</code> 属性值，直接作为 HTML。会忽略解析 property 值中的数据绑定。</p>\n<h3><a id=\"Attribute_214\"></a>Attribute</h3>\n<p>使用vue提供的 <code>v-bind</code> 指令可以为HTML标签绑定任意的vue应用中的属性值。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">v-bind:placeholder</span>=<span class=\"hljs-string\">\"t_val\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">v-bind:disabled</span>=<span class=\"hljs-string\">\"btn_dis\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"提交\"</span>&gt;</span>\n</code></div></pre>\n<p>如果绑定的值是 <code>null</code> 或 <code>undefined</code>，那么该 attribute 将不会被包含在渲染的元素上。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402160006070.png\" alt=\"image-20220402160006070\" /></p>\n<h3><a id=\"JavaScript_229\"></a>使用JavaScript表达式</h3>\n<p>迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ message.length === 3 }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ message.split(\' \')[0] }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ message.length &gt; 5 ? \'big\' : \'small\' }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"\'list-\' + id\"</span>&gt;</span>{{ id}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<p>这些表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!--  这是语句，不是表达式：--&gt;</span>\n{{ var a = 1 }}\n\n<span class=\"hljs-comment\">&lt;!-- 流程控制也不会生效，请使用三元表达式 --&gt;</span>\n{{ if (ok) { return message } }}\n</code></div></pre>\n<h2><a id=\"_252\"></a>指令</h2>\n<p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 和 <code>v-on</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"seen\"</span>&gt;</span>现在你看到我了<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<p>这里，<code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来插入/移除 <code>&lt;p&gt;</code> 元素。</p>\n<h3><a id=\"_264\"></a>参数</h3>\n<p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML 属性：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span>跳转<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></div></pre>\n<p>这里的 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> 属性和表达式的 <code>url</code> 值绑定，最后显示的效果就是 <code>&lt;a href=\'url绑定的内容\'&gt;跳转&lt;/a&gt;</code> 。</p>\n<h3><a id=\"_276\"></a>动态参数</h3>\n<p>也可以在指令参数中使用 JavaScript 表达式，方法是用方括号括起来：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!--\n注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。\n--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">attr_name</span>]=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></div></pre>\n<p>这里的 <code>attr_name</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。</p>\n<p>比如组件实例中data()中绑定的 <code>attr_name</code> 值为 <code> &quot;href&quot;</code> ，那么这个绑定等价于 <code> v-bind:href=&quot;url&quot;</code> 。</p>\n<p><mark><strong>注意</strong>：动态参数中绑定的标签需要避免大写，因为浏览器会把标签中所有大写的标签属性全部转换为小写，那么在vue解析的时候，还是只能解析到小写的参数。</mark></p>\n<h3><a id=\"_295\"></a>修饰符</h3>\n<p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>=<span class=\"hljs-string\">\"onSubmit\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></div></pre>\n<p>在接下来对 <code>v-on</code>和 <code>v-for</code> 等功能的探索中，你会看到修饰符的其它例子。</p>\n<h2><a id=\"_307\"></a>缩写</h2>\n<p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的属性。然而，对于一些频繁用到的指令来说，就会感到使用繁琐。所以Vue.js提供了一套缩写的方式来简化开发，实现的效果和带 <code>v-</code> 前缀的效果一致。</p>\n<p><strong><code>v-bind</code>  缩写</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 完整语法 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态参数的缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></div></pre>\n<p><strong><code>v-on</code> 缩写</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 完整语法 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 动态参数的缩写 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></div></pre>\n<p>它们看起来可能与普通的 HTML 略有不同，但 <code>:</code> 与 <code>@</code> 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</p>\n<hr />\n<h1><a id=\"Data_Property_349\"></a>Data Property和方法</h1>\n<p>组件的 <code>data</code> 选项是一个函数。Vue 会在创建新组件实例的过程中调用此函数。通过data()函数创建的对象，会以 <code>$data</code> 的形式存储在组件实例当中。</p>\n<p>用 <code>methods</code> 选项可以向组件实例中添加方法，Vue 自动为 <code>methods</code> 绑定 <code>this</code>，以便于它始终指向组件实例。这将确保方法在用作事件监听或回调时保持正确的 <code>this</code> 指向。</p>\n<p>外部的Js程序，可以通过调用挂载的实例获取系列参数，或者</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> Root = {\n    data() {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span>\n        }\n    },\n    <span class=\"hljs-attr\">methods</span>: {\n        add() {\n            <span class=\"hljs-keyword\">this</span>.count++;\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">const</span> app = Vue.createApp(Root)\n<span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n\n<span class=\"hljs-built_in\">console</span>.log(vm.$data.count) <span class=\"hljs-comment\">// =&gt; 4</span>\n<span class=\"hljs-built_in\">console</span>.log(vm.count)       <span class=\"hljs-comment\">// =&gt; 4</span>\n\n<span class=\"hljs-comment\">// 可以调用挂载实例的方法</span>\nvm.add()\n<span class=\"hljs-built_in\">console</span>.log(vm.$data.count) <span class=\"hljs-comment\">// =&gt; 5</span>\n\n<span class=\"hljs-comment\">// 修改 vm.count 的值也会更新 $data.count</span>\nvm.count = <span class=\"hljs-number\">5</span>\n<span class=\"hljs-built_in\">console</span>.log(vm.$data.count) <span class=\"hljs-comment\">// =&gt; 5</span>\n</code></div></pre>\n<p><mark>注意：在定义 <code>methods</code> 时应避免使用箭头函数，因为这会阻止 Vue 绑定恰当的 <code>this</code> 指向。</mark></p>\n<hr />\n<h1><a id=\"_394\"></a>计算属性和侦听器</h1>\n<h2><a id=\"_396\"></a>计算属性</h2>\n<p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- html代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>name: {{ person.name }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>birthday: {{ new Date().getFullYear() - person.age }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- js代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> Root = {\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">person</span>: {\n                    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'Mary\'</span>,\n                    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">17</span>\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">const</span> app = Vue.createApp(Root)\n\n    <span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></div></pre>\n<p>根据上面的代码，可以根据年龄来查询用户的出生年份。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402172519406.png\" alt=\"image-20220402172519406\" /></p>\n<p>虽然可以实现结果，但是如果在模板中需要多次包含此计算，问题就会变得很糟，而且不利于复用。</p>\n<p>所以，对于任何包含响应式数据的复杂逻辑，你都应该使用<strong>计算属性</strong>。</p>\n<h3><a id=\"_438\"></a>基本例子</h3>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- html代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>name: {{ person.name }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>birthday: {{ getBirthday }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- js代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> Root = {\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">person</span>: {\n                    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'Mary\'</span>,\n                    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">17</span>\n                }\n            }\n        },\n        <span class=\"hljs-attr\">computed</span>: {\n            getBirthday() {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-keyword\">this</span>.person.age\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">const</span> app = Vue.createApp(Root)\n\n    <span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></div></pre>\n<p>结果和之前是一致的：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402172519406.png\" alt=\"image-20220402172519406\" /></p>\n<p>这里声明了一个计算属性 <code> getBirthday</code>，更改person中age的值，对应的 <code> getBirthday</code> 也会修改。和原先相比，这种方式更利于代码的维护和复用。</p>\n<h3><a id=\"_vs__481\"></a>计算属性缓存 vs 方法</h3>\n<p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>birthday: {{ calcBirthday() }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// 在组件中</span>\nmethods: {\n    calcBirthday() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getFullYear() - <span class=\"hljs-keyword\">this</span>.person.age \n    }\n}\n</code></div></pre>\n<p>我们可以将同样的函数定义为一个方法，而不是一个计算属性。从最终结果来说，这两种实现方式确实是完全相同的。然而，不同的是<strong>计算属性将基于它们的响应依赖关系缓存</strong>。</p>\n<p>这就意味着只要 <code>this.person.age</code> 没有发生改变，多次访问 <code>getBirthday</code>  时计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>\n<p>这也同样意味着下面的计算属性将永远不会更新，因为 <code>Date.now ()</code> 不是响应式依赖：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">computed: {\n  now() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()\n  }\n}\n</code></div></pre>\n<p>相比之下，每当触发重新渲染时，调用方法将<strong>始终</strong>会再次执行函数。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <code>list</code>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <code>list</code>。如果没有缓存，我们将不可避免的多次执行 <code>list</code> 的 getter！如果你不希望有缓存，请用 <code>method</code> 来替代。</p>\n<h2><a id=\"_518\"></a>侦听器</h2>\n<p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>\n<p>例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- html代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"question\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ answer }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- js代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> Root = {\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">question</span>: <span class=\"hljs-string\">\'\'</span>,\n                <span class=\"hljs-attr\">answer</span>: <span class=\"hljs-string\">\'null\'</span>\n            }\n        },\n        <span class=\"hljs-attr\">computed</span>: {\n            getDate() {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now();\n            }\n        },\n        <span class=\"hljs-attr\">watch</span>: {\n            question(newQuestion, OldQuestion) {\n                <span class=\"hljs-keyword\">if</span> (newQuestion.indexOf(<span class=\"hljs-string\">\'?\'</span>) &gt; <span class=\"hljs-number\">-1</span>) {\n                    <span class=\"hljs-keyword\">this</span>.getAnswer(newQuestion)\n                }\n            }\n        },\n        <span class=\"hljs-attr\">methods</span>: {\n            getAnswer(question) {\n                <span class=\"hljs-keyword\">this</span>.answer = question.length\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">const</span> app = Vue.createApp(Root)\n\n    <span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></div></pre>\n<p>通过上面的代码，可以实现用户输入?之后，计算出字符串的长度。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402175423295.png\" alt=\"image-20220402175423295\" /></p>\n<h3><a id=\"_vs__573\"></a>计算属性 vs 侦听器</h3>\n<p>Vue 提供了一种更通用的方式来观察和响应当前活动的实例上的数据变动：<strong>侦听属性</strong>。当你有一些数据需要随着其它数据变动而变动时，<code>watch</code> 很容易被滥用，很多时候使用计算属性可以更方便的实现效果，包括上面的例子，用计算属性也可以实现效果</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- html代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demo\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>姓: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"firstname\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>名: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"lastname\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ fullname }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- js代码 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    Vue.createApp({\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">firstname</span>: <span class=\"hljs-string\">\'\'</span>,\n                <span class=\"hljs-attr\">lastname</span>: <span class=\"hljs-string\">\'\'</span>,\n                <span class=\"hljs-attr\">fullname</span>: <span class=\"hljs-string\">\'\'</span>\n            }\n        },\n        <span class=\"hljs-attr\">watch</span>: {\n            <span class=\"hljs-comment\">// 监听firstname</span>\n            firstname(newFirstname, oldFirstname) {\n                <span class=\"hljs-keyword\">this</span>.fullname = newFirstname + <span class=\"hljs-keyword\">this</span>.lastname\n            },\n            <span class=\"hljs-comment\">// 监听lastname</span>\n            lastname(newLastname, oldLastname) {\n                <span class=\"hljs-keyword\">this</span>.fullname = <span class=\"hljs-keyword\">this</span>.firstname + newLastname;\n            }\n        }\n    }).mount(<span class=\"hljs-string\">\"#demo\"</span>)\n</span></code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402180154156.png\" alt=\"image-20220402180154156\" /></p>\n<p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    Vue.createApp({\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">firstname</span>: <span class=\"hljs-string\">\'\'</span>,\n                <span class=\"hljs-attr\">lastname</span>: <span class=\"hljs-string\">\'\'</span>,\n            }\n        },\n        <span class=\"hljs-attr\">computed</span>: {\n            fullname() {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.firstname + <span class=\"hljs-keyword\">this</span>.lastname\n            }\n        }\n    }).mount(<span class=\"hljs-string\">\"#demo\"</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></div></pre>\n<p>这样不是简单得多吗？</p>\n<hr />\n<h1><a id=\"Class__Style__640\"></a>Class 和 Style 绑定</h1>\n<p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。</p>\n<h2><a id=\"_HTML_Class_644\"></a>绑定 HTML Class</h2>\n<h3><a id=\"_646\"></a>对象语法</h3>\n<p>我们可以传给 <code>:class</code> (<code>v-bind:class</code> 的简写) 一个对象，以动态地切换 class：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"{active: isActive}\"</span>&gt;</span>{{ message }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于data()中返回的 <code>isActive</code> 的值为true还是false。</p>\n<p>你可以在对象中传入更多字段来动态切换多个 class。此外，<code>:class</code> 指令也可以与普通的 <code>class</code> 共存。当有如下模板：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"{active: isActive, danger: isDanger}\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"static\"</span>&gt;</span>{{ message }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>和如下的data:</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue!\'</span>,\n        <span class=\"hljs-attr\">isActive</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">isDanger</span>: <span class=\"hljs-literal\">true</span>\n    }\n}\n</code></div></pre>\n<p>渲染的结果为:</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"active danger static\"</span>&gt;</span>Hello Vue!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>当 <code>isActive</code> 或者 <code> isDanger</code> 变化时，class列表将相应的更新。</p>\n<p>绑定的数据对象不必内联定义在模板里：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"classObject\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">classObj</span>: {\n            <span class=\"hljs-attr\">active</span>: <span class=\"hljs-literal\">true</span>,\n            <span class=\"hljs-attr\">danger</span>: <span class=\"hljs-literal\">false</span>\n        }\n    }\n}\n</code></div></pre>\n<p>渲染的结果为：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"active\"</span>&gt;</span>Hello Vue!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"{active: getActive}\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"static\"</span>&gt;</span>{{ message }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">computed: {\n    getActive() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.message.length &lt; <span class=\"hljs-number\">3</span>\n    }\n}\n</code></div></pre>\n<h3><a id=\"_721\"></a>数组语法</h3>\n<p>我们可以把一个数组传给 <code>:class</code>，以应用一个 class 列表：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[activeClass, dangerClass]\"</span>&gt;</span>Hello JavaScript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n  <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">activeClass</span>: <span class=\"hljs-string\">\'active\'</span>,\n      <span class=\"hljs-attr\">dangerClass</span>: <span class=\"hljs-string\">\'danger\'</span>\n  }\n}\n</code></div></pre>\n<p>渲染结果为：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"active danger\"</span>&gt;</span>Hello JavaScript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[{active: isActive}, dangerClass]\"</span>&gt;</span>Hello JavaScript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<h3><a id=\"_752\"></a>在组件上使用</h3>\n<p>当你在带有单个根元素的自定义组件上使用 <code>class</code> 属性时，这些 class 将被添加到该元素中。此元素上的现有 class 将不会被覆盖。</p>\n<p>例如，如果你声明了这个组件：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> app = Vue.createApp({\n    data() {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">isActive</span>: <span class=\"hljs-literal\">true</span>\n        }\n    }\n})\n\napp.component(<span class=\"hljs-string\">\'my-component\'</span>, {\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;p class=\"foo bar\"&gt;Hi!&lt;/p&gt;`</span>\n})\n\napp.mount(<span class=\"hljs-string\">\'#app\'</span>);\n</code></div></pre>\n<p>这个组件的模板自带了 <code>class</code> 属性，但是我们使用的使用再添加一些class：</p>\n<pre><code class=\"lang-\">&lt;my-component :class=&quot;{active: isActive}&quot;&gt;&lt;/my-component&gt;\n</code></pre>\n<p>那么最终将被渲染为：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"foo box active\"</span>&gt;</span>Hi!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"_788\"></a>绑定内联样式</h2>\n<h3><a id=\"_790\"></a>对象语法</h3>\n<p><code>:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{color: fontColor, fontSize: fontSize + \'px\'}\"</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">fontColor</span>: <span class=\"hljs-string\">\'red\'</span>,\n        <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">30</span>\n    }\n}\n</code></div></pre>\n<p>渲染完成后：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: red; font-size: 30px;\"</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"styleObj\"</span>&gt;</span>Good<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">styleObj</span>: {\n            <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">\'red\'</span>,\n            <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">\'30px\'</span>\n        }\n    }\n}\n</code></div></pre>\n<p>渲染的效果和上方是一致的。</p>\n<h3><a id=\"_834\"></a>数组语法</h3>\n<p><code>:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"[styleObj, styleObj2]\"</span>&gt;</span>Good Boy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">styleObj</span>: {\n            <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">\'red\'</span>,\n            <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">\'30px\'</span>\n        },\n        <span class=\"hljs-attr\">styleObj2</span>: {\n            <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">\'green\'</span>\n        }\n    }\n}\n</code></div></pre>\n<h3><a id=\"_858\"></a>多重值</h3>\n<p>可以为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"{background: [\'red\', \'green\', \'yellow\']}\"</span>&gt;</span>Good girl<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<p><mark>这样写只会渲染数组中最后一个被浏览器支持的值</mark>。在本例中，最终生效的 <code>background</code> 实际上是 <code> yellow</code> 。</p>\n<hr />\n<h1><a id=\"_874\"></a>条件渲染</h1>\n<h2><a id=\"vif_876\"></a>v-if</h2>\n<p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"show\"</span>&gt;</span>Hello Vue<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></div></pre>\n<p>也可以用 <code>v-else</code> 添加一个“else 块”：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"show\"</span>&gt;</span>Hello Vue<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>Hello JavaScript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></div></pre>\n<p>还可以添加 <code>v-else-if</code> ，和条件判断语句一致：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"type === \'A\'\"</span>&gt;</span>\n    A\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === \'B\'\"</span>&gt;</span>\n    B\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === \'C\'\"</span>&gt;</span>\n    C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n    Not A/B/C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<h3><a id=\"_template__vif__910\"></a>在 <code>&lt;template&gt;</code> 元素上使用 <code>v-if</code> 条件渲染分组</h3>\n<p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 <code>v-if</code>。<strong>最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"show\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>TitleElse<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"vshow_929\"></a>v-show</h2>\n<p>另一个用于条件性展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">\"show\"</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></div></pre>\n<p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 的原理只是简单的为标签添加 <code>display = \'none\'</code> 样式。</p>\n<p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p>\n<h2><a id=\"vif_VS_vshow_943\"></a>v-if VS v-show</h2>\n<p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。</p>\n<p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>\n<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>\n<h2><a id=\"vif__vfor__955\"></a>v-if 与 v-for 一起使用</h2>\n<p><strong>不推荐</strong>同时使用 <code>v-if</code> 和 <code>v-for</code>。当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-if</code> 具有比 <code>v-for</code> 更高的优先级。</p>\n<hr />\n<h1><a id=\"_965\"></a>列表渲染</h1>\n<h2><a id=\"_vfor__967\"></a>用 <code>v-for</code> 把一个数组映射为一组元素</h2>\n<p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 items 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in fruits\"</span>&gt;</span>水果名: {{ item.name }}, 价格: {{ item.price }}元/斤<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">fruits</span>: [\n            {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'苹果\'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">4</span>},\n            {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'橘子\'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">3</span>},\n            {<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'香蕉\'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">2</span>},\n        ]\n    }\n}\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402213950135.png\" alt=\"image-20220402213950135\" /></p>\n<p><code>v-for</code> 还支持一个可选的第二个参数，即当前项的索引。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in fruits\"</span>&gt;</span>{{ index + 1 }}、水果名: {{ item.name }}, 价格: {{ item.price }}元/斤<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402214134885.png\" alt=\"image-20220402214134885\" /></p>\n<p>也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item of items\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"_vfor__1013\"></a>在 v-for 里使用对象</h2>\n<p>你也可以用 <code>v-for</code> 来遍历一个对象的所有属性。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>个人资料<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"value in person\"</span>&gt;</span>{{ value }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">person</span>: {\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'张三\'</span>,\n            <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,\n            <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\'北京市\'</span>\n        }\n    }\n}\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402214613197.png\" alt=\"image-20220402214613197\" /></p>\n<p>同样，我们可以提供第二个参数(键名)，甚至第三个参数(索引)：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>个人资料<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(value, name, index) in person\"</span>&gt;</span>{{ index }}、{{ name }}: {{ value }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402214852779.png\" alt=\"image-20220402214852779\" /></p>\n<h2><a id=\"_1051\"></a>维护状态</h2>\n<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 <code>key</code> 属性：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- 内容 --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>\n<p>如果这个数据是从后端请求的，一般使用该数据的主键作为key。</p>\n<p><mark>注意：不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 key。请用字符串或数值类型的值。</mark></p>\n<h2><a id=\"_vfor__1069\"></a>在 v-for 里使用值的范围</h2>\n<p><code>v-for</code> 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"n in 10\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"n\"</span>&gt;</span>{{ n }}&amp;nbsp;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402215350477.png\" alt=\"image-20220402215350477\" /></p>\n<h2><a id=\"_template__vfor_1085\"></a>在 &lt;template&gt; 中使用 v-for</h2>\n<p>类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。比如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.msg\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>{{ item.msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"divider\"</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"presentation\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"vfor__vif__1100\"></a>v-for 与 v-if 一同使用</h2>\n<p>注意我们<strong>不</strong>推荐在同一元素上使用 <code>v-if</code> 和 <code>v-for</code>。当它们处于同一节点，<code>v-if</code> 的优先级比 <code>v-for</code> 更高，这意味着 <code>v-if</code> 将没有权限访问 <code>v-for</code> 里的变量：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 注意：这里是一个错误演示 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in fruits\"</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"item.show\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></div></pre>\n<p>可以把 <code>v-for</code> 移动到 <code>&lt;template&gt;</code> 标签中来修正：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in fruits\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"item.show\"</span>&gt;</span>{{ item.name }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></div></pre>\n<hr />\n<h1><a id=\"_1127\"></a>事件处理</h1>\n<h2><a id=\"_1129\"></a>监听事件</h2>\n<p>我们可以使用 <code>v-on</code> 指令 (通常缩写为 <code>@</code> 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为 <code>v-on:click=&quot;methodName&quot;</code> 或使用快捷方式 <code>@click=&quot;methodName&quot;</code></p>\n<p>例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>number: {{ number }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"addNum\"</span>&gt;</span>增加<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> Root = {\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">number</span>: <span class=\"hljs-number\">1</span>\n            }\n        }, \n        <span class=\"hljs-attr\">methods</span>: {\n            addNum() {\n                <span class=\"hljs-keyword\">this</span>.number++;\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">const</span> app = Vue.createApp(Root)\n    <span class=\"hljs-keyword\">const</span> vm = app.mount(<span class=\"hljs-string\">\'#app\'</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402222900074.png\" alt=\"image-20220402222900074\" /></p>\n<p>当然，<code>@click</code> 中可以直接写一些简单的js语句执行，而不一定是方法，但是在业务逻辑更为复杂的时候，还是需要绑定一个方法。</p>\n<h2><a id=\"_1170\"></a>内联处理器中的方法</h2>\n<p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"inline-handler\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"say(\'hi\')\"</span>&gt;</span>Say hi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"say(\'what\')\"</span>&gt;</span>Say what<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">Vue.createApp({\n  <span class=\"hljs-attr\">methods</span>: {\n    say(message) {\n      alert(message)\n    }\n  }\n}).mount(<span class=\"hljs-string\">\'#inline-handler\'</span>)\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220402223516402.png\" alt=\"image-20220402223516402\" /></p>\n<p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"say(\'hi\', $event)\"</span>&gt;</span>sayHi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// ...</span>\nmethods: {\n    say(message, event) {\n        alert(message)\n        <span class=\"hljs-built_in\">console</span>.log(event.target)\n    }\n}\n</code></div></pre>\n<h2><a id=\"_1213\"></a>多事件处理器</h2>\n<p>事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 这两个 one() 和 two() 将执行按钮点击事件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"one($event), two($event)\"</span>&gt;</span>\n  Submit\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// ...</span>\nmethods: {\n  one(event) {\n    <span class=\"hljs-comment\">// 第一个事件处理器逻辑...</span>\n  },\n  two(event) {\n   <span class=\"hljs-comment\">// 第二个事件处理器逻辑...</span>\n  }\n}\n</code></div></pre>\n<h2><a id=\"_1238\"></a>事件修饰符</h2>\n<p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>\n<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n<li><code>.passive</code></li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 阻止单击事件继续冒泡 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @<span class=\"hljs-attr\">click.stop</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 取消表单默认事件并执行指定函数 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> @<span class=\"hljs-attr\">submit.prevent</span>=<span class=\"hljs-string\">\"onSubmit\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 修饰符可以串联 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @<span class=\"hljs-attr\">click.stop.prevent</span>=<span class=\"hljs-string\">\"doThat\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 只有修饰符 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> @<span class=\"hljs-attr\">submit.prevent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> @<span class=\"hljs-attr\">click.capture</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> @<span class=\"hljs-attr\">click.self</span>=<span class=\"hljs-string\">\"doThat\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<blockquote>\n<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>@click.prevent.self</code> 会阻止<strong>元素本身及其子元素的点击的默认行为</strong>，而 <code>@click.self.prevent</code> 只会阻止对元素自身的点击的默认行为。</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 事件只会触发一次，之后不再生效 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.once</span>=<span class=\"hljs-string\">\"say(\'hi\', $event)\"</span>&gt;</span>sayHi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发，   --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 而不会等待 `onScroll` 完成，                    --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 以防止其中包含 `event.preventDefault()` 的情况  --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> @<span class=\"hljs-attr\">scroll.passive</span>=<span class=\"hljs-string\">\"onScroll\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p>\n<p><mark>注意：<strong>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用</strong>，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你<em>不想</em>阻止事件的默认行为。</mark></p>\n<h2><a id=\"_1291\"></a>按键修饰符</h2>\n<p>在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许为 <code>v-on</code> 或者 <code>@</code> 在监听键盘事件时添加按键修饰符：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 当键盘按下 `enter` 键并弹起时调用 `vm.submit()` --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.enter</span>=<span class=\"hljs-string\">\"submit\"</span> /&gt;</span>\n</code></div></pre>\n<p>也可以为键盘绑定指定的按键来作为修饰符：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 当用户y键弹起时 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> @<span class=\"hljs-attr\">keyup.y</span>=<span class=\"hljs-string\">\"say(\'hello\')\"</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 当用户PageDown键弹起时 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.page-down</span>=<span class=\"hljs-string\">\"onPageDown\"</span> /&gt;</span>\n</code></div></pre>\n<h3><a id=\"_1311\"></a>按键别名</h3>\n<p>Vue 为最常用的键提供了别名：</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code> (捕获“删除”和“退格”键)</li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<h2><a id=\"_1327\"></a>系统修饰键</h2>\n<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>\n<ul>\n<li><code>.ctrl</code></li>\n<li><code>.alt</code></li>\n<li><code>.shift</code></li>\n<li><code>.meta</code></li>\n</ul>\n<p>例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- Alt + Enter --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.alt.enter</span>=<span class=\"hljs-string\">\"clear\"</span> /&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Ctrl + Click --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> @<span class=\"hljs-attr\">click.ctrl</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<h3><a id=\"exact__1348\"></a>.exact 修饰符</h3>\n<p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.ctrl</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.ctrl.exact</span>=<span class=\"hljs-string\">\"onCtrlClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.exact</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></div></pre>\n<h3><a id=\"_1365\"></a>鼠标按钮修饰符</h3>\n<ul>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n<li><code>.middle</code></li>\n</ul>\n<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>\n<hr />\n<h1><a id=\"_1379\"></a>表单输入绑定</h1>\n<h2><a id=\"_1381\"></a>基础用法</h2>\n<p>你可以用 v-model 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>\n<p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>\n<ul>\n<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>\n<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>\n<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>\n</ul>\n<h3><a id=\"_1393\"></a>文本框</h3>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 单行文本框 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span> \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>input message: {{ msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 多行文本框 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"multiMsg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"white-space: pre-line;\"</span>&gt;</span>textarea message: {{ multiMsg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">\'\'</span>,\n        <span class=\"hljs-attr\">multiMsg</span>: <span class=\"hljs-string\">\'\'</span>\n    }\n}\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403151249796.png\" alt=\"image-20220403151249796\" /></p>\n<p>注意：插值在 textarea 中不起作用，请使用 <code>v-model</code> 来代替。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 错误 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span>&gt;</span>{{ text }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 正确 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span>\n</code></div></pre>\n<h3><a id=\"_1431\"></a>复选框</h3>\n<p>单个复选框，并且 <code>v-model</code> 绑定的是一个布尔值时，可以表示该复选框是否被选定：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checked\"</span>&gt;</span>男{{checked}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">checked</span>: <span class=\"hljs-literal\">true</span>,\n    }\n}\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403152043642.png\" alt=\"image-20220403152043642\" /></p>\n<p>多个复选框，可以绑定到同一个数组：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Jack\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"names\"</span>&gt;</span>Jack\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Mary\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"names\"</span>&gt;</span>Mary\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Bob\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"names\"</span>&gt;</span>Bob\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>checked names: {{ names }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">names</span>: []\n    }\n}\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403152255195.png\" alt=\"image-20220403152255195\" /></p>\n<h3><a id=\"_1478\"></a>单选框</h3>\n<p>单选框绑定是单选的value值：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"man\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span>&gt;</span> 男\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"woman\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span>&gt;</span> 女\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>性别: {{ picked }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">picked</span>: <span class=\"hljs-string\">\'\'</span>\n    }\n}\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403152603571.png\" alt=\"image-20220403152603571\" /></p>\n<h3><a id=\"_1506\"></a>选择框</h3>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"city\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">disabled</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"\"</span>&gt;</span>选择您的城市<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>北京<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>上海<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>广州<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>深圳<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>城市: {{ city }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">data() {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">\'\'</span>\n    }\n}\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403152956976.png\" alt=\"image-20220403152956976\" /></p>\n<p>注意：如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 <code>change</code> 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>\n<p>如果选择框添加多选属性，则会绑定为一个数组：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"city\"</span> <span class=\"hljs-attr\">multiple</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">disabled</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"\"</span>&gt;</span>select<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>B<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>C<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>D<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>selected: {{ city }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></div></pre>\n<p>结果：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403153230398.png\" alt=\"image-20220403153230398\" /></p>\n<h2><a id=\"_1552\"></a>值绑定</h2>\n<p>对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)。</p>\n<p>但是有时我们可能想把值绑定到当前活动实例的一个动态 property 上，这时可以用 <code>v-bind</code> 实现，此外，使用 <code>v-bind</code> 可以将输入值绑定到非字符串。</p>\n<h3><a id=\"_1560\"></a>复选框</h3>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"toggle\"</span> <span class=\"hljs-attr\">true-value</span>=<span class=\"hljs-string\">\"yes\"</span> <span class=\"hljs-attr\">false-value</span>=<span class=\"hljs-string\">\"no\"</span> /&gt;</span>toggle: {{ toggle }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--\n当选中时，toggle === \'yes\'\n未选中时，toggle === \'no\'\n--&gt;</span>\n</code></div></pre>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403153915628.png\" alt=\"image-20220403153915628\" /></p>\n<h3><a id=\"_1575\"></a>单选框</h3>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"pick\"</span> <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">\"a\"</span> /&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 当选中时，vm.pick === vm.a --&gt;</span>\n</code></div></pre>\n<h3><a id=\"_1584\"></a>选择框</h3>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- 内联对象字面量 --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">\"{ number: 123 }\"</span>&gt;</span>123<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!--\n	当选中时\n    typeof vm.selected // =&gt; \'object\'\n    vm.selected.number // =&gt; 123\n--&gt;</span>\n</code></div></pre>\n<h2><a id=\"_1600\"></a>修饰符</h2>\n<h3><a id=\"lazy_1602\"></a>.lazy</h3>\n<p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件之后进行同步：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 一般在输入框失去焦点或者用户回车时，触发`change`事件 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">v-model.lazy</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span> \n</code></div></pre>\n<h3><a id=\"number_1613\"></a>.number</h3>\n<p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"age\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> /&gt;</span>\n</code></div></pre>\n<p>当输入类型为 <code>text</code> 时这通常很有用。如果输入类型是 <code>number</code>，Vue 能够自动将原始字符串转换为数字，无需为 <code>v-model</code> 添加 <code>.number</code> 修饰符。如果这个值无法被 <code>parseFloat()</code> 解析，则返回原始的值。</p>\n<h3><a id=\"trim_1625\"></a>.trim</h3>\n<p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.trim</span>=<span class=\"hljs-string\">\"msg\"</span> /&gt;</span>\n</code></div></pre>\n<hr />\n<h1><a id=\"_API_1639\"></a>组合式 API</h1>\n<blockquote>\n<p><strong>Tips: 这一小节可能比较复杂，可以先学习后面内容再回来学习。</strong></p>\n</blockquote>\n<p>通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。</p>\n<p>假设我们的应用中有一个显示某个用户的仓库列表的视图。此外，我们还希望有搜索和筛选功能。实现此视图组件的代码可能如下所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">components</span>: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">user</span>: { \n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    }\n  },\n  data () {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">repositories</span>: [], <span class=\"hljs-comment\">// 1</span>\n      filters: { ... }, <span class=\"hljs-comment\">// 3</span>\n      searchQuery: <span class=\"hljs-string\">\'\'</span> <span class=\"hljs-comment\">// 2</span>\n    }\n  },\n  <span class=\"hljs-attr\">computed</span>: {\n    filteredRepositories () { ... }, <span class=\"hljs-comment\">// 3</span>\n    repositoriesMatchingSearchQuery () { ... }, <span class=\"hljs-comment\">// 2</span>\n  },\n  <span class=\"hljs-attr\">watch</span>: {\n    <span class=\"hljs-attr\">user</span>: <span class=\"hljs-string\">\'getUserRepositories\'</span> <span class=\"hljs-comment\">// 1</span>\n  },\n  <span class=\"hljs-attr\">methods</span>: {\n    getUserRepositories () {\n      <span class=\"hljs-comment\">// 使用 `this.user` 获取用户仓库</span>\n    }, <span class=\"hljs-comment\">// 1</span>\n    updateFilters () { ... }, <span class=\"hljs-comment\">// 3</span>\n  },\n  mounted () {\n    <span class=\"hljs-keyword\">this</span>.getUserRepositories() <span class=\"hljs-comment\">// 1</span>\n  }\n}\n</code></div></pre>\n<blockquote>\n<p><strong>以上处理相似业务逻辑的部分标记了相同的数值。</strong></p>\n</blockquote>\n<p>该组件有以下几个职责：</p>\n<ol>\n<li>\n<p>从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新</p>\n</li>\n<li>\n<p>使用 <code>searchQuery</code> 字符串搜索仓库</p>\n</li>\n<li>\n<p>使用 <code>filters</code> 对象筛选仓库</p>\n</li>\n</ol>\n<p>使用 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，<strong>逻辑关注点</strong>的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会<strong>导致组件难以阅读和理解</strong>。</p>\n<p>如果能够将同一个逻辑关注点相关代码收集在一起会更好。而这正是组合式 API 使我们能够做到的。</p>\n<h2><a id=\"_API__1700\"></a>组合式 API 基础</h2>\n<p>既然我们知道了<strong>为什么</strong>，我们就可以知道<strong>怎么做</strong>。为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在 Vue 组件中，我们将此位置称为 <code>setup</code> 。</p>\n<h3><a id=\"setup__1704\"></a><code>setup</code> 组件选项</h3>\n<p>新的 <code>setup</code> 选项在组件创建<strong>之前</strong>执行，一旦 <code>props</code> 被解析，就将作为组合式 API 的入口。</p>\n<blockquote>\n<p><strong>注意：在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例。<code>setup</code> 的调用发生在 <code>data</code> property、<code>computed</code> property 或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。</strong></p>\n</blockquote>\n<p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数，此外，我们将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p>\n<p>让我们把 <code>setup</code> 添加到组件中：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">components</span>: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">user</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    }\n  },\n  setup(props) {\n    <span class=\"hljs-built_in\">console</span>.log(props) <span class=\"hljs-comment\">// { user: \'\' }</span>\n\n    <span class=\"hljs-keyword\">return</span> {} <span class=\"hljs-comment\">// 这里返回的任何内容都可以用于组件的其余部分</span>\n  }\n  <span class=\"hljs-comment\">// 组件的“其余部分”</span>\n}\n</code></div></pre>\n<p>现在让我们从提取第一个逻辑关注点开始 (在原始代码段中标记为“1”)。</p>\n<blockquote>\n<p><strong>1、从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新</strong></p>\n</blockquote>\n<p>我们将从最明显的部分开始：</p>\n<ul>\n<li>仓库列表</li>\n<li>更新仓库列表的函数</li>\n<li>返回列表和函数，以便其他组件选项可以对它们进行访问</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue `setup` function</span>\n<span class=\"hljs-keyword\">import</span> { fetchUserRepositories } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/api/repositories\'</span>\n\n<span class=\"hljs-comment\">// 在我们的组件内</span>\nsetup (props) {\n  <span class=\"hljs-keyword\">let</span> repositories = []\n  <span class=\"hljs-keyword\">const</span> getUserRepositories = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    repositories = <span class=\"hljs-keyword\">await</span> fetchUserRepositories(props.user)\n  }\n\n  <span class=\"hljs-keyword\">return</span> {\n    repositories,\n    getUserRepositories <span class=\"hljs-comment\">// 返回的函数与方法的行为相同</span>\n  }\n}\n</code></div></pre>\n<p>这是我们的出发点，但它还无法生效，因为 <code>repositories</code> 变量是非响应式的。这意味着从用户的角度来看，仓库列表将始终为空。让我们来解决这个问题！</p>\n<h3><a id=\"_ref__1768\"></a>带 <code>ref</code> 的响应式变量</h3>\n<p>在 Vue 3.0 中，我们可以通过一个新的 <code>ref</code> 函数使任何响应式变量在任何地方起作用，如下所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\nsetup() {\n    <span class=\"hljs-keyword\">const</span> counter = ref(<span class=\"hljs-number\">0</span>)\n}\n</code></div></pre>\n<p><code>ref</code> 接收参数并将其包裹在一个带有 <code>value</code> property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\nsetup() {\n    <span class=\"hljs-keyword\">const</span> counter = ref(<span class=\"hljs-number\">0</span>)\n\n    <span class=\"hljs-built_in\">console</span>.log(counter) <span class=\"hljs-comment\">// { value: 0 }</span>\n    <span class=\"hljs-built_in\">console</span>.log(counter.value) <span class=\"hljs-comment\">// 0</span>\n\n    counter.value++\n    <span class=\"hljs-built_in\">console</span>.log(counter.value) <span class=\"hljs-comment\">// 1</span>\n}\n</code></div></pre>\n<p><code>ref</code> 为我们的值创建了一个<strong>响应式引用</strong>。在整个组合式 API 中会经常使用<strong>引用</strong>的概念。</p>\n<p>回到我们的例子，让我们创建一个响应式的 <code>repositories</code> 变量：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue `setup` function</span>\n<span class=\"hljs-keyword\">import</span> { fetchUserRepositories } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/api/repositories\'</span>\n<span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-comment\">// 在我们的组件中</span>\nsetup (props) {\n  <span class=\"hljs-keyword\">const</span> repositories = ref([])\n  <span class=\"hljs-keyword\">const</span> getUserRepositories = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    repositories.value = <span class=\"hljs-keyword\">await</span> fetchUserRepositories(props.user)\n  }\n\n  <span class=\"hljs-keyword\">return</span> {\n    repositories,\n    getUserRepositories\n  }\n}\n</code></div></pre>\n<p>完成！现在，每当我们调用 <code>getUserRepositories</code> 时，<code>repositories</code> 都将发生变化，视图也会更新以反映变化。我们的组件现在应该如下所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue</span>\n<span class=\"hljs-keyword\">import</span> { fetchUserRepositories } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/api/repositories\'</span>\n<span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">components</span>: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">user</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    }\n  },\n  setup (props) {\n    <span class=\"hljs-keyword\">const</span> repositories = ref([])\n    <span class=\"hljs-keyword\">const</span> getUserRepositories = <span class=\"hljs-keyword\">async</span> () =&gt; {\n      repositories.value = <span class=\"hljs-keyword\">await</span> fetchUserRepositories(props.user)\n    }\n\n    <span class=\"hljs-keyword\">return</span> {\n      repositories,\n      getUserRepositories\n    }\n  },\n  data () {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">filters</span>: { ... }, <span class=\"hljs-comment\">// 3</span>\n      searchQuery: <span class=\"hljs-string\">\'\'</span> <span class=\"hljs-comment\">// 2</span>\n    }\n  },\n  <span class=\"hljs-attr\">computed</span>: {\n    filteredRepositories () { ... }, <span class=\"hljs-comment\">// 3</span>\n    repositoriesMatchingSearchQuery () { ... }, <span class=\"hljs-comment\">// 2</span>\n  },\n  <span class=\"hljs-attr\">watch</span>: {\n    <span class=\"hljs-attr\">user</span>: <span class=\"hljs-string\">\'getUserRepositories\'</span> <span class=\"hljs-comment\">// 1</span>\n  },\n  <span class=\"hljs-attr\">methods</span>: {\n    updateFilters () { ... }, <span class=\"hljs-comment\">// 3</span>\n  },\n  mounted () {\n    <span class=\"hljs-keyword\">this</span>.getUserRepositories() <span class=\"hljs-comment\">// 1</span>\n  }\n}\n</code></div></pre>\n<p>我们已经将第一个逻辑关注点中的几个部分移到了 <code>setup</code> 方法中，它们彼此非常接近。剩下的就是在 <code>mounted</code> 钩子中调用 <code>getUserRepositories</code>，并设置一个监听器，以便在 <code>user</code> prop 发生变化时执行此操作。</p>\n<p>我们将从生命周期钩子开始。</p>\n<h3><a id=\"_setup__1873\"></a>在 <code>setup</code> <strong>内注册生命周期钩子</strong></h3>\n<p>为了使组合式 API 的功能和选项式 API 一样完整，我们还需要一种在 <code>setup</code> 中注册生命周期钩子的方法。这要归功于 Vue 导出的几个新函数。组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 <code>on</code>：即 <code>mounted</code> 看起来会像 <code>onMounted</code>。</p>\n<p>这些函数接受一个回调，当钩子被组件调用时，该回调将被执行。</p>\n<p>让我们将其添加到 <code>setup</code> 函数中：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue `setup` function</span>\n<span class=\"hljs-keyword\">import</span> { fetchUserRepositories } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/api/repositories\'</span>\n<span class=\"hljs-keyword\">import</span> { ref, onMounted } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-comment\">// 在我们的组件中</span>\nsetup (props) {\n  <span class=\"hljs-keyword\">const</span> repositories = ref([])\n  <span class=\"hljs-keyword\">const</span> getUserRepositories = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    repositories.value = <span class=\"hljs-keyword\">await</span> fetchUserRepositories(props.user)\n  }\n\n  onMounted(getUserRepositories) <span class=\"hljs-comment\">// 在 `mounted` 时调用 `getUserRepositories`</span>\n\n  <span class=\"hljs-keyword\">return</span> {\n    repositories,\n    getUserRepositories\n  }\n}\n</code></div></pre>\n<p>现在我们需要对 <code>user</code> prop 的变化做出反应。为此，我们将使用独立的 <code>watch</code> 函数。</p>\n<h3><a id=\"watch__1906\"></a><code>watch</code> 响应式更改</h3>\n<p>就像我们在组件中使用 <code>watch</code> 选项并在 <code>user</code> property 上设置侦听器一样，我们也可以使用从 Vue 导入的 <code>watch</code> 函数执行相同的操作。它接受 3 个参数：</p>\n<ul>\n<li>一个想要侦听的<strong>响应式引用</strong>或 getter 函数</li>\n<li>一个回调</li>\n<li>可选的配置选项</li>\n</ul>\n<p><strong>下面让我们快速了解一下它是如何工作的</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { ref, watch } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\nsetup() {\n    <span class=\"hljs-keyword\">const</span> counter = ref(<span class=\"hljs-number\">0</span>)\n    watch(counter, (newValue, oldValue) =&gt; {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'The new counter value is: \'</span> + counter.value)\n    })\n}\n</code></div></pre>\n<p>每当 <code>counter</code> 被修改时，例如 <code>counter.value=5</code>，侦听将触发并执行回调 (第二个参数)，在本例中，它将把 <code>\'The new counter value is:5\'</code> 记录到控制台中。</p>\n<p><strong>以下是等效的选项式 API：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  data() {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span>\n    }\n  },\n  <span class=\"hljs-attr\">watch</span>: {\n    counter(newValue, oldValue) {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'The new counter value is: \'</span> + <span class=\"hljs-keyword\">this</span>.counter)\n    }\n  }\n}\n</code></div></pre>\n<p><strong>现在我们将其应用到我们的示例中：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue `setup` function</span>\n<span class=\"hljs-keyword\">import</span> { fetchUserRepositories } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/api/repositories\'</span>\n<span class=\"hljs-keyword\">import</span> { ref, onMounted, watch, toRefs } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-comment\">// 在我们组件中</span>\nsetup (props) {\n  <span class=\"hljs-comment\">// 使用 `toRefs` 创建对 `props` 中的 `user` property 的响应式引用</span>\n  <span class=\"hljs-keyword\">const</span> { user } = toRefs(props)\n\n  <span class=\"hljs-keyword\">const</span> repositories = ref([])\n  <span class=\"hljs-keyword\">const</span> getUserRepositories = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-comment\">// 更新 `prop.user` 到 `user.value` 访问引用值</span>\n    repositories.value = <span class=\"hljs-keyword\">await</span> fetchUserRepositories(user.value)\n  }\n\n  onMounted(getUserRepositories)\n\n  <span class=\"hljs-comment\">// 在 user prop 的响应式引用上设置一个侦听器</span>\n  watch(user, getUserRepositories)\n\n  <span class=\"hljs-keyword\">return</span> {\n    repositories,\n    getUserRepositories\n  }\n}\n</code></div></pre>\n<p>你可能已经注意到在我们的 <code>setup</code> 的顶部使用了 <code>toRefs</code>。这是为了确保我们的侦听器能够根据 <code>user</code> prop 的变化做出反应。</p>\n<p>有了这些变化，我们就把第一个逻辑关注点移到了一个地方。我们现在可以对第二个关注点执行相同的操作——基于 <code>searchQuery</code> 进行过滤，这次是使用计算属性。</p>\n<h3><a id=\"_computed__1982\"></a>独立的 <code>computed</code> 属性</h3>\n<p>与 <code>ref</code> 和 <code>watch</code> 类似，也可以使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性。让我们回到 counter 的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { ref, computed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\nsetup() {\n    <span class=\"hljs-keyword\">const</span> counter = ref(<span class=\"hljs-number\">0</span>)\n    <span class=\"hljs-keyword\">const</span> twiceTheCounter = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> counter.value * <span class=\"hljs-number\">2</span>)\n\n    counter.value++\n    <span class=\"hljs-built_in\">console</span>.log(counter.value) <span class=\"hljs-comment\">// 1</span>\n    <span class=\"hljs-built_in\">console</span>.log(twiceTheCounter.value) <span class=\"hljs-comment\">// 2</span>\n    \n    <span class=\"hljs-keyword\">return</span> {\n        counter,\n        twiceTheCounter\n    }\n}\n</code></div></pre>\n<p>这里我们给 <code>computed</code> 函数传递了第一个参数，它是一个类似 getter 的回调函数，输出的是一个<em>只读</em>的<strong>响应式引用</strong>。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像 <code>ref</code> 一样使用 <code>.value</code> property。</p>\n<p>让我们将搜索功能移到 <code>setup</code> 中：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue `setup` function</span>\n<span class=\"hljs-keyword\">import</span> { fetchUserRepositories } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/api/repositories\'</span>\n<span class=\"hljs-keyword\">import</span> { ref, onMounted, watch, toRefs, computed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-comment\">// 在我们的组件中</span>\nsetup (props) {\n  <span class=\"hljs-comment\">// 使用 `toRefs` 创建对 props 中的 `user` property 的响应式引用</span>\n  <span class=\"hljs-keyword\">const</span> { user } = toRefs(props)\n\n  <span class=\"hljs-keyword\">const</span> repositories = ref([])\n  <span class=\"hljs-keyword\">const</span> getUserRepositories = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-comment\">// 更新 `props.user ` 到 `user.value` 访问引用值</span>\n    repositories.value = <span class=\"hljs-keyword\">await</span> fetchUserRepositories(user.value)\n  }\n\n  onMounted(getUserRepositories)\n\n  <span class=\"hljs-comment\">// 在 user prop 的响应式引用上设置一个侦听器</span>\n  watch(user, getUserRepositories)\n\n  <span class=\"hljs-keyword\">const</span> searchQuery = ref(<span class=\"hljs-string\">\'\'</span>)\n  <span class=\"hljs-keyword\">const</span> repositoriesMatchingSearchQuery = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> repositories.value.filter(\n      <span class=\"hljs-function\"><span class=\"hljs-params\">repository</span> =&gt;</span> repository.name.includes(searchQuery.value)\n    )\n  })\n\n  <span class=\"hljs-keyword\">return</span> {\n    repositories,\n    getUserRepositories,\n    searchQuery,\n    repositoriesMatchingSearchQuery\n  }\n}\n</code></div></pre>\n<p>对于其他的<strong>逻辑关注点</strong>我们也可以这样做，但是你可能已经在问这个问题了——<em>这不就是把代码移到 <code>setup</code> 选项并使它变得非常大吗</em>？嗯，确实是这样的。</p>\n<p>这就是为什么我们要在继续其他任务之前，我们首先要将上述代码提取到一个独立的<strong>组合式函数</strong>中。</p>\n<h3><a id=\"_2051\"></a>组合式函数</h3>\n<p>让我们从创建 <code>useUserRepositories</code> 函数开始：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/composables/useUserRepositories.js</span>\n\n<span class=\"hljs-keyword\">import</span> { fetchUserRepositories } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/api/repositories\'</span>\n<span class=\"hljs-keyword\">import</span> { ref, onMounted, watch } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUserRepositories</span>(<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> repositories = ref([])\n  <span class=\"hljs-keyword\">const</span> getUserRepositories = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    repositories.value = <span class=\"hljs-keyword\">await</span> fetchUserRepositories(user.value)\n  }\n\n  onMounted(getUserRepositories)\n  watch(user, getUserRepositories)\n\n  <span class=\"hljs-keyword\">return</span> {\n    repositories,\n    getUserRepositories\n  }\n}\n</code></div></pre>\n<p>然后是搜索功能：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/composables/useRepositoryNameSearch.js</span>\n\n<span class=\"hljs-keyword\">import</span> { ref, computed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useRepositoryNameSearch</span>(<span class=\"hljs-params\">repositories</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> searchQuery = ref(<span class=\"hljs-string\">\'\'</span>)\n  <span class=\"hljs-keyword\">const</span> repositoriesMatchingSearchQuery = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> repositories.value.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">repository</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> repository.name.includes(searchQuery.value)\n    })\n  })\n\n  <span class=\"hljs-keyword\">return</span> {\n    searchQuery,\n    repositoriesMatchingSearchQuery\n  }\n}\n</code></div></pre>\n<p><strong>现在我们有了两个单独的功能模块，接下来就可以开始在组件中使用它们了。以下是如何做到这一点：</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">// src/components/UserRepositories.vue</span>\n<span class=\"hljs-keyword\">import</span> useUserRepositories <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/composables/useUserRepositories\'</span>\n<span class=\"hljs-keyword\">import</span> useRepositoryNameSearch <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/composables/useRepositoryNameSearch\'</span>\n<span class=\"hljs-keyword\">import</span> { toRefs } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">components</span>: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList },\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">user</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    }\n  },\n  setup (props) {\n    <span class=\"hljs-keyword\">const</span> { user } = toRefs(props)\n\n    <span class=\"hljs-keyword\">const</span> { repositories, getUserRepositories } = useUserRepositories(user)\n\n    <span class=\"hljs-keyword\">const</span> {\n      searchQuery,\n      repositoriesMatchingSearchQuery\n    } = useRepositoryNameSearch(repositories)\n\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-comment\">// 因为我们并不关心未经过滤的仓库</span>\n      <span class=\"hljs-comment\">// 我们可以在 `repositories` 名称下暴露过滤后的结果</span>\n      repositories: repositoriesMatchingSearchQuery,\n      getUserRepositories,\n      searchQuery,\n    }\n  },\n  data () {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">filters</span>: { ... }, <span class=\"hljs-comment\">// 3</span>\n    }\n  },\n  <span class=\"hljs-attr\">computed</span>: {\n    filteredRepositories () { ... }, <span class=\"hljs-comment\">// 3</span>\n  },\n  <span class=\"hljs-attr\">methods</span>: {\n    updateFilters () { ... }, <span class=\"hljs-comment\">// 3</span>\n  }\n}\n</code></div></pre>\n<p>此时，你可能已经知道了其中的奥妙，其他功能也可以类似的迁移。</p>\n<hr />\n<p><strong>本章完。</strong></p>\n',1534440888750649346),(1405916999854342212,'# SpringMVC 自动配置概览\n\nSpringMVC中的大多数场景都可以自动配置，所以大多数场景都无需自动配置。\n\n- 内容协商视图解析器和BeanName视图解析器\n- 静态资源 (包括webjars)\n- 自动注册 ( `Converter`、`GenericConverter`、`Formatter` )\n- 支持 `HttpMessageConverters`\n- 静态 `index.html` 支持\n- 自定义 `Favicon`\n- 自动使用 `ConfigurableWebBindingInitializer` ，(DataBinder负责将请求数据绑定到JavaBean上)\n\n\n\n# 静态资源访问\n\nSpringBoot默认的静态资源目录有四个：\n\n- `/static`\n- `/public`\n- `resources`\n- `/META-INF/resources`\n\n这四个目录都需要创建在 `src/main/resources` 目录下，这四个目录中的静态资源，默认都可以使用当前 `项目根路径/ + 静态资源名` 直接访问。如 `http://localhost:8080/a.jpg` 。\n\n\n\n## 修改静态资源访问路径\n\n静态资源可以直接访问，其原理就是因为配置了静态资源映射 `/**` 。在这个路径下的资源会先交给控制器进行解析，如果控制器解析不了，再交给静态资源解析器解析。\n\n如果要修改用户在浏览器上访问静态资源的路径，可以：\n\n```yaml\nspring:\n  mvc:\n    static-path-pattern: /res/**\n```\n\n修改之后，就必须加上 `/res/` 的前缀才可以访问到静态资源，如 `http://localhost:8080/res/a.jpg` 。\n\n\n\n## 修改静态资源存放路径\n\n上面说了，SpringBoot默认提供的静态资源路径有4个，但是我们不想在这四个路径存放资源怎么办？其实我们也是可以修改的：\n\n```yaml\nspring:\n  web:\n    resources:\n      static-locations: [classpath:/myres/, classpath:/hello/]\n```\n\n这样修改后，四个默认的路径就无法直接访问到了，`/myres/` 和 `/hello/` 目录下的静态资源也可以被静态资源解析器解析到。\n\n\n\n## webjars\n\nwebjars是SpringBoot为我们提供的一种常用静态资源导入方式，比如 `jQuery` 、`Bootstrap` 等等。\n\n访问[webjars的官网](https://www.webjars.org/)可以找到各种静态资源，我们可以选择使用 `Maven` 的方式导入，而不用使用 `JavaScript` 的方式导入。\n\n比如jQuery的静态资源导入方式如下：\n\n```xml\n<dependency>\n    <groupId>org.webjars.npm</groupId>\n    <artifactId>jquery</artifactId>\n    <version>3.6.0</version>\n</dependency>\n```\n\n在org.webjars.npm包下的 `MATA-INF/resources` 中就有我们需要的 `jQuery` 文件，之后我们访问静态资源的路径就是 `根路径/ +  MATA-INF/resources下的包路径` ，如 `http://localhost:8080/webjars/jquery/3.6.0/dist/jquery.js`\n\n \n\n# 欢迎页和Favicon\n\n**欢迎页**\n\n存放在静态资源路径下的 `index.html` 文件，可以直接使用 `根路径/` 访问，如 `http://localhost:8080/`。\n\n但是不能修改静态资源的访问路径，否则无法自动配置。\n\n\n\n**Favicon**\n\n每个网站都有favicon，一般就是这个网站的logo，如图箭头指向的位置：\n\n![image-20220407142135795](http://img.liubaiblog.top/img/image-20220407142135795.png)\n\n在静态资源的目录下，直接存放一个以 `favicon.ico` 为名的图片文件，SpringBoot就会自动帮我们解析为favicon。\n\n但是也不能修改静态资源的访问路径，否则无法自动配置。\n\n\n\n\n\n```java\npublic WebMvcAutoConfigurationAdapter(\n    WebProperties webProperties, WebMvcProperties mvcProperties, \n    ListableBeanFactory beanFactory, \n    ObjectProvider<HttpMessageConverters> messageConvertersProvider, ObjectProvider<WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider, \n    ObjectProvider<DispatcherServletPath> dispatcherServletPath, \n    ObjectProvider<ServletRegistrationBean<?>> servletRegistrations\n) {\n    this.resourceProperties = webProperties.getResources();\n    this.mvcProperties = mvcProperties;\n    this.beanFactory = beanFactory;\n    this.messageConvertersProvider = messageConvertersProvider;\n    this.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n    this.dispatcherServletPath = dispatcherServletPath;\n    this.servletRegistrations = servletRegistrations;\n    this.mvcProperties.checkConfiguration();\n}\n```\n\n\n\n# 静态资源配置原理\n\n前面说过，SpringBoot自动配置默认会加载对于的 `XxxAutoConfiguration` 类。SpringMVC的自动配置类就是 `WebMvcAutoConfiguration` 类，配置了web场景后，这个自动配置类就会自动生效。\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})\n@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})\n@AutoConfigureOrder(-2147483638)\n@AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})\npublic class WebMvcAutoConfiguration {\n    // ...\n}\n```\n\n\n\n## 静态资源处理默认规则\n\n这个配置类中有几个内部配置类比较重要的，比如 `WebMvcAutoConfigurationAdapter` 类：\n\n`WebMvcAutoConfigurationAdapter` 类中使用了 `@EnableConfigurationProperties` 注解导入了两个配置文件类 `WebMvcProperties.class` 和 `WebProperties.class` ：\n\n```java\n@Configuration(proxyBeanMethods = false)\n@Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class})\n@EnableConfigurationProperties({WebMvcProperties.class, WebProperties.class})\n@Order(0)\npublic static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware {\n	// ...\n}\n```\n\n这两个配置文件类查看源码就可以发现其导入的是配置文件中前缀为 `spring.mvc` 和 `spring.web` 的内容：\n\n```java\n@ConfigurationProperties(prefix = \"spring.mvc\")\npublic class WebMvcProperties {\n    // ...\n}\n\n@ConfigurationProperties(\"spring.web\")\npublic class WebProperties {\n    // ...\n}\n```\n\n回到  `WebMvcAutoConfigurationAdapter` 类，这个类是只有一个有参构造器，那么IOC创建这个对象的时候，就只能调用这个有参构造，其中的参数都会从IOC容器中找，其中参数的含义大致如下：\n\n- ResourceProperties resourceProperties：获取和spring.resources绑定的所有的值的对象\n- WebMvcProperties mvcProperties：获取和spring.mvc绑定的所有的值的对象\n- ListableBeanFactory beanFactory Spring的beanFactory\n- HttpMessageConverters：找到所有的HttpMessageConverters\n- ResourceHandlerRegistrationCustomizer：找到 资源处理器的自定义器。\n- DispatcherServletPath  \n- ServletRegistrationBean   给应用注册Servlet、Filter....\n\n```java\npublic WebMvcAutoConfigurationAdapter(\n    WebProperties webProperties, \n    WebMvcProperties mvcProperties, \n    ListableBeanFactory beanFactory,\n    ObjectProvider<HttpMessageConverters> messageConvertersProvider, \n    ObjectProvider<WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider, \n    ObjectProvider<DispatcherServletPath> dispatcherServletPath, \n    ObjectProvider<ServletRegistrationBean<?>> servletRegistrations\n) {\n    this.resourceProperties = webProperties.getResources();\n    this.mvcProperties = mvcProperties;\n    this.beanFactory = beanFactory;\n    this.messageConvertersProvider = messageConvertersProvider;\n    this.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n    this.dispatcherServletPath = dispatcherServletPath;\n    this.servletRegistrations = servletRegistrations;\n    this.mvcProperties.checkConfiguration();\n}\n\n```\n\n所以经过这个有参构造，就可以把配置文件中前缀为 `spring.mvc` 和 `spring.web` 的所有数据获取到。\n\n在  `WebMvcAutoConfigurationAdapter` 类中有一个 `addResourceHandlers()` 方法，这个方法就可以对静态资源进行一些默认处理：\n\n```java\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    // 使用开启静态资源映射\n    // 如果 spring.web.resources.add-mappings=true，则不会开启默认的静态资源处理\n    if (!this.resourceProperties.isAddMappings()) {\n        logger.debug(\"Default resource handling disabled\");\n    } else {\n        // 对静态资源进行处理\n        this.addResourceHandler(registry, \"/webjars/**\", \"classpath:/META-INF/resources/webjars/\");\n        this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {\n            // this.resourceProperties.getStaticLocations() 默认就是静态资源的四个路径\n            // 如果自己指定了静态资源路径，则是自己指定的静态资源路径\n            registration.addResourceLocations(this.resourceProperties.getStaticLocations());\n            if (this.servletContext != null) {\n                ServletContextResource resource = new ServletContextResource(this.servletContext, \"/\");\n                registration.addResourceLocations(new Resource[]{resource});\n            }\n\n        });\n    }\n}\n```\n\n```java\n// 处理方法\nprivate void addResourceHandler(ResourceHandlerRegistry registry, String pattern, Consumer<ResourceHandlerRegistration> customizer) {\n    if (!registry.hasMappingForPattern(pattern)) {\n        ResourceHandlerRegistration registration = registry.addResourceHandler(new String[]{pattern});\n        customizer.accept(registration);\n        // 设置缓存的时间(秒)\n        registration.setCachePeriod(this.getSeconds(this.resourceProperties.getCache().getPeriod()));\n        registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());\n        registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());\n        this.customizeResourceHandlerRegistration(registration);\n    }\n}\n```\n\n\n\n## 欢迎页的默认规则\n\n在 `WebMvcAutoConfiguration` 下还有一个内部类 `EnableWebMvcConfiguration` 。\n\n这个内部类也获取了配置文件中以 `spring.web` 为前缀的配置，同时里面的 `welcomePageHandlerMapping()` 方法定义了欢迎页的映射方式：\n\n```java\n@EnableConfigurationProperties({WebProperties.class})\npublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {\n    // ...\n\n    @Bean	// HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。\n    public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {\n        // 新建了一个 `WelcomePageHandlerMapping` 对象\n        WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern());\n        welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n        welcomePageHandlerMapping.setCorsConfigurations(this.getCorsConfigurations());\n        return welcomePageHandlerMapping;\n    }\n    \n    // ...\n    \n}\n```\n\n```java\nfinal class WelcomePageHandlerMapping extends AbstractUrlHandlerMapping {\n	\n    // ...\n \n    WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) {\n        // 欢迎页的路径必须是 \"/**\" 下的，\n        if (welcomePage != null && \"/**\".equals(staticPathPattern)) {\n            logger.info(\"Adding welcome page: \" + welcomePage);\n            this.setRootViewName(\"forward:index.html\");\n        } else if (this.welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {\n            logger.info(\"Adding welcome page template: index\");\n            // 如果静态资源中没有 \"index.html\" 则让视图解析器解析/index\n            this.setRootViewName(\"index\");\n        }\n\n    }\n 	// ...   \n}\n```\n\n\n\n# 请求参数处理\n\n## REST\n\nSpringMVC支持REST风格的请求，REST请求之前就说过：GET 用来获取资源、POST 用来新建资源、PUT 用来更新资源、DELETE 用来删除资源。\n\n### 使用方式\n\n使用SpringBoot封装后，开启REST风格只需要在核心配置文件中配置如下内容：\n\n```yaml\nspring:\n  mvc:\n    hiddenmethod:\n      filter:\n        enabled: true\n```\n\n`properties` 文件的使用方式也是类似。开启之后，就可以正常使用REST风格的请求了。\n\n当然，这是因为网页端的页面无法独自发起 `put` 和 `delete` 请求。如果是安卓客户端，可以直接发起 `put` 和 `delete` 请求就不用配置这一项也可以。\n\n网页端的发起 `put` 和 `delete` 请求必须满足两个需求：\n\n1. 表单的默认请求方式是post。\n2. 表单的必须含有 `_method` 属性，属性值为真正的请求方式。\n\n```html\n<form action=\"/user\" method=\"post\">\n    <input type=\"hidden\" name=\"_method\" value=\"delete\">\n    <input type=\"submit\" value=\"模仿delete请求\">\n</form>\n```\n\n\n\n### REST原理\n\n找到SpringMVC的自动配置类  `WebMvcAutoConfiguration` 。其中有一个 `hiddenHttpMethodFilter()` 方法，就是自动配置请求方式过滤器的：\n\n```java\npublic class WebMvcAutoConfiguration {\n	// ...\n    \n    @Bean\n    @ConditionalOnMissingBean({HiddenHttpMethodFilter.class})\n    @ConditionalOnProperty(\n        prefix = \"spring.mvc.hiddenmethod.filter\",\n        name = {\"enabled\"}\n    )\n    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {\n        return new OrderedHiddenHttpMethodFilter();\n    }\n    \n    // ...\n}\n```\n\n可以看到必须要满足 `HiddenHttpMethodFilter` 存在和 `spring.mvc.hiddenmethod.filter.enable == true` 的时候，才会创建这个bean对象，这就解释了我们为什么必须在核心配置文件中配置开启映射。\n\n然后返回的是 `OrderedHiddenHttpMethodFilter` 过滤器，`order` 是表示排序的意思，SpringBoot还会对这些过滤器的优先级进行排序，这个我们先不管。\n\n `OrderedHiddenHttpMethodFilter` 过滤器的父类是 `HiddenHttpMethodFilter` ，这就是我们熟悉的HTTP请求过滤器。\n\n```java\npublic class OrderedHiddenHttpMethodFilter extends HiddenHttpMethodFilter implements OrderedFilter {}\n```\n\n查看 `HiddenHttpMethodFilter` 过滤器的源码，其底层使用了装饰器模式，替换了原来请求的 `post` 请求方式：\n\n```java\npublic class HiddenHttpMethodFilter extends OncePerRequestFilter {\n    private static final List<String> ALLOWED_METHODS;\n    public static final String DEFAULT_METHOD_PARAM = \"_method\";\n    private String methodParam = \"_method\";\n\n    public HiddenHttpMethodFilter() {\n    }\n\n    public void setMethodParam(String methodParam) {\n        Assert.hasText(methodParam, \"\'methodParam\' must not be empty\");\n        this.methodParam = methodParam;\n    }\n\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        // 将request对象赋值给一个临时对象requestToUse\n        HttpServletRequest requestToUse = request;\n        // 判断请求方式是否为post，并且没有抛出异常\n        if (\"POST\".equals(request.getMethod()) && request.getAttribute(\"javax.servlet.error.exception\") == null) {\n            // 获取请求携带的_method属性值，this.methodParam见上方初始化为 \"_mothod\"\n            String paramValue = request.getParameter(this.methodParam);\n            if (StringUtils.hasLength(paramValue)) {\n                // 一律将_method属性值属性值转换为英语大写\n                String method = paramValue.toUpperCase(Locale.ENGLISH);\n                // ALLOWED_METHODS是一个集合，包含PUT、DELETE、PATCH请求，判断_method属性值是否在其中\n                if (ALLOWED_METHODS.contains(method)) {\n                    // 在其中就通过包装的方式将原来的post请求替换成新的请求方式\n                    requestToUse = new HiddenHttpMethodFilter.HttpMethodRequestWrapper(request, method);\n                }\n            }\n        }\n		\n        // 交给其他过滤器时，如果if语句成功执行了，以后都是新的请求了，而原来的请求方式被替换掉了\n        filterChain.doFilter((ServletRequest)requestToUse, response);\n    }\n\n    static {\n        ALLOWED_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));\n    }\n	\n    // 这个类父类的父类就是HttpServletRequest\n    private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper {\n        private final String method;\n		\n        public HttpMethodRequestWrapper(HttpServletRequest request, String method) {\n            super(request);\n            // 将请求方式替换为新的请求方式\n            this.method = method;\n        }\n		// 重写了getMethod()方法，这样其他类调用getMethod()就是替换后的method\n        public String getMethod() {\n            return this.method;\n        }\n    }\n}\n```\n\n如果我们不满意默认提供的 `_method` 属性值中定义请求方式，我们也可以自定义表单中的哪个属性值对应请求方式。\n\n之前说过如果要修改默认的内容，有两种方式：\n\n- 修改配置文件\n- 创建一个新的bean替换SpringBoot为我们提供的bean\n\n在配置文件中，找不到一个参数满足我们的需求，所有可以采用第二种方式：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig {\n\n    @Bean\n    public HiddenHttpMethodFilter hiddenHttpMethodFilter() {\n        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();\n        // 之后浏览器发起的_new的属性值，就是真正的请求方式\n        methodFilter.setMethodParam(\"_new\");\n        return methodFilter;\n    }\n\n}\n```\n\n\n\n## 请求映射原理\n\nSpringMVC的所有请求都要先交给 `dispatcherServlet` 进行解析，这是在学习SpringBoot之前就学习过的。\n\n通过关系图可以发现，其父类其实也是 `HttpServlet` ：\n\n![image-20220407181216878](http://img.liubaiblog.top/img/image-20220407181216878.png)\n\n在最早 `JSP` 的学习阶段，我们就学习过 `HttpServlet` ，我们自定义的 `servlet` 都需要继承 `HttpServlet` ，并且根据请求实现其 `doGet()` 或 `doPost()` 或其他 `doXxx()` 方法，而 `doXxx()` 方法是通过 `service()` 方法实现调度的。\n\n`FrameworkServlet` 类中重写了各种 `doXxx()` 请求，这些请求最终调用了 `FrameworkServlet` 类的 `processRequest()` 方法，这个方法中又调用了 `doService()` 方法：\n\n```java\npublic abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware {\n    \n    // ...\n   \n    protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.processRequest(request, response);\n    }\n\n    protected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.processRequest(request, response);\n    }\n    \n    \n    protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // ...\n\n        try {\n            this.doService(request, response);\n        } catch (IOException | ServletException var16) {\n            failureCause = var16;\n            throw var16;\n        } catch (Throwable var17) {\n            failureCause = var17;\n            throw new NestedServletException(\"Request processing failed\", var17);\n        } finally {\n            this.resetContextHolders(request, previousLocaleContext, previousAttributes);\n            if (requestAttributes != null) {\n                requestAttributes.requestCompleted();\n            }\n\n            this.logResult(request, response, (Throwable)failureCause, asyncManager);\n            this.publishRequestHandledEvent(request, response, startTime, (Throwable)failureCause);\n        }\n\n    }\n    \n    protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws Exception;\n\n    // ...\n}\n```\n\n可以看到，调用的 `doService()` 方法是一个抽象方法，是需要子类实现的，而 `FrameworkServlet` 类的子类就是我们熟悉的 `DispatcherServlet` 。\n\n`DispatcherServlet` 中的 `doService()` 方法中，先是调用了一些 `setXxx()` 方法执行初始化，这些我们忽略，之后就调用了 `doDispatch()` 方法\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    // ...\n    \n    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        // ...\n\n        try {\n            this.doDispatch(request, response);\n        } finally {\n            if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() && attributesSnapshot != null) {\n                this.restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n\n            if (this.parseRequestPath) {\n                ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);\n            }\n\n        }\n\n    }\n    \n    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        boolean multipartRequestParsed = false;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            try {\n                ModelAndView mv = null;\n                Object dispatchException = null;\n\n                try {\n                    // 判断请求中是否含有文件\n                    processedRequest = this.checkMultipart(request);\n                    multipartRequestParsed = processedRequest != request;\n                    // 获取处理器，也就是我们编写的控制器方法\n                    mappedHandler = this.getHandler(processedRequest);\n                    if (mappedHandler == null) {\n                        this.noHandlerFound(processedRequest, response);\n                        return;\n                    } \n                } catch () {\n                    // ...\n                }\n\n                // ...   \n    }\n    \n    // ...\n}\n```\n\n`doDispatch()` 方法中，调用了 `getHandler()` 方法，这个方法用于获取控制器方法：\n\n```java\n@Nullable\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    if (this.handlerMappings != null) {\n        // 获取映射处理器，欢迎页中我们学习过 `WelcomePageHandlerMapping`\n        Iterator var2 = this.handlerMappings.iterator();\n		// 循环遍历映射处理器\n        while(var2.hasNext()) {\n            HandlerMapping mapping = (HandlerMapping)var2.next();\n            // 获取可以处理的控制器方法\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            // 获取完之后如果存在，返回的就是具体的某个控制器方法\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n\n    return null;\n}\n```\n\n`this.handlerMappings` 中的数据如图，其中就是几个映射处理器，而 `RequestMappingHandlerMapping` 就是我们控制器默认所在的映射处理器，欢迎页就在 `WelcomePageHandlerMapping` 中：\n\n![image-20220407183445459](http://img.liubaiblog.top/img/image-20220407183445459.png)\n\n `RequestMappingHandlerMapping -> mappingRegistry -> nameLookup ` 中，可以看到我们定义的控制器方法，在 `getHandler()` 方法中，会通过匹配，最终只会剩下一个合适的方法返回，如果有多个则会抛出异常。\n\n![image-20220407183541060](http://img.liubaiblog.top/img/image-20220407183541060.png)\n\n\n\n# 普通参数\n\n获取普通参数的方式在SpringMVC阶段基本都已经学习过，这里除了几个前面没有记过的，其他不过仅做复习，具体可见：https://www.yuque.com/u12581613/zozp7f/qu7sf2#de329c1f。\n\n## 注解\n\n- `@PathVariable` ：获取REST参数\n- `@RequestParam` ：获取用户请求参数\n- `@RequestHeader` ：获取请求体\n- `@CookieValue` ：获取指定Cookie属性值\n- `@RequestBody` ：获取请求体\n- `@ModelAttribute` ：在所有控制器方法之前执行指定方法\n- `@RequestAttribute` ：获取 `request` 域参数\n- `@MatrixVariable` ：获取矩阵变量\n- ...\n\n对于这些注解获取参数的方式，基本都已经很熟悉了，下面主要针对 `@ModelAttribute` 、`@RequestAttribute` 和 `@MatrixVariable`  注解简要说明。\n\n### `@ModelAttribute` 注解\n\n`@ModelAttribute` 注解可以放在方法或者形参的上方，被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，因此对于一个controller映射多个URL的用法来说，要谨慎使用。\n\n**作用在方法上**\n\n1、`@ModelAttribute` 标记没有返回值的方法\n\n```java\n@ModelAttribute\npublic void getUser(Model model) {\n    model.addAttribute(\"username\", \"jack\");\n}\n```\n\n2、`@ModelAttribute` 标记有返回值的方法\n\n```java\n@ModelAttribute(\"username\")\npublic String getUser(Model model) {\n    model.addAttribute(\"age\", \"12\");\n    return \"mary\";\n}\n```\n\n这些方法会在所有控制器方法之前执行，这样每次请求都会添加一次该请求参数，所以要谨慎使用，如果要多次使用到某个参数，可以直接添加到 `session` 中。\n\n**作用在形参上**\n\n```java\n@ResponseBody\n@RequestMapping(\"/success\")\npublic Object success(@ModelAttribute(\"username\") String username) {\n    Map<String, String> map = new HashMap<>(3);\n    map.put(\"username\", username);\n    return map;\n}\n```\n\n这个方法可以获取到上面标注 `@ModelAttribute`  方法中的属性值，如果 `model` 域中获取不到属性值，就会从用户传递的参数中获取，如果也没有，则会空值。\n\n\n\n### `@RequestAttribute` 注解\n\n这个注解用于获取 `request` 域中的数据：\n\n```java\n// 向请求域中添加数据\n@RequestMapping(\"/test\")\npublic String abc(Model model) {\n    model.addAttribute(\"name\", \"张三\");\n    model.addAttribute(\"age\", \"12\");\n    model.addAttribute(\"gender\", \"男\");\n    // 转发给 `success` 中处理\n    return \"forward:/success\";\n}\n\n@ResponseBody\n@RequestMapping(\"/success\")\n// 获取请求域中的数据\npublic Object success(@RequestAttribute(\"name\") String name,@RequestAttribute(\"age\") String age,@RequestAttribute(\"gender\") String gender) {\n    Map<String, String> map = new HashMap<>(3);\n    map.put(\"name\", name);\n    map.put(\"age\", age);\n    map.put(\"gender\", gender);\n    log.info(map.toString());\n    return map;\n}\n```\n\n注意：这样并不能获取到用户上传的参数，只能获取到服务端放在 `request` 域中的数据。\n\n\n\n### `@MatrixVariable` 注解\n\n这个注解用户获取矩阵变量，这个概念可能比较陌生，之前我们获取用户传递的参数都是 `/user?name=jack&hobby=sing&hobby=basketball` 的格式，但是矩阵变量则是 `/user;name=jack;hobby=sing,basketball` 。\n\n```java\n@ResponseBody\n@RequestMapping(\"/person/{user}\")\npublic Object matrix(@MatrixVariable(\"name\") String name, @MatrixVariable(\"hobby\") String[] hobby, @PathVariable(\"user\") String path) {\n    Map<String, Object> map = new HashMap<>(3);\n    map.put(\"path\", path);\n    map.put(\"name\", name);\n    map.put(\"hobby\", hobby);\n    return map;\n}\n// {\"name\":\"jack\",\"path\":\"user\",\"hobby\":[\"sing\",\"basketball\"]}\n```\n\n如果矩阵变量的属性名有重复值，比如 `/boss/b;id=10/emp/e;id=20` ，这个时候有两个 `id` ，那么我们可以根据路径来确定属性值：\n\n```java\n@ResponseBody\n@RequestMapping(\"/boss/{bossPath}/emp/{empPath}\")\npublic Object matrix2(@MatrixVariable(pathVar = \"bossPath\", value = \"id\") String bossId, @MatrixVariable(pathVar = \"empPath\", value = \"id\") String empId) {\n    Map<String, Object> map = new HashMap<>(3);\n    map.put(\"bossId\", bossId);\n    map.put(\"empId\", empId);\n    return map;\n}\n// {\"bossId\":\"10\",\"empId\":\"20\"}\n```\n\n==注意：比较低版本的SpringBoot可能没有默认不会开启这个功能，我们有两种方式配置开启==\n\n**方式一**：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void configurePathMatch(PathMatchConfigurer configurer) {\n        UrlPathHelper urlPathHelper = new UrlPathHelper();\n        // 设置不要移除 `;` 后面的值\n        urlPathHelper.setRemoveSemicolonContent(false);\n        configurer.setUrlPathHelper(urlPathHelper);\n    }\n    \n}\n```\n\n**方式二**：\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig {\n    \n    @Bean\n    public WebMvcConfigurer configurer() {\n        return new WebMvcConfigurer() {\n            @Override\n            public void configurePathMatch(PathMatchConfigurer configurer) {\n                UrlPathHelper urlPathHelper = new UrlPathHelper();\n                // 设置不要移除 `;` 后面的值\n                urlPathHelper.setRemoveSemicolonContent(false);\n                configurer.setUrlPathHelper(urlPathHelper);\n            }\n        };\n    }\n\n}\n```\n\n这两种方式的本质都是一样的，都是在容器中创建一个实现 `WebMvcConfigurer` 接口的bean对象。\n\n\n\n## Servlet API\n\n- `HttpServletRequest`\n- `HttpServletResponse`\n- `HttpSession`\n- ...\n\n\n\n## 复杂参数\n\n- `Map`\n- `Model`\n\n- ...\n\n\n\n## 参数处理原理\n\n在 `DispatcherServlet` 类的 `doDispatch()` 方法中：\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        try {\n            ModelAndView mv = null;\n            Object dispatchException = null;\n\n            try {\n                processedRequest = this.checkMultipart(request);\n                multipartRequestParsed = processedRequest != request;\n                // 获取控制器的哪个方法能够处理请求\n                mappedHandler = this.getHandler(processedRequest);\n                if (mappedHandler == null) {\n                    this.noHandlerFound(processedRequest, response);\n                    return;\n                }\n				// 处理器适配层，即为控制器方法赋值\n                HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n                String method = request.getMethod();\n                boolean isGet = HttpMethod.GET.matches(method);\n                if (isGet || HttpMethod.HEAD.matches(method)) {\n                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n                        return;\n                    }\n                }\n\n                if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                    return;\n                }\n				// 真正的执行目标方法，并返回一个ModelAndView对象\n                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n                if (asyncManager.isConcurrentHandlingStarted()) {\n                    return;\n                }\n\n                // ...\n        } catch (Exception var22) {\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);\n        } catch (Throwable var23) {\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", var23));\n        }\n\n    } finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        } else if (multipartRequestParsed) {\n            this.cleanupMultipart(processedRequest);\n        }\n\n    }\n}\n```\n\n进入 `mv = ha.handle(processedRequest, response, mappedHandler.getHandler());` 内部，其底层调用了 ``\n\n```java\nprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n    this.checkRequest(request);\n    ModelAndView mav;\n    if (this.synchronizeOnSession) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            Object mutex = WebUtils.getSessionMutex(session);\n            synchronized(mutex) {\n                // 执行目标方法\n                mav = this.invokeHandlerMethod(request, response, handlerMethod);\n            }\n        } else {\n            mav = this.invokeHandlerMethod(request, response, handlerMethod);\n        }\n    } else {\n        mav = this.invokeHandlerMethod(request, response, handlerMethod);\n    }\n    \n    // ...\n\n    return mav;\n}\n\n```\n\n`mav = this.invokeHandlerMethod(request, response, handlerMethod);` 内部会调用参数解析器和返回值解析器来解析参数和返回值：\n\n**参数解析器**\n\n![image-20220408153430902](http://img.liubaiblog.top/img/image-20220408153430902.png)\n\n**返回值解析器**\n\n![image-20220408153450432](http://img.liubaiblog.top/img/image-20220408153450432.png)\n\nSpringMVC底层会遍历这些参数解析器和返回值解析器，判断哪个参数解析器和返回值解析器能解析数据，如果匹配到合适的解析器，就会放入缓存中，方便下次调用。\n\n\n\n# 转换器\n\n我们在控制器方法中定义的形参，SpringMVC都会帮我们自动注入参数。通常前端传递的参数都是 `String` 类型，如果控制器方法的形参位置不是 `String` 类型，则需要进行类型转换。\n\nSpringMVC底层有一个 `WebDataBinder` 对象，即数据绑定器，负责将请求参数的值绑定到指定的JavaBean里面，它会利用它里面的 `Converters` 将请求数据转成指定的数据类型后，再封装到JavaBean中。\n\n`Converters` 是一个转换器集合，包含了网页中绝大多数的请求转换方式，但是有时候这些类型转换器未必能满足需求。\n\n**实体类**\n\n```java\n@Data\npublic class Person {\n    private String name;\n    private String age;\n    private String birth;\n    private Pet pet;\n}\n\n@Data\npublic class Pet {\n    private String name;\n    private String age;\n}\n```\n\n**html**\n\n```html\n<form action=\"/savePerson\" method=\"post\">\n    <h2>测试封装POJO对象</h2>\n    姓名： <input name=\"name\" value=\"张三\"/> <br/>\n    年龄： <input name=\"age\" value=\"20\"/> <br/>\n    生日： <input name=\"birth\" value=\"2020-10-01\"/> <br/>\n    宠物：<input name=\"pet\" value=\"旺财,3\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n```\n\n我们的需求是，获取到前端传递的 `Person` 对象并保存。\n\n但是问题就是，Spring肯定不知道怎么把一个 `“旺财,3”` 转换成一个 `Pet` 对象，当启动服务发起请求尝试去获取 `Person` 实体类的时候，就会抛出异常。\n\n所以我们可以自定义一个类型转换器，遇到这种问题就可以将 `String` 类型数据转换成 `Pet` 类型：\n\n```java\n// 在配置类中，添加转换器\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addFormatters(FormatterRegistry registry) {\n        // 表示把String类型数据转换为Pet对象\n        registry.addConverter(new Converter<String, Pet>() {\n            @Override\n            public Pet convert(String source) {\n                if (StringUtils.hasLength(source)) {\n                    Pet pet = new Pet();\n                    String[] split = source.split(\",\");\n                    pet.setName(split[0]);\n                    pet.setAge(split[1]);\n                    return pet;\n                }\n                return null;\n            }\n        });\n    }\n}\n```\n\n这样，如果发起请求后，是需要 `String` 转 `Pet` 类型的，都会由这个转换器处理。\n\n> **注意**：\n>\n> 这种javaBean中嵌套另一个JavaBean的方式SpringMVC也考虑到了，SpringMVC默认为我们提供的是级联赋值的方式：\n>\n> ```html\n> 宠物姓名：<input name=\"pet.name\" value=\"旺财\"/><br/>\n> 宠物年龄：<input name=\"pet.age\" value=\"3\"/><br/>\n> ```\n>\n> 这样也可以实现我们的需求，只不过使用转换器后，我们可以更加灵活的定制化我们的项目。\n\n\n\n# 内容协商\n\n每次浏览器像服务器发起请求的时候，请求头中默认都会携带 `Accept` 参数，这个参数定义了浏览器可以接受哪中类型的参数，默认值如下：\n\n```\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n```\n\n同时服务端返回数据的时候，也会有能返回的数据类型，那么服务端返回的数据类型和浏览器能够接受的类型之间，就会产生内容协商。\n\n我们可以引入不同的第三方包来丰富服务端可以返回的数据类型：\n\n```xml\n<!-- 服务端返回json数据的依赖 -->\n<!-- SpringBoot导入web环境后已经帮我们导入了这个依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-json</artifactId>\n</dependency>\n\n<!-- 服务端返回xml数据的依赖 -->\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n</dependency>\n```\n\n注意：xml 的优先级在默认情况下是比 json 高的，所以没有特别设置的情况下，浏览器会接受到 xml 类型的数据。\n\n\n\n## 开启浏览器参数方式内容协商功能\n\n浏览器默认是不能修改请求头中的 `Accept` 参数的，我们使用 `Ajax` 技术可以实现这个功能，但是如果不使用这个方式，我们应该怎么设置响应类型呢？\n\nSpringBoot为我们提供了很方便的功能，我们只需要在SpringBoot的核心配置文件中，添加如下内容即可：\n\n```yaml\nspring:\n  mvc:\n    contentnegotiation:\n      favor-parameter: true		# 开启请求参数内容协商模式\n```\n\n此时我们只要请求参数中携带 `format` 参数，参数值就是真实的响应类型，如 `http://localhost:8080/person?format=json` 。\n\n\n\n**那么其底层是怎么实现的呢？**\n\nSpringBoot为了确定客户端能够接受的媒体类型，其内部使用的是 **`contentNegotiationManager` (内容协商管理器)**，内容协商管理器会基于不同的策略，来确定客户端能接受多少哪些内容，默认是 **`HeaderContentNegotiationStrategy` (请求头协商策略)**。\n\n也就是根据请求头中的 `Accept` 字段值来确定客户端能够接受哪些内容。\n\n开启请求参数内容协商后，内容协商管理器中会增加一个 **`ParameterContentNegotiationStrategy` (参数内容协商策略)**。这就允许我们以请求参数的形式来指定获取的内容。\n\n`ParameterContentNegotiationStrategy` 类中有如下方法，就是用来从请求参数中获取浏览器接受的内容类型。\n\n```java\n@Nullable\nprotected String getMediaTypeKey(NativeWebRequest request) {\n    return request.getParameter(this.getParameterName());\n}\n```\n\n\n\n## 内容协商原理\n\n- 判断当前响应头中是否已经有确定的媒体类型。\n- 获取客户端支持接受的类型。(获取 `Accept` 请求头字段值，使用内容协商管理器，基于请求头协商或者基于参数内容协商)\n- 循环获取所有当前系统的 `MessageConverter` ，看谁支持操作控制器方法返回的对象。\n- 找到支持操作这个对象的 `converter` ，把 `converter` 支持的媒体类型统计出来。\n- 把客户端需要的媒体类型，和服务端支持的媒体类型查找出来。\n- 确定内容协商的最佳匹配的媒体类型。\n- 把支持的对象转为最佳匹配媒体类型的 `converter` ，调用它进行转化。(比如把 `Person` 对象转化为 `json` 还是转化为 `xml` )\n\n\n\n## 自定义 `MessageConverter`\n\n因为 SpringBoot 提供了内容协商的功能，所以我们可以自己创建消息转换器，而不使用默认的 `json` 格式或者 `xml` 格式。\n\n\n\n**范例**\n\n访问 `/person` 资源时，控制器方法返回一个 `Person` 对象。\n\n- 如果浏览器请求的资源是 `application/json` ，则返回 `json` 格式的数据。\n- 如果浏览器请求的资源是 `application/xml` ，则返回 `xml` 格式的数据。\n- 如果浏览器请求的资源是 `application/x-hello` ，则返回自定义格式的数据。(如 `“name: jack; age: 18”`) \n\n实现消息转换器至少需要两步，第三步根据需要选择，如果使用参数内容协商，则需要加上第三步，如果是安卓客户端，或者使用 `ajax` 则可以省略第三步。\n\n**第一步：创建内容转换器**\n\n```java\npublic class HelloMsgConverter implements HttpMessageConverter<Person> {\n    @Override\n    public boolean canRead(Class<?> clazz, MediaType mediaType) {\n        return false;\n    }\n\n    /**\n     * 是否能写，此处表示只要内容为Person对象即可写\n     */\n    @Override\n    public boolean canWrite(Class<?> clazz, MediaType mediaType) {\n        return clazz.isAssignableFrom(Person.class);\n    }\n\n    /**\n     * 此消息转换器能够支持的媒体类型列表\n     * @return\n     */\n    @Override\n    public List<MediaType> getSupportedMediaTypes() {\n        return MediaType.parseMediaTypes(\"application/x-hello\");\n    }\n\n    @Override\n    public Person read(Class<? extends Person> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {\n        return null;\n    }\n\n    /**\n     * 怎么写入给浏览器，Spring会调用这个方法将控制器方法的返回值写给浏览器\n     */\n    @Override\n    public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {\n        String data = \"name: \" + person.getName() + \"; age: \" + person.getAge();\n        outputMessage.getBody().write(data.getBytes());\n    }\n}\n```\n\n但是这个时候只是创建了消息转换器，但是没有在在容器中添加这个消息转换器，所以我们还需要在配置类中，添加这个消息转换器到容器中。\n\n**第二步：配置消息转换器**\n\n```java\n@Configuration(proxyBeanMethods = false)\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override   // 自定义消息转换器\n    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.add(new HelloMsgConverter());\n    }\n\n    @Override	// 配置消息转换器(这会覆盖原来的所有消息转换器，谨慎使用!)\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        WebMvcConfigurer.super.configureMessageConverters(converters);\n    }\n}\n```\n\n配置完这一步之后，虽然服务器支持 `application/x-hello` 消息类型的转换，但是浏览器默认没法儿发起请求此类型的消息。我们可以配置基于参数内容的策略，让浏览器可以通过 `format` 字段来指定消息类型。\n\n但是使用参数内容策略，但是参数内容中默认只能支持 `json` 和 `xml` 格式的解析，如果其他格式，就无法通过参数内容来指定。所以我们还需要在配置文件中添加如下内容。\n\n**第三步：配置文件中添加消息类型**\n\n```yaml\nspring:\n  mvc:\n    contentnegotiation:\n      favor-parameter: true\n      media-types:\n        hello: application/x-hello\n```\n\n使用 `http://localhost:8080/person?format=hello` 即可以 `application/x-hello` 的格式获取内容。\n\n\n\n除了修改配置文件这种方式，还有一种方式就是重新配置内容协商管理器。但是需要注意，这种方式会覆盖原来的内容协商管理器，所以我们必须自己重新配置上参数内容策略和请求头协商策略：\n\n```java\n@Configuration(proxyBeanMethods = false)\n// 配置类需要实现 WebMvcConfigurer 接口\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override   // 自定义消息转换器\n    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.add(new HelloMsgConverter());\n    }\n\n    @Override   // 自定义内容协商管理器\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        // 自定义基于参数协商策略\n        Map<String, MediaType> map = new ConcurrentHashMap<>();\n        map.put(\"json\", MediaType.APPLICATION_JSON);\n        map.put(\"xml\", MediaType.APPLICATION_XML);\n        map.put(\"hello\", MediaType.parseMediaType(\"application/x-hello\"));\n        ParameterContentNegotiationStrategy paramStrategy = new ParameterContentNegotiationStrategy(map);\n\n        // 默认的基于请求头协商策略也需要添加\n        HeaderContentNegotiationStrategy headerStrategy = new HeaderContentNegotiationStrategy();\n        // 向内容协商管理器添加策略，注意，这种方式会覆盖原来的所有策略\n        configurer.strategies(Arrays.asList(paramStrategy, headerStrategy));\n    }\n    \n}\n```\n\n\n\n# 视图解析和模板引擎\n\nSpringBoot 默认不支持 `JSP` ，所以我们需要引入第三方的模板引擎技术实现渲染。\n\n在不使用前后端分离的架构下，推荐使用 `thymeleaf` 作为模板引擎。\n\n\n\n## 整合 `Thymeleaf`\n\n### 基本介绍\n\n`Thymeleaf ` 是新一代 Java 模板引擎，支持 HTML 原型，以直接被浏览器打开，此时浏览器会忽略未定义的 `Thymeleaf ` 标签属性，展示 `Thymeleaf ` 模板的静态页面效果。当在应用程序中会动态地替换掉页面设置的标签属性。\n\n对于 `thymeleaf` 的使用，可以参考[官方文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#introducing-thymeleaf)，具体的如何使用，此处不做介绍。\n\n\n\n### 基本使用\n\n**引入依赖**：除了默认的 `web` 场景启动器外，我们还需要引入 `thymeleaf` 的场景启动器。\n\n```html\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n`thymeleaf` 的视图解析器默认解析的前缀是 `resources/templates` ，后缀是 `.html` 。所以需要在 `resources` 目录下创建 `templates` 目录，然后创建任何 `.html` 文件即可。\n\n**创建 `index.html` 文件**\n\n```html\n<!DOCTYPE html>\n<!-- 每个html文件都需要引入thymeleaf的名称空间 -->\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>成功</title>\n</head>\n<body>\n<p>访问域对象数据: <span th:text=\"${msg}\"></span></p>\n<p><a th:href=\"@{/target}\">跳转目标页面</a></p>\n\n</body>\n</html>\n```\n\n**创建控制器**\n\n```java\n@Controller\npublic class ThymeleafTestController {\n\n    @GetMapping(\"/index\")\n    public String success(Model model) {\n        model.addAttribute(\"msg\", \"HelloWorld\");\n        return \"index\";\n    }\n\n    @GetMapping(\"/target\")\n    public String target() {\n        return \"target\";\n    }\n}\n```\n\n控制器方法中，我们只需要返回文件名即可，文件的路径前缀和文件名后缀 `thymeleaf` 的视图解析器会自动帮我们补全。\n\n\n\n## 视图解析原理流程\n\n1. 在控制器方法处理的过程中，所有的数据都会被放在 `ModelAndViewContainer` 里面，包括数据和视图地址。\n\n2. 方法的参数如果是自定义类型对象(从请求参数中确定的)，把他重新放在 `ModelAndViewContainer` 。\n3. 任何控制器方法执行完成后返回值都会被封装为 `ModelAndView` (数据和视图地址)。\n4. 在 `DispatcherServlet` 类的 `doDispatch()` 方法内，还会调用  `processDispatcheResule()` 方法，这个方法会根据 `ModelAndView` 处理派发结果(页面如何响应)\n    -  内部调用 `render()` 进行页面渲染逻辑。\n    - 根据方法的 `String` 返回值得到 `View` 对象(定义了页面的渲染逻辑)\n    - 比如得到了 `“redirect:/main”` 最终会 `Thymeleaf` 被解析为 `RedirectView` 对象。\n    - `ContentNegotiationViewResolver ` 里面包含了所有的视图解析器，内部列用视图解析器解析得到视图对象。\n    - 视图对象调用自定义的 `render()` 方法进行页面渲染工作。\n\n\n\n# 拦截器\n\n拦截器可以对网页一些非法的请求进行拦截，比如用户未登录，拦截其进行主页。\n\n关于拦截器的具体解析和原理，在我之前的文档中已经写过，可以参考之前的[文档](https://www.yuque.com/u12581613/zozp7f/upocgs#f7ae864d)。\n\n\n\n**创建拦截器**\n\n```java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    @Override   // 在控制器方法之前执行，true表示放行，false表示拦截，对于拦截的请求我们通常进行转发或者重定向\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        HttpSession session = request.getSession();\n        Object attribute = session.getAttribute(Constant.SESSION_USER);\n        if (attribute != null) {\n            return true;\n        } else {\n            response.sendRedirect(request.getContextPath() + \"/login\");\n            return false;\n        }\n    }\n\n    @Override   // 在控制器方法之后执行\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);\n    }\n\n    @Override   // 页面完成渲染之前抛出了任何异常，都会执行此方法，若无异常，则页面完成渲染后执行此方法\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);\n    }\n}\n```\n\n**添加拦截器到Web环境**\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()) // 添加拦截器\n                .addPathPatterns(\"/**\")     // 拦截的请求\n                .excludePathPatterns(\"/\", \"/login\", \"/css/**\", \"/js/**\", \"/images/**\", \"/fonts/**\");    // 不拦截的请求\n    }\n}\n```\n\n\n\n# 文件上传\n\nSpringBoot中文件上传特别简单，在 `web` 场景启动器中已经配置了文件上传所需要的包，并且由于自动配置的特性，我们也不需要自定义文件上传解析器了。\n\n由于有之前MVC阶段的基础，所以此处简单展示一下代码：\n\n**前端页面**： \n\n```html\n<h1>文件上传演示</h1>\n<!-- 需要配置enctype属性 -->\n<form th:action=\"@{/upload}\" method=\"post\" enctype=\"multipart/form-data\">\n    <div>用户名:&nbsp;<input type=\"text\" name=\"username\" placeholder=\"请输入用户名...\"></div>\n    <!-- 如果需要选择多个文件，可以为文件输入框添加 multiple -->\n    <div>上传文件:&nbsp;<input type=\"file\" name=\"file\" multiple></div>\n    <div><input type=\"submit\" name=\"上传\"></div>\n</form>\n```\n\n**后端代码**：\n\n```java\n@Controller\n@Slf4j\npublic class FormController {\n\n    @GetMapping(\"/upload\")\n    public String uploadPage() {\n        return \"form/upload_file\";\n    }\n\n    @ResponseBody\n    @PostMapping(\"/upload\")\n    public Object upload(String username, @RequestPart(\"file\") MultipartFile file, HttpServletRequest req) throws IOException {\n        // 获取源文件后缀\n        String originalFilename = file.getOriginalFilename();\n        String suffix = null;\n        if (originalFilename != null) {\n            suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(\".\"));\n        }\n        // 文件名随机生成\n        String filename = UUID.randomUUID() + suffix;\n        // 获取服务器路径\n        String serverPath = req.getSession().getServletContext().getRealPath(File.separator + \"uploadFile\");\n        // 拼接得到文件所在的完成路径\n        File realFilePath = new File(serverPath + File.separator + filename);\n        // 如果文件夹不存在则创建\n        File serverPathDir = new File(serverPath);\n        if (!serverPathDir.exists()) serverPathDir.mkdirs();\n        // 写入到磁盘\n        file.transferTo(realFilePath);\n        \n        log.info(\"上传用户: \" + username);\n        log.info(\"realPath: \" + serverPath + File.separator + filename);\n\n        // 返回json数据\n        Map<String, String> map = new HashMap<>(2);\n        map.put(\"code\", \"200\");\n        map.put(\"msg\", \"success\");\n        return map;\n    }\n}\n```\n\nSpringBoot 的核心配置文件中，我们可以修改一些参数来改变默认的配置，文件上传的自动配置都是以 `spring.servlet.multipart` 为前缀。\n\n```yaml\nspring:\n  servlet:\n    multipart:\n      max-file-size: 10MB       # 最大文件大小\n      max-request-size: 100MB   # 单次请求最大上传的文件大小(因为可能是多文件上传)\n```\n\n文件上传的自动配置类为 `MultipartAutoConfiguration` ，读取配置文件的类为 `MultipartProperties` ，我们也可以查看其源码了解配置信息。\n\n\n\n**文件上传原理**\n\n- 在 `DispatcherServlet` 中的 `doDispatch()` 方法中，会调用 `this.checkMultipart(request);` 方法判断请求是否为文件上传请求，并获取到一个新的请求。\n- 内部会调用 `multipartResolver` 的 `isMultipart(request)` 方法判断是否为文件上传请求，主要就是判断是否含有 `multipart/form-data` 。\n- 判断新的请求和原来的请求是否相同，如果不相同则说明是文件上传请求。\n- 如果是文件上传的请求，则会调用 `RequestPartMethodArgumentResolver` 参数解析器解析控制器方法的参数，最终会把文件内容封装成一个 `MultipartFile` 。\n\n\n\n# 异常处理\n\n## SpringBoot 默认异常处理规则\n\n默认情况下，SpringBoot 提供 `/error` 处理所有错误的映射。对于机器客户端，它生成 JSON 响应，其中包含错误信息、HTTP状态码和异常的详细信息等。对于浏览器客户端，响应一个 `whiteabel` 视图，以HTML格式呈现相同的数据。\n\n![image-20220412201750407](http://img.liubaiblog.top/img/image-20220412201750407.png)\n\n我们可以在 `resources/templates` 下，创建一个 `error` 目录，其中可以存放对应各种状态码的页面：\n\n![image-20220412201818574](http://img.liubaiblog.top/img/image-20220412201818574.png)\n\n注：SpringBoot 支持状态码的模糊匹配，==`5xx.html` 表示以 `500` 开头的错误码会转发到这个页面展示，而 `404.html` 则仅表示页面404时展示的页面。==\n\n在错误页面中，我们也可以正常使用 `thymeleaf` 获取域对象中的数据：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>500</title>\n</head>\n<body>\n<h1>500</h1>\n<!-- error: 出现的错误 -->\n<p th:text=\"${error}\"></p>\n<!-- message: 错误的相关信息 -->\n<p th:text=\"${message}\"></p>\n<!-- trace: 错误的堆栈信息 -->\n<p th:text=\"${trace}\"></p>\n</body>\n</html>\n```\n\n\n\n## 自动配置原理\n\n`ErrorMvcAutoConfiguration` 类是 SpringBoot 中负责异常处理的自动配置类。\n\n容器中有一些组件：`DefaultErrorAttributes` 、`BasicErrorController` 、`DefaultErrorViewResolver` ，分别实现了异常自动配置的一些功能。\n\n- `DefaultErrorAttributes` 类配置了一些异常参数，定义了错误页面中域对象可以取到哪些数据，如上方的 `error` 、`message` 等异常信息，都是这个类帮我们自动配置的，查看这个类的源码还可以发现更多的异常参数。\n\n- `BasicErrorController` 类配置了出现错误时响应的页面，比如浏览器的白页和json数据，都是这个配置类进行的配置。其类的头部标注了 `@RequestMapping({\"${server.error.path:${error.path:/error}}\"})` 注解，所以我们可以修改 `server.error.path` 来配置错误路径。\n\n- `DefaultErrorViewResolver` 类定义如果发生错误，会以 `HTTP` 状态码作为视图页地址( `viewName` ) ，找到真正的页面。如 `4xx.html` 、`5xx.html` 。\n\n`ErrorMvcAutoConfiguration` 类的 `StaticView` 定义了白页中内容。\n\n\n\n## 自定义异常处理\n\n如果我们不想使用SpringBoot默认给我们提供的异常处理规则，我们也可以自定义异常处理的功能，Spring为我们提供了三种方式，我们可以根据情况自行选择。\n\n\n\n**方式一：使用 `@ControllerAdvice` + `@ExceptionHandler` 注解**\n\n```java\n@Slf4j\n@ControllerAdvice	// 表示这是一个控制器增强类\npublic class GlobalExceptionHandler {\n	// 表示处理空指针异常和算术异常\n    @ExceptionHandler({NullPointerException.class, ArithmeticException.class})\n    public String exceptionHandler(Exception e) {\n        log.error(\"error is \" + e);\n        return \"login\";\n    }\n}\n```\n\n这种异常处理方式底层是 `ExceptionHandlerExceptionResolver` 支持的。\n\n\n\n**方式二：使用 `@ResponseStatus` 注解**\n\n```java\n@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = \"用户人数过多\")\npublic class UserToManyException extends RuntimeException {\n\n    public UserToManyException() {\n    }\n\n    public UserToManyException(String message) {\n        super(message);\n    }\n}\n```\n\n```java\n@Controller\npublic class UserController {\n    \n    @GetMapping(\"/user\")\n    public String user() {\n        // 其他操作...\n        \n        if (users.size() > 10000) {\n            throw new UserToManyException();\n        }\n        return \"user\";\n    }\n    \n}\n```\n\n这种方式和之前的方式不同，这种方式需要定义一个异常类，异常类通过标注 `@ResponseStatus` 注解来处理异常页面，然后必须要在控制器方法中抛出这个异常。`value` 属性表示的是抛出这个异常后的响应状态码，`reason` 属性表示在浏览器中显示的异常信息是什么。\n\n\n\n**方式三：实现 `HandlerExceptionResolver` 注解**\n\n```java\n// 这种方式建议设置优先级，数值越小越优\n@Order(Ordered.HIGHEST_PRECEDENCE)\n@Component\npublic class CustomerHandlerExceptionResolver implements HandlerExceptionResolver {\n\n    @Override\n    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {\n        try {\n            // 让 tomcat 发送一个 `/error` 请求\n            response.sendError(500, \"服务器错误\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return new ModelAndView();\n    }\n}\n```\n\n实现 `HandlerExceptionResolver` 注解可以直接定义一个异常处理器，不过建议声明优先级，不然异常可能会被其他异常处理器优先处理。使用 `senError()` 方法可以让tomcat发起一个 `/error` 请求，这个请求会被 `DispatcherServlet` 解析，然后默认交给 `BasicErrorController` 解析。\n\n我们也可以使用如下的方式：\n\n```java\n@Order(Ordered.HIGHEST_PRECEDENCE)\n@Component\npublic class CustomerHandlerExceptionResolver implements HandlerExceptionResolver {\n\n    @Override\n    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {\n        if (ex instanceof ArithmeticException) {\n            ModelAndView mv = new ModelAndView();\n            mv.setViewName(\"main\");\n            return mv;\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n\n\n# Web 原生组件注入\n\n在兼容一些老Web项目的时候，如果我们想更新到SpringBoot的框架，可能会遇到一些不方便，就是项目中的 `Servlet` 、`Filter`、`Listener` 不方便注册到IOC容器中。\n\n使用SpringBoot之后，我们有两种方式将原生的Web组件注册到IOC容器中。\n\n\n\n## 方式一\n\n**使用 `@WebXxx` + `@ServletComponentScan` 注解**\n\n```java\n// 注解的value值表示这个servlet处理的路径\n@WebServlet(\"/hello/*\")\npublic class HelloServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html\");\n        resp.getWriter().write(\"<h1>Hello Servlet!</h1>\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n```\n\n```java\n@SpringBootApplication\n@ServletComponentScan(\"com.example.springbootthymeleaf\")\npublic class  SpringBootThymeleafApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootThymeleafApplication.class, args);\n    }\n\n}\n```\n\n这种方式我们需要在 `Servlet` 上方添加 `@WebServlet` 注解，并且还需要在主程序类或者配置类中添加原生组件的包扫描路径，这种方式比较方便，所以也推荐这种方式。\n\n\n\n## 方式二\n\n使用 `@WebXxx` + `@ServletComponentScan` 注解\n\n```java\npublic class HelloFilter implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        Filter.super.init(filterConfig);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"执行HelloFilter过滤器\");\n        filterChain.doFilter(servletRequest, servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n        Filter.super.destroy();\n    }\n}\n\n```\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Bean\n    public ServletRegistrationBean<HelloServlet> helloServlet() {\n        return new ServletRegistrationBean<>(new HelloServlet(), \"/hello/*\");\n    }\n\n    @Bean\n    public FilterRegistrationBean<HelloFilter> helloFilter() {\n        // 第一个参数是注册的过滤器，第二个参数可以选择拦截某个servlet下的所有路径\n        return new FilterRegistrationBean<>(new HelloFilter(), this.helloServlet());\n        // 上面方式等价于: \n        // FilterRegistrationBean<HelloFilter> registrationBean = new FilterRegistrationBean<>(new HelloFilter());\n        // registrationBean.addUrlPatterns(\"/hello/*\");\n    }\n}\n```\n\n这种方式我们只需要在配置类中使用各种注册器注册对应的原生组件即可，不需要在原来的位置添加任何代码。\n\n至于 `Listener` 的注册方式和上面基本一致，就不再进行演示。\n\n> **注意：使用原生 `servlet` 处理的路径不会被Spring的拦截器所拦截，只会被其自带的过滤器拦截。**\n\n\n\n## DispatcherServlet 自动配置\n\n在 `DispatcherServletAutoConfiguration` 类中，定义了 `DispatcherServlet` 的自动配置信息。\n\n其中定义了 `DispatcherServlet` 的属性会绑定到 `WebMvcProperties` 这个配置文件类中，这个类对应的以 `spring.mvc` 为前缀的配置路径。\n\n![image-20220413214857725](http://img.liubaiblog.top/img/image-20220413214857725.png)\n\n然后是通过 `DispatcherServletRegistrationBean` 将 `DispatcherServlet` 注册进来的。\n\n![image-20220413215148379](http://img.liubaiblog.top/img/image-20220413215148379.png)\n\n我们可以修改配置文件中 `spring.mvc.servlet.path` 为其他路径来修改 `DispatcherServlet` 的映射路径，不过我们一般不这么做。\n\n\n\n# 嵌入式 `Servlet` 容器\n\nSpringBoot 默认支持的WebServer有三种，就是 `Tomcat`、`Jetty` 和 `Undertow` 。`ServletWebServerApplicationContext ` 容器启动寻找 `ServletWebServerFactory ` 并引导创建服务器。\n\n\n\n## 切换服务器\n\n以 `jetty` 服务器为例，我们只需要在 `pom.xml` 文件中排除 `tomcat` 的 `jar` 包，并引入 `jetty` 服务器的相关 `jar` 包即可。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jetty</artifactId>\n</dependency>\n```\n\n\n\n## 定制 Servlet 容器\n\n如果需要修改服务器的配置，可以在服务器中直接修改 `server` 为前缀的配置，如修改端口：\n\n```yaml\nserver:\n  port: 8080\n```\n\n不过还有一种方式就是使用 SpringBoot 为我们提供的定制化器，特定的定制化器可以改变特定的默认规则。\n\n```java\n@Component\npublic class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {\n    @Override\n    public void customize(ConfigurableServletWebServerFactory factory) {\n        factory.setPort(8080);\n    }\n}\n```\n\n如果不想使用定制化器，最后一种方式就是自定义 `webServer` 的工厂：\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Bean\n    public ConfigurableServletWebServerFactory webServerFactory() {\n        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();\n        factory.setPort(8000);\n        return factory;\n    }\n}\n```\n\n这三种方式都可以自定义的修改 `servlet` 容器的配置，按需要选择即可。\n\n\n\n# 定制化原理\n\n## 定制化常见方式\n\n1. 修改配置文件，可以查看官网，或者查看 `xxxAutoConfiguration` 自动配置类自动注入的配置文件前缀了解。\n2. 编写自定义配置类，如 `xxxConfiguration` + `@Bean` 添加为组件，即可替换、添加容器中的默认组件。\n3. 如果要全面接管 `mvc` ，可以使用 `@EnableMVC` 注解，这个注解会让 SpringBoot 自动配置的内容全部失效，由我们自定定制。\n\n\n\n## 固定套路\n\n**导入场景依赖 `starter`** -> xxxxAutoConfiguration -> 导入 `xxx` 组件 -> 绑定 `xxxProperties` -> **绑定配置文件项**\n\n\n\n---\n\n**本章完。**\n','<h1><a id=\"SpringMVC__0\"></a>SpringMVC 自动配置概览</h1>\n<p>SpringMVC中的大多数场景都可以自动配置，所以大多数场景都无需自动配置。</p>\n<ul>\n<li>内容协商视图解析器和BeanName视图解析器</li>\n<li>静态资源 (包括webjars)</li>\n<li>自动注册 ( <code>Converter</code>、<code>GenericConverter</code>、<code>Formatter</code> )</li>\n<li>支持 <code>HttpMessageConverters</code></li>\n<li>静态 <code>index.html</code> 支持</li>\n<li>自定义 <code>Favicon</code></li>\n<li>自动使用 <code>ConfigurableWebBindingInitializer</code> ，(DataBinder负责将请求数据绑定到JavaBean上)</li>\n</ul>\n<h1><a id=\"_14\"></a>静态资源访问</h1>\n<p>SpringBoot默认的静态资源目录有四个：</p>\n<ul>\n<li><code>/static</code></li>\n<li><code>/public</code></li>\n<li><code>resources</code></li>\n<li><code>/META-INF/resources</code></li>\n</ul>\n<p>这四个目录都需要创建在 <code>src/main/resources</code> 目录下，这四个目录中的静态资源，默认都可以使用当前 <code>项目根路径/ + 静态资源名</code> 直接访问。如 <code>http://localhost:8080/a.jpg</code> 。</p>\n<h2><a id=\"_27\"></a>修改静态资源访问路径</h2>\n<p>静态资源可以直接访问，其原理就是因为配置了静态资源映射 <code>/**</code> 。在这个路径下的资源会先交给控制器进行解析，如果控制器解析不了，再交给静态资源解析器解析。</p>\n<p>如果要修改用户在浏览器上访问静态资源的路径，可以：</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">spring:</span>\n<span class=\"hljs-attr\">  mvc:</span>\n<span class=\"hljs-attr\">    static-path-pattern:</span> <span class=\"hljs-string\">/res/**</span>\n</code></div></pre>\n<p>修改之后，就必须加上 <code>/res/</code> 的前缀才可以访问到静态资源，如 <code>http://localhost:8080/res/a.jpg</code> 。</p>\n<h2><a id=\"_43\"></a>修改静态资源存放路径</h2>\n<p>上面说了，SpringBoot默认提供的静态资源路径有4个，但是我们不想在这四个路径存放资源怎么办？其实我们也是可以修改的：</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">spring:</span>\n<span class=\"hljs-attr\">  web:</span>\n<span class=\"hljs-attr\">    resources:</span>\n<span class=\"hljs-attr\">      static-locations:</span> <span class=\"hljs-string\">[classpath:/myres/,</span> <span class=\"hljs-attr\">classpath:/hello/]</span>\n</code></div></pre>\n<p>这样修改后，四个默认的路径就无法直接访问到了，<code>/myres/</code> 和 <code>/hello/</code> 目录下的静态资源也可以被静态资源解析器解析到。</p>\n<h2><a id=\"webjars_58\"></a>webjars</h2>\n<p>webjars是SpringBoot为我们提供的一种常用静态资源导入方式，比如 <code>jQuery</code> 、<code>Bootstrap</code> 等等。</p>\n<p>访问<a href=\"https://www.webjars.org/\" target=\"_blank\">webjars的官网</a>可以找到各种静态资源，我们可以选择使用 <code>Maven</code> 的方式导入，而不用使用 <code>JavaScript</code> 的方式导入。</p>\n<p>比如jQuery的静态资源导入方式如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.webjars.npm<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>jquery<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.6.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>在org.webjars.npm包下的 <code>MATA-INF/resources</code> 中就有我们需要的 <code>jQuery</code> 文件，之后我们访问静态资源的路径就是 <code>根路径/ +  MATA-INF/resources下的包路径</code> ，如 <code>http://localhost:8080/webjars/jquery/3.6.0/dist/jquery.js</code></p>\n<h1><a id=\"Favicon_78\"></a>欢迎页和Favicon</h1>\n<p><strong>欢迎页</strong></p>\n<p>存放在静态资源路径下的 <code>index.html</code> 文件，可以直接使用 <code>根路径/</code> 访问，如 <code>http://localhost:8080/</code>。</p>\n<p>但是不能修改静态资源的访问路径，否则无法自动配置。</p>\n<p><strong>Favicon</strong></p>\n<p>每个网站都有favicon，一般就是这个网站的logo，如图箭头指向的位置：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220407142135795.png\" alt=\"image-20220407142135795\" /></p>\n<p>在静态资源的目录下，直接存放一个以 <code>favicon.ico</code> 为名的图片文件，SpringBoot就会自动帮我们解析为favicon。</p>\n<p>但是也不能修改静态资源的访问路径，否则无法自动配置。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">WebMvcAutoConfigurationAdapter</span><span class=\"hljs-params\">(\n    WebProperties webProperties, WebMvcProperties mvcProperties, \n    ListableBeanFactory beanFactory, \n    ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, \n    ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, \n    ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations\n)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.resourceProperties = webProperties.getResources();\n    <span class=\"hljs-keyword\">this</span>.mvcProperties = mvcProperties;\n    <span class=\"hljs-keyword\">this</span>.beanFactory = beanFactory;\n    <span class=\"hljs-keyword\">this</span>.messageConvertersProvider = messageConvertersProvider;\n    <span class=\"hljs-keyword\">this</span>.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n    <span class=\"hljs-keyword\">this</span>.dispatcherServletPath = dispatcherServletPath;\n    <span class=\"hljs-keyword\">this</span>.servletRegistrations = servletRegistrations;\n    <span class=\"hljs-keyword\">this</span>.mvcProperties.checkConfiguration();\n}\n</code></div></pre>\n<h1><a id=\"_123\"></a>静态资源配置原理</h1>\n<p>前面说过，SpringBoot自动配置默认会加载对于的 <code>XxxAutoConfiguration</code> 类。SpringMVC的自动配置类就是 <code>WebMvcAutoConfiguration</code> 类，配置了web场景后，这个自动配置类就会自动生效。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-meta\">@ConditionalOnWebApplication</span>(type = Type.SERVLET)\n<span class=\"hljs-meta\">@ConditionalOnClass</span>({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})\n<span class=\"hljs-meta\">@ConditionalOnMissingBean</span>({WebMvcConfigurationSupport.class})\n<span class=\"hljs-meta\">@AutoConfigureOrder</span>(-<span class=\"hljs-number\">2147483638</span>)\n<span class=\"hljs-meta\">@AutoConfigureAfter</span>({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebMvcAutoConfiguration</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></div></pre>\n<h2><a id=\"_141\"></a>静态资源处理默认规则</h2>\n<p>这个配置类中有几个内部配置类比较重要的，比如 <code>WebMvcAutoConfigurationAdapter</code> 类：</p>\n<p><code>WebMvcAutoConfigurationAdapter</code> 类中使用了 <code>@EnableConfigurationProperties</code> 注解导入了两个配置文件类 <code>WebMvcProperties.class</code> 和 <code>WebProperties.class</code> ：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-meta\">@Import</span>({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class})\n<span class=\"hljs-meta\">@EnableConfigurationProperties</span>({WebMvcProperties.class, WebProperties.class})\n<span class=\"hljs-meta\">@Order</span>(<span class=\"hljs-number\">0</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebMvcAutoConfigurationAdapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span>, <span class=\"hljs-title\">ServletContextAware</span> </span>{\n	<span class=\"hljs-comment\">// ...</span>\n}\n</code></div></pre>\n<p>这两个配置文件类查看源码就可以发现其导入的是配置文件中前缀为 <code>spring.mvc</code> 和 <code>spring.web</code> 的内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ConfigurationProperties</span>(prefix = <span class=\"hljs-string\">\"spring.mvc\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebMvcProperties</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-meta\">@ConfigurationProperties</span>(<span class=\"hljs-string\">\"spring.web\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebProperties</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></div></pre>\n<p>回到  <code>WebMvcAutoConfigurationAdapter</code> 类，这个类是只有一个有参构造器，那么IOC创建这个对象的时候，就只能调用这个有参构造，其中的参数都会从IOC容器中找，其中参数的含义大致如下：</p>\n<ul>\n<li>ResourceProperties resourceProperties：获取和spring.resources绑定的所有的值的对象</li>\n<li>WebMvcProperties mvcProperties：获取和spring.mvc绑定的所有的值的对象</li>\n<li>ListableBeanFactory beanFactory Spring的beanFactory</li>\n<li>HttpMessageConverters：找到所有的HttpMessageConverters</li>\n<li>ResourceHandlerRegistrationCustomizer：找到 资源处理器的自定义器。</li>\n<li>DispatcherServletPath</li>\n<li>ServletRegistrationBean   给应用注册Servlet、Filter…</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">WebMvcAutoConfigurationAdapter</span><span class=\"hljs-params\">(\n    WebProperties webProperties, \n    WebMvcProperties mvcProperties, \n    ListableBeanFactory beanFactory,\n    ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, \n    ObjectProvider&lt;WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, \n    ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, \n    ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations\n)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.resourceProperties = webProperties.getResources();\n    <span class=\"hljs-keyword\">this</span>.mvcProperties = mvcProperties;\n    <span class=\"hljs-keyword\">this</span>.beanFactory = beanFactory;\n    <span class=\"hljs-keyword\">this</span>.messageConvertersProvider = messageConvertersProvider;\n    <span class=\"hljs-keyword\">this</span>.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();\n    <span class=\"hljs-keyword\">this</span>.dispatcherServletPath = dispatcherServletPath;\n    <span class=\"hljs-keyword\">this</span>.servletRegistrations = servletRegistrations;\n    <span class=\"hljs-keyword\">this</span>.mvcProperties.checkConfiguration();\n}\n\n</code></div></pre>\n<p>所以经过这个有参构造，就可以把配置文件中前缀为 <code>spring.mvc</code> 和 <code>spring.web</code> 的所有数据获取到。</p>\n<p>在  <code>WebMvcAutoConfigurationAdapter</code> 类中有一个 <code>addResourceHandlers()</code> 方法，这个方法就可以对静态资源进行一些默认处理：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addResourceHandlers</span><span class=\"hljs-params\">(ResourceHandlerRegistry registry)</span> </span>{\n    <span class=\"hljs-comment\">// 使用开启静态资源映射</span>\n    <span class=\"hljs-comment\">// 如果 spring.web.resources.add-mappings=true，则不会开启默认的静态资源处理</span>\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.resourceProperties.isAddMappings()) {\n        logger.debug(<span class=\"hljs-string\">\"Default resource handling disabled\"</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 对静态资源进行处理</span>\n        <span class=\"hljs-keyword\">this</span>.addResourceHandler(registry, <span class=\"hljs-string\">\"/webjars/**\"</span>, <span class=\"hljs-string\">\"classpath:/META-INF/resources/webjars/\"</span>);\n        <span class=\"hljs-keyword\">this</span>.addResourceHandler(registry, <span class=\"hljs-keyword\">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; {\n            <span class=\"hljs-comment\">// this.resourceProperties.getStaticLocations() 默认就是静态资源的四个路径</span>\n            <span class=\"hljs-comment\">// 如果自己指定了静态资源路径，则是自己指定的静态资源路径</span>\n            registration.addResourceLocations(<span class=\"hljs-keyword\">this</span>.resourceProperties.getStaticLocations());\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.servletContext != <span class=\"hljs-keyword\">null</span>) {\n                ServletContextResource resource = <span class=\"hljs-keyword\">new</span> ServletContextResource(<span class=\"hljs-keyword\">this</span>.servletContext, <span class=\"hljs-string\">\"/\"</span>);\n                registration.addResourceLocations(<span class=\"hljs-keyword\">new</span> Resource[]{resource});\n            }\n\n        });\n    }\n}\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">// 处理方法</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addResourceHandler</span><span class=\"hljs-params\">(ResourceHandlerRegistry registry, String pattern, Consumer&lt;ResourceHandlerRegistration&gt; customizer)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (!registry.hasMappingForPattern(pattern)) {\n        ResourceHandlerRegistration registration = registry.addResourceHandler(<span class=\"hljs-keyword\">new</span> String[]{pattern});\n        customizer.accept(registration);\n        <span class=\"hljs-comment\">// 设置缓存的时间(秒)</span>\n        registration.setCachePeriod(<span class=\"hljs-keyword\">this</span>.getSeconds(<span class=\"hljs-keyword\">this</span>.resourceProperties.getCache().getPeriod()));\n        registration.setCacheControl(<span class=\"hljs-keyword\">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());\n        registration.setUseLastModified(<span class=\"hljs-keyword\">this</span>.resourceProperties.getCache().isUseLastModified());\n        <span class=\"hljs-keyword\">this</span>.customizeResourceHandlerRegistration(registration);\n    }\n}\n</code></div></pre>\n<h2><a id=\"_247\"></a>欢迎页的默认规则</h2>\n<p>在 <code>WebMvcAutoConfiguration</code> 下还有一个内部类 <code>EnableWebMvcConfiguration</code> 。</p>\n<p>这个内部类也获取了配置文件中以 <code>spring.web</code> 为前缀的配置，同时里面的 <code>welcomePageHandlerMapping()</code> 方法定义了欢迎页的映射方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@EnableConfigurationProperties</span>({WebProperties.class})\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EnableWebMvcConfiguration</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">DelegatingWebMvcConfiguration</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ResourceLoaderAware</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n\n    <span class=\"hljs-meta\">@Bean</span>	<span class=\"hljs-comment\">// HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> WelcomePageHandlerMapping <span class=\"hljs-title\">welcomePageHandlerMapping</span><span class=\"hljs-params\">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>{\n        <span class=\"hljs-comment\">// 新建了一个 `WelcomePageHandlerMapping` 对象</span>\n        WelcomePageHandlerMapping welcomePageHandlerMapping = <span class=\"hljs-keyword\">new</span> WelcomePageHandlerMapping(<span class=\"hljs-keyword\">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, <span class=\"hljs-keyword\">this</span>.getWelcomePage(), <span class=\"hljs-keyword\">this</span>.mvcProperties.getStaticPathPattern());\n        welcomePageHandlerMapping.setInterceptors(<span class=\"hljs-keyword\">this</span>.getInterceptors(mvcConversionService, mvcResourceUrlProvider));\n        welcomePageHandlerMapping.setCorsConfigurations(<span class=\"hljs-keyword\">this</span>.getCorsConfigurations());\n        <span class=\"hljs-keyword\">return</span> welcomePageHandlerMapping;\n    }\n    \n    <span class=\"hljs-comment\">// ...</span>\n    \n}\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WelcomePageHandlerMapping</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractUrlHandlerMapping</span> </span>{\n	\n    <span class=\"hljs-comment\">// ...</span>\n \n    WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) {\n        <span class=\"hljs-comment\">// 欢迎页的路径必须是 \"/**\" 下的，</span>\n        <span class=\"hljs-keyword\">if</span> (welcomePage != <span class=\"hljs-keyword\">null</span> &amp;&amp; <span class=\"hljs-string\">\"/**\"</span>.equals(staticPathPattern)) {\n            logger.info(<span class=\"hljs-string\">\"Adding welcome page: \"</span> + welcomePage);\n            <span class=\"hljs-keyword\">this</span>.setRootViewName(<span class=\"hljs-string\">\"forward:index.html\"</span>);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {\n            logger.info(<span class=\"hljs-string\">\"Adding welcome page template: index\"</span>);\n            <span class=\"hljs-comment\">// 如果静态资源中没有 \"index.html\" 则让视图解析器解析/index</span>\n            <span class=\"hljs-keyword\">this</span>.setRootViewName(<span class=\"hljs-string\">\"index\"</span>);\n        }\n\n    }\n 	<span class=\"hljs-comment\">// ...   </span>\n}\n</code></div></pre>\n<h1><a id=\"_295\"></a>请求参数处理</h1>\n<h2><a id=\"REST_297\"></a>REST</h2>\n<p>SpringMVC支持REST风格的请求，REST请求之前就说过：GET 用来获取资源、POST 用来新建资源、PUT 用来更新资源、DELETE 用来删除资源。</p>\n<h3><a id=\"_301\"></a>使用方式</h3>\n<p>使用SpringBoot封装后，开启REST风格只需要在核心配置文件中配置如下内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">spring:</span>\n<span class=\"hljs-attr\">  mvc:</span>\n<span class=\"hljs-attr\">    hiddenmethod:</span>\n<span class=\"hljs-attr\">      filter:</span>\n<span class=\"hljs-attr\">        enabled:</span> <span class=\"hljs-literal\">true</span>\n</code></div></pre>\n<p><code>properties</code> 文件的使用方式也是类似。开启之后，就可以正常使用REST风格的请求了。</p>\n<p>当然，这是因为网页端的页面无法独自发起 <code>put</code> 和 <code>delete</code> 请求。如果是安卓客户端，可以直接发起 <code>put</code> 和 <code>delete</code> 请求就不用配置这一项也可以。</p>\n<p>网页端的发起 <code>put</code> 和 <code>delete</code> 请求必须满足两个需求：</p>\n<ol>\n<li>表单的默认请求方式是post。</li>\n<li>表单的必须含有 <code>_method</code> 属性，属性值为真正的请求方式。</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"/user\"</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"hidden\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"_method\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"delete\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"模仿delete请求\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></div></pre>\n<h3><a id=\"REST_331\"></a>REST原理</h3>\n<p>找到SpringMVC的自动配置类  <code>WebMvcAutoConfiguration</code> 。其中有一个 <code>hiddenHttpMethodFilter()</code> 方法，就是自动配置请求方式过滤器的：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebMvcAutoConfiguration</span> </span>{\n	<span class=\"hljs-comment\">// ...</span>\n    \n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-meta\">@ConditionalOnMissingBean</span>({HiddenHttpMethodFilter.class})\n    <span class=\"hljs-meta\">@ConditionalOnProperty</span>(\n        prefix = <span class=\"hljs-string\">\"spring.mvc.hiddenmethod.filter\"</span>,\n        name = {<span class=\"hljs-string\">\"enabled\"</span>}\n    )\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> OrderedHiddenHttpMethodFilter <span class=\"hljs-title\">hiddenHttpMethodFilter</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> OrderedHiddenHttpMethodFilter();\n    }\n    \n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></div></pre>\n<p>可以看到必须要满足 <code>HiddenHttpMethodFilter</code> 存在和 <code>spring.mvc.hiddenmethod.filter.enable == true</code> 的时候，才会创建这个bean对象，这就解释了我们为什么必须在核心配置文件中配置开启映射。</p>\n<p>然后返回的是 <code>OrderedHiddenHttpMethodFilter</code> 过滤器，<code>order</code> 是表示排序的意思，SpringBoot还会对这些过滤器的优先级进行排序，这个我们先不管。</p>\n<p><code>OrderedHiddenHttpMethodFilter</code> 过滤器的父类是 <code>HiddenHttpMethodFilter</code> ，这就是我们熟悉的HTTP请求过滤器。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderedHiddenHttpMethodFilter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HiddenHttpMethodFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">OrderedFilter</span> </span>{}\n</code></div></pre>\n<p>查看 <code>HiddenHttpMethodFilter</code> 过滤器的源码，其底层使用了装饰器模式，替换了原来请求的 <code>post</code> 请求方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HiddenHttpMethodFilter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">OncePerRequestFilter</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> List&lt;String&gt; ALLOWED_METHODS;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String DEFAULT_METHOD_PARAM = <span class=\"hljs-string\">\"_method\"</span>;\n    <span class=\"hljs-keyword\">private</span> String methodParam = <span class=\"hljs-string\">\"_method\"</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">HiddenHttpMethodFilter</span><span class=\"hljs-params\">()</span> </span>{\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setMethodParam</span><span class=\"hljs-params\">(String methodParam)</span> </span>{\n        Assert.hasText(methodParam, <span class=\"hljs-string\">\"\'methodParam\' must not be empty\"</span>);\n        <span class=\"hljs-keyword\">this</span>.methodParam = methodParam;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doFilterInternal</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>{\n        <span class=\"hljs-comment\">// 将request对象赋值给一个临时对象requestToUse</span>\n        HttpServletRequest requestToUse = request;\n        <span class=\"hljs-comment\">// 判断请求方式是否为post，并且没有抛出异常</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"POST\"</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(<span class=\"hljs-string\">\"javax.servlet.error.exception\"</span>) == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">// 获取请求携带的_method属性值，this.methodParam见上方初始化为 \"_mothod\"</span>\n            String paramValue = request.getParameter(<span class=\"hljs-keyword\">this</span>.methodParam);\n            <span class=\"hljs-keyword\">if</span> (StringUtils.hasLength(paramValue)) {\n                <span class=\"hljs-comment\">// 一律将_method属性值属性值转换为英语大写</span>\n                String method = paramValue.toUpperCase(Locale.ENGLISH);\n                <span class=\"hljs-comment\">// ALLOWED_METHODS是一个集合，包含PUT、DELETE、PATCH请求，判断_method属性值是否在其中</span>\n                <span class=\"hljs-keyword\">if</span> (ALLOWED_METHODS.contains(method)) {\n                    <span class=\"hljs-comment\">// 在其中就通过包装的方式将原来的post请求替换成新的请求方式</span>\n                    requestToUse = <span class=\"hljs-keyword\">new</span> HiddenHttpMethodFilter.HttpMethodRequestWrapper(request, method);\n                }\n            }\n        }\n		\n        <span class=\"hljs-comment\">// 交给其他过滤器时，如果if语句成功执行了，以后都是新的请求了，而原来的请求方式被替换掉了</span>\n        filterChain.doFilter((ServletRequest)requestToUse, response);\n    }\n\n    <span class=\"hljs-keyword\">static</span> {\n        ALLOWED_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));\n    }\n	\n    <span class=\"hljs-comment\">// 这个类父类的父类就是HttpServletRequest</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HttpMethodRequestWrapper</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HttpServletRequestWrapper</span> </span>{\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String method;\n		\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">HttpMethodRequestWrapper</span><span class=\"hljs-params\">(HttpServletRequest request, String method)</span> </span>{\n            <span class=\"hljs-keyword\">super</span>(request);\n            <span class=\"hljs-comment\">// 将请求方式替换为新的请求方式</span>\n            <span class=\"hljs-keyword\">this</span>.method = method;\n        }\n		<span class=\"hljs-comment\">// 重写了getMethod()方法，这样其他类调用getMethod()就是替换后的method</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getMethod</span><span class=\"hljs-params\">()</span> </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.method;\n        }\n    }\n}\n</code></div></pre>\n<p>如果我们不满意默认提供的 <code>_method</code> 属性值中定义请求方式，我们也可以自定义表单中的哪个属性值对应请求方式。</p>\n<p>之前说过如果要修改默认的内容，有两种方式：</p>\n<ul>\n<li>修改配置文件</li>\n<li>创建一个新的bean替换SpringBoot为我们提供的bean</li>\n</ul>\n<p>在配置文件中，找不到一个参数满足我们的需求，所有可以采用第二种方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> HiddenHttpMethodFilter <span class=\"hljs-title\">hiddenHttpMethodFilter</span><span class=\"hljs-params\">()</span> </span>{\n        HiddenHttpMethodFilter methodFilter = <span class=\"hljs-keyword\">new</span> HiddenHttpMethodFilter();\n        <span class=\"hljs-comment\">// 之后浏览器发起的_new的属性值，就是真正的请求方式</span>\n        methodFilter.setMethodParam(<span class=\"hljs-string\">\"_new\"</span>);\n        <span class=\"hljs-keyword\">return</span> methodFilter;\n    }\n\n}\n</code></div></pre>\n<h2><a id=\"_448\"></a>请求映射原理</h2>\n<p>SpringMVC的所有请求都要先交给 <code>dispatcherServlet</code> 进行解析，这是在学习SpringBoot之前就学习过的。</p>\n<p>通过关系图可以发现，其父类其实也是 <code>HttpServlet</code> ：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220407181216878.png\" alt=\"image-20220407181216878\" /></p>\n<p>在最早 <code>JSP</code> 的学习阶段，我们就学习过 <code>HttpServlet</code> ，我们自定义的 <code>servlet</code> 都需要继承 <code>HttpServlet</code> ，并且根据请求实现其 <code>doGet()</code> 或 <code>doPost()</code> 或其他 <code>doXxx()</code> 方法，而 <code>doXxx()</code> 方法是通过 <code>service()</code> 方法实现调度的。</p>\n<p><code>FrameworkServlet</code> 类中重写了各种 <code>doXxx()</code> 请求，这些请求最终调用了 <code>FrameworkServlet</code> 类的 <code>processRequest()</code> 方法，这个方法中又调用了 <code>doService()</code> 方法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FrameworkServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HttpServletBean</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ApplicationContextAware</span> </span>{\n    \n    <span class=\"hljs-comment\">// ...</span>\n   \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>{\n        <span class=\"hljs-keyword\">this</span>.processRequest(request, response);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>{\n        <span class=\"hljs-keyword\">this</span>.processRequest(request, response);\n    }\n    \n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">processRequest</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>{\n        <span class=\"hljs-comment\">// ...</span>\n\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">this</span>.doService(request, response);\n        } <span class=\"hljs-keyword\">catch</span> (IOException | ServletException var16) {\n            failureCause = var16;\n            <span class=\"hljs-keyword\">throw</span> var16;\n        } <span class=\"hljs-keyword\">catch</span> (Throwable var17) {\n            failureCause = var17;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NestedServletException(<span class=\"hljs-string\">\"Request processing failed\"</span>, var17);\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">this</span>.resetContextHolders(request, previousLocaleContext, previousAttributes);\n            <span class=\"hljs-keyword\">if</span> (requestAttributes != <span class=\"hljs-keyword\">null</span>) {\n                requestAttributes.requestCompleted();\n            }\n\n            <span class=\"hljs-keyword\">this</span>.logResult(request, response, (Throwable)failureCause, asyncManager);\n            <span class=\"hljs-keyword\">this</span>.publishRequestHandledEvent(request, response, startTime, (Throwable)failureCause);\n        }\n\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doService</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> Exception</span>;\n\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></div></pre>\n<p>可以看到，调用的 <code>doService()</code> 方法是一个抽象方法，是需要子类实现的，而 <code>FrameworkServlet</code> 类的子类就是我们熟悉的 <code>DispatcherServlet</code> 。</p>\n<p><code>DispatcherServlet</code> 中的 <code>doService()</code> 方法中，先是调用了一些 <code>setXxx()</code> 方法执行初始化，这些我们忽略，之后就调用了 <code>doDispatch()</code> 方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DispatcherServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FrameworkServlet</span> </span>{\n    <span class=\"hljs-comment\">// ...</span>\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doService</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        <span class=\"hljs-comment\">// ...</span>\n\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">this</span>.doDispatch(request, response);\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.parseRequestPath) {\n                ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);\n            }\n\n        }\n\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doDispatch</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">boolean</span> multipartRequestParsed = <span class=\"hljs-keyword\">false</span>;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">try</span> {\n                ModelAndView mv = <span class=\"hljs-keyword\">null</span>;\n                Object dispatchException = <span class=\"hljs-keyword\">null</span>;\n\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-comment\">// 判断请求中是否含有文件</span>\n                    processedRequest = <span class=\"hljs-keyword\">this</span>.checkMultipart(request);\n                    multipartRequestParsed = processedRequest != request;\n                    <span class=\"hljs-comment\">// 获取处理器，也就是我们编写的控制器方法</span>\n                    mappedHandler = <span class=\"hljs-keyword\">this</span>.getHandler(processedRequest);\n                    <span class=\"hljs-keyword\">if</span> (mappedHandler == <span class=\"hljs-keyword\">null</span>) {\n                        <span class=\"hljs-keyword\">this</span>.noHandlerFound(processedRequest, response);\n                        <span class=\"hljs-keyword\">return</span>;\n                    } \n                } <span class=\"hljs-keyword\">catch</span> () {\n                    <span class=\"hljs-comment\">// ...</span>\n                }\n\n                <span class=\"hljs-comment\">// ...   </span>\n    }\n    \n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></div></pre>\n<p><code>doDispatch()</code> 方法中，调用了 <code>getHandler()</code> 方法，这个方法用于获取控制器方法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Nullable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> HandlerExecutionChain <span class=\"hljs-title\">getHandler</span><span class=\"hljs-params\">(HttpServletRequest request)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.handlerMappings != <span class=\"hljs-keyword\">null</span>) {\n        <span class=\"hljs-comment\">// 获取映射处理器，欢迎页中我们学习过 `WelcomePageHandlerMapping`</span>\n        Iterator var2 = <span class=\"hljs-keyword\">this</span>.handlerMappings.iterator();\n		<span class=\"hljs-comment\">// 循环遍历映射处理器</span>\n        <span class=\"hljs-keyword\">while</span>(var2.hasNext()) {\n            HandlerMapping mapping = (HandlerMapping)var2.next();\n            <span class=\"hljs-comment\">// 获取可以处理的控制器方法</span>\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            <span class=\"hljs-comment\">// 获取完之后如果存在，返回的就是具体的某个控制器方法</span>\n            <span class=\"hljs-keyword\">if</span> (handler != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> handler;\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n}\n</code></div></pre>\n<p><code>this.handlerMappings</code> 中的数据如图，其中就是几个映射处理器，而 <code>RequestMappingHandlerMapping</code> 就是我们控制器默认所在的映射处理器，欢迎页就在 <code>WelcomePageHandlerMapping</code> 中：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220407183445459.png\" alt=\"image-20220407183445459\" /></p>\n<p><code>RequestMappingHandlerMapping -&gt; mappingRegistry -&gt; nameLookup </code> 中，可以看到我们定义的控制器方法，在 <code>getHandler()</code> 方法中，会通过匹配，最终只会剩下一个合适的方法返回，如果有多个则会抛出异常。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220407183541060.png\" alt=\"image-20220407183541060\" /></p>\n<h1><a id=\"_595\"></a>普通参数</h1>\n<p>获取普通参数的方式在SpringMVC阶段基本都已经学习过，这里除了几个前面没有记过的，其他不过仅做复习，具体可见：https://www.yuque.com/u12581613/zozp7f/qu7sf2#de329c1f。</p>\n<h2><a id=\"_599\"></a>注解</h2>\n<ul>\n<li><code>@PathVariable</code> ：获取REST参数</li>\n<li><code>@RequestParam</code> ：获取用户请求参数</li>\n<li><code>@RequestHeader</code> ：获取请求体</li>\n<li><code>@CookieValue</code> ：获取指定Cookie属性值</li>\n<li><code>@RequestBody</code> ：获取请求体</li>\n<li><code>@ModelAttribute</code> ：在所有控制器方法之前执行指定方法</li>\n<li><code>@RequestAttribute</code> ：获取 <code>request</code> 域参数</li>\n<li><code>@MatrixVariable</code> ：获取矩阵变量</li>\n<li>…</li>\n</ul>\n<p>对于这些注解获取参数的方式，基本都已经很熟悉了，下面主要针对 <code>@ModelAttribute</code> 、<code>@RequestAttribute</code> 和 <code>@MatrixVariable</code>  注解简要说明。</p>\n<h3><a id=\"ModelAttribute__613\"></a><code>@ModelAttribute</code> 注解</h3>\n<p><code>@ModelAttribute</code> 注解可以放在方法或者形参的上方，被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，因此对于一个controller映射多个URL的用法来说，要谨慎使用。</p>\n<p><strong>作用在方法上</strong></p>\n<p>1、<code>@ModelAttribute</code> 标记没有返回值的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ModelAttribute</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(Model model)</span> </span>{\n    model.addAttribute(<span class=\"hljs-string\">\"username\"</span>, <span class=\"hljs-string\">\"jack\"</span>);\n}\n</code></div></pre>\n<p>2、<code>@ModelAttribute</code> 标记有返回值的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ModelAttribute</span>(<span class=\"hljs-string\">\"username\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getUser</span><span class=\"hljs-params\">(Model model)</span> </span>{\n    model.addAttribute(<span class=\"hljs-string\">\"age\"</span>, <span class=\"hljs-string\">\"12\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"mary\"</span>;\n}\n</code></div></pre>\n<p>这些方法会在所有控制器方法之前执行，这样每次请求都会添加一次该请求参数，所以要谨慎使用，如果要多次使用到某个参数，可以直接添加到 <code>session</code> 中。</p>\n<p><strong>作用在形参上</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ResponseBody</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/success\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">success</span><span class=\"hljs-params\">(@ModelAttribute(<span class=\"hljs-string\">\"username\"</span>)</span> String username) </span>{\n    Map&lt;String, String&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;(<span class=\"hljs-number\">3</span>);\n    map.put(<span class=\"hljs-string\">\"username\"</span>, username);\n    <span class=\"hljs-keyword\">return</span> map;\n}\n</code></div></pre>\n<p>这个方法可以获取到上面标注 <code>@ModelAttribute</code>  方法中的属性值，如果 <code>model</code> 域中获取不到属性值，就会从用户传递的参数中获取，如果也没有，则会空值。</p>\n<h3><a id=\"RequestAttribute__656\"></a><code>@RequestAttribute</code> 注解</h3>\n<p>这个注解用于获取 <code>request</code> 域中的数据：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">// 向请求域中添加数据</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/test\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">abc</span><span class=\"hljs-params\">(Model model)</span> </span>{\n    model.addAttribute(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"张三\"</span>);\n    model.addAttribute(<span class=\"hljs-string\">\"age\"</span>, <span class=\"hljs-string\">\"12\"</span>);\n    model.addAttribute(<span class=\"hljs-string\">\"gender\"</span>, <span class=\"hljs-string\">\"男\"</span>);\n    <span class=\"hljs-comment\">// 转发给 `success` 中处理</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"forward:/success\"</span>;\n}\n\n<span class=\"hljs-meta\">@ResponseBody</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/success\"</span>)\n<span class=\"hljs-comment\">// 获取请求域中的数据</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">success</span><span class=\"hljs-params\">(@RequestAttribute(<span class=\"hljs-string\">\"name\"</span>)</span> String name,@<span class=\"hljs-title\">RequestAttribute</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"age\"</span>)</span> String age,@<span class=\"hljs-title\">RequestAttribute</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"gender\"</span>)</span> String gender) </span>{\n    Map&lt;String, String&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;(<span class=\"hljs-number\">3</span>);\n    map.put(<span class=\"hljs-string\">\"name\"</span>, name);\n    map.put(<span class=\"hljs-string\">\"age\"</span>, age);\n    map.put(<span class=\"hljs-string\">\"gender\"</span>, gender);\n    log.info(map.toString());\n    <span class=\"hljs-keyword\">return</span> map;\n}\n</code></div></pre>\n<p>注意：这样并不能获取到用户上传的参数，只能获取到服务端放在 <code>request</code> 域中的数据。</p>\n<h3><a id=\"MatrixVariable__688\"></a><code>@MatrixVariable</code> 注解</h3>\n<p>这个注解用户获取矩阵变量，这个概念可能比较陌生，之前我们获取用户传递的参数都是 <code>/user?name=jack&amp;hobby=sing&amp;hobby=basketball</code> 的格式，但是矩阵变量则是 <code>/user;name=jack;hobby=sing,basketball</code> 。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ResponseBody</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/person/{user}\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">matrix</span><span class=\"hljs-params\">(@MatrixVariable(<span class=\"hljs-string\">\"name\"</span>)</span> String name, @<span class=\"hljs-title\">MatrixVariable</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"hobby\"</span>)</span> String[] hobby, @<span class=\"hljs-title\">PathVariable</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"user\"</span>)</span> String path) </span>{\n    Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;(<span class=\"hljs-number\">3</span>);\n    map.put(<span class=\"hljs-string\">\"path\"</span>, path);\n    map.put(<span class=\"hljs-string\">\"name\"</span>, name);\n    map.put(<span class=\"hljs-string\">\"hobby\"</span>, hobby);\n    <span class=\"hljs-keyword\">return</span> map;\n}\n<span class=\"hljs-comment\">// {\"name\":\"jack\",\"path\":\"user\",\"hobby\":[\"sing\",\"basketball\"]}</span>\n</code></div></pre>\n<p>如果矩阵变量的属性名有重复值，比如 <code>/boss/b;id=10/emp/e;id=20</code> ，这个时候有两个 <code>id</code> ，那么我们可以根据路径来确定属性值：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ResponseBody</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"/boss/{bossPath}/emp/{empPath}\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">matrix2</span><span class=\"hljs-params\">(@MatrixVariable(pathVar = <span class=\"hljs-string\">\"bossPath\"</span>, value = <span class=\"hljs-string\">\"id\"</span>)</span> String bossId, @<span class=\"hljs-title\">MatrixVariable</span><span class=\"hljs-params\">(pathVar = <span class=\"hljs-string\">\"empPath\"</span>, value = <span class=\"hljs-string\">\"id\"</span>)</span> String empId) </span>{\n    Map&lt;String, Object&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;(<span class=\"hljs-number\">3</span>);\n    map.put(<span class=\"hljs-string\">\"bossId\"</span>, bossId);\n    map.put(<span class=\"hljs-string\">\"empId\"</span>, empId);\n    <span class=\"hljs-keyword\">return</span> map;\n}\n<span class=\"hljs-comment\">// {\"bossId\":\"10\",\"empId\":\"20\"}</span>\n</code></div></pre>\n<p><mark>注意：比较低版本的SpringBoot可能没有默认不会开启这个功能，我们有两种方式配置开启</mark></p>\n<p><strong>方式一</strong>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configurePathMatch</span><span class=\"hljs-params\">(PathMatchConfigurer configurer)</span> </span>{\n        UrlPathHelper urlPathHelper = <span class=\"hljs-keyword\">new</span> UrlPathHelper();\n        <span class=\"hljs-comment\">// 设置不要移除 `;` 后面的值</span>\n        urlPathHelper.setRemoveSemicolonContent(<span class=\"hljs-keyword\">false</span>);\n        configurer.setUrlPathHelper(urlPathHelper);\n    }\n    \n}\n</code></div></pre>\n<p><strong>方式二</strong>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> </span>{\n    \n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> WebMvcConfigurer <span class=\"hljs-title\">configurer</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> WebMvcConfigurer() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configurePathMatch</span><span class=\"hljs-params\">(PathMatchConfigurer configurer)</span> </span>{\n                UrlPathHelper urlPathHelper = <span class=\"hljs-keyword\">new</span> UrlPathHelper();\n                <span class=\"hljs-comment\">// 设置不要移除 `;` 后面的值</span>\n                urlPathHelper.setRemoveSemicolonContent(<span class=\"hljs-keyword\">false</span>);\n                configurer.setUrlPathHelper(urlPathHelper);\n            }\n        };\n    }\n\n}\n</code></div></pre>\n<p>这两种方式的本质都是一样的，都是在容器中创建一个实现 <code>WebMvcConfigurer</code> 接口的bean对象。</p>\n<h2><a id=\"Servlet_API_764\"></a>Servlet API</h2>\n<ul>\n<li><code>HttpServletRequest</code></li>\n<li><code>HttpServletResponse</code></li>\n<li><code>HttpSession</code></li>\n<li>…</li>\n</ul>\n<h2><a id=\"_773\"></a>复杂参数</h2>\n<ul>\n<li>\n<p><code>Map</code></p>\n</li>\n<li>\n<p><code>Model</code></p>\n</li>\n<li>\n<p>…</p>\n</li>\n</ul>\n<h2><a id=\"_782\"></a>参数处理原理</h2>\n<p>在 <code>DispatcherServlet</code> 类的 <code>doDispatch()</code> 方法中：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doDispatch</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">boolean</span> multipartRequestParsed = <span class=\"hljs-keyword\">false</span>;\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">try</span> {\n            ModelAndView mv = <span class=\"hljs-keyword\">null</span>;\n            Object dispatchException = <span class=\"hljs-keyword\">null</span>;\n\n            <span class=\"hljs-keyword\">try</span> {\n                processedRequest = <span class=\"hljs-keyword\">this</span>.checkMultipart(request);\n                multipartRequestParsed = processedRequest != request;\n                <span class=\"hljs-comment\">// 获取控制器的哪个方法能够处理请求</span>\n                mappedHandler = <span class=\"hljs-keyword\">this</span>.getHandler(processedRequest);\n                <span class=\"hljs-keyword\">if</span> (mappedHandler == <span class=\"hljs-keyword\">null</span>) {\n                    <span class=\"hljs-keyword\">this</span>.noHandlerFound(processedRequest, response);\n                    <span class=\"hljs-keyword\">return</span>;\n                }\n				<span class=\"hljs-comment\">// 处理器适配层，即为控制器方法赋值</span>\n                HandlerAdapter ha = <span class=\"hljs-keyword\">this</span>.getHandlerAdapter(mappedHandler.getHandler());\n                String method = request.getMethod();\n                <span class=\"hljs-keyword\">boolean</span> isGet = HttpMethod.GET.matches(method);\n                <span class=\"hljs-keyword\">if</span> (isGet || HttpMethod.HEAD.matches(method)) {\n                    <span class=\"hljs-keyword\">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                    <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-keyword\">new</span> ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) {\n                        <span class=\"hljs-keyword\">return</span>;\n                    }\n                }\n\n                <span class=\"hljs-keyword\">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                    <span class=\"hljs-keyword\">return</span>;\n                }\n				<span class=\"hljs-comment\">// 真正的执行目标方法，并返回一个ModelAndView对象</span>\n                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n                <span class=\"hljs-keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) {\n                    <span class=\"hljs-keyword\">return</span>;\n                }\n\n                <span class=\"hljs-comment\">// ...</span>\n        } <span class=\"hljs-keyword\">catch</span> (Exception var22) {\n            <span class=\"hljs-keyword\">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);\n        } <span class=\"hljs-keyword\">catch</span> (Throwable var23) {\n            <span class=\"hljs-keyword\">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class=\"hljs-keyword\">new</span> NestedServletException(<span class=\"hljs-string\">\"Handler processing failed\"</span>, var23));\n        }\n\n    } <span class=\"hljs-keyword\">finally</span> {\n        <span class=\"hljs-keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) {\n            <span class=\"hljs-keyword\">if</span> (mappedHandler != <span class=\"hljs-keyword\">null</span>) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (multipartRequestParsed) {\n            <span class=\"hljs-keyword\">this</span>.cleanupMultipart(processedRequest);\n        }\n\n    }\n}\n</code></div></pre>\n<p>进入 <code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code> 内部，其底层调用了 ``</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> ModelAndView <span class=\"hljs-title\">handleInternal</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    <span class=\"hljs-keyword\">this</span>.checkRequest(request);\n    ModelAndView mav;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.synchronizeOnSession) {\n        HttpSession session = request.getSession(<span class=\"hljs-keyword\">false</span>);\n        <span class=\"hljs-keyword\">if</span> (session != <span class=\"hljs-keyword\">null</span>) {\n            Object mutex = WebUtils.getSessionMutex(session);\n            <span class=\"hljs-keyword\">synchronized</span>(mutex) {\n                <span class=\"hljs-comment\">// 执行目标方法</span>\n                mav = <span class=\"hljs-keyword\">this</span>.invokeHandlerMethod(request, response, handlerMethod);\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            mav = <span class=\"hljs-keyword\">this</span>.invokeHandlerMethod(request, response, handlerMethod);\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        mav = <span class=\"hljs-keyword\">this</span>.invokeHandlerMethod(request, response, handlerMethod);\n    }\n    \n    <span class=\"hljs-comment\">// ...</span>\n\n    <span class=\"hljs-keyword\">return</span> mav;\n}\n\n</code></div></pre>\n<p><code>mav = this.invokeHandlerMethod(request, response, handlerMethod);</code> 内部会调用参数解析器和返回值解析器来解析参数和返回值：</p>\n<p><strong>参数解析器</strong></p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220408153430902.png\" alt=\"image-20220408153430902\" /></p>\n<p><strong>返回值解析器</strong></p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220408153450432.png\" alt=\"image-20220408153450432\" /></p>\n<p>SpringMVC底层会遍历这些参数解析器和返回值解析器，判断哪个参数解析器和返回值解析器能解析数据，如果匹配到合适的解析器，就会放入缓存中，方便下次调用。</p>\n<h1><a id=\"_889\"></a>转换器</h1>\n<p>我们在控制器方法中定义的形参，SpringMVC都会帮我们自动注入参数。通常前端传递的参数都是 <code>String</code> 类型，如果控制器方法的形参位置不是 <code>String</code> 类型，则需要进行类型转换。</p>\n<p>SpringMVC底层有一个 <code>WebDataBinder</code> 对象，即数据绑定器，负责将请求参数的值绑定到指定的JavaBean里面，它会利用它里面的 <code>Converters</code> 将请求数据转成指定的数据类型后，再封装到JavaBean中。</p>\n<p><code>Converters</code> 是一个转换器集合，包含了网页中绝大多数的请求转换方式，但是有时候这些类型转换器未必能满足需求。</p>\n<p><strong>实体类</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>{\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> String age;\n    <span class=\"hljs-keyword\">private</span> String birth;\n    <span class=\"hljs-keyword\">private</span> Pet pet;\n}\n\n<span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Pet</span> </span>{\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> String age;\n}\n</code></div></pre>\n<p><strong>html</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"/savePerson\"</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>测试封装POJO对象<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n    姓名： <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"张三\"</span>/&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    年龄： <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"age\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"20\"</span>/&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    生日： <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"birth\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"2020-10-01\"</span>/&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    宠物：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"pet\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"旺财,3\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"提交\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></div></pre>\n<p>我们的需求是，获取到前端传递的 <code>Person</code> 对象并保存。</p>\n<p>但是问题就是，Spring肯定不知道怎么把一个 <code>“旺财,3”</code> 转换成一个 <code>Pet</code> 对象，当启动服务发起请求尝试去获取 <code>Person</code> 实体类的时候，就会抛出异常。</p>\n<p>所以我们可以自定义一个类型转换器，遇到这种问题就可以将 <code>String</code> 类型数据转换成 <code>Pet</code> 类型：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">// 在配置类中，添加转换器</span>\n<span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addFormatters</span><span class=\"hljs-params\">(FormatterRegistry registry)</span> </span>{\n        <span class=\"hljs-comment\">// 表示把String类型数据转换为Pet对象</span>\n        registry.addConverter(<span class=\"hljs-keyword\">new</span> Converter&lt;String, Pet&gt;() {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Pet <span class=\"hljs-title\">convert</span><span class=\"hljs-params\">(String source)</span> </span>{\n                <span class=\"hljs-keyword\">if</span> (StringUtils.hasLength(source)) {\n                    Pet pet = <span class=\"hljs-keyword\">new</span> Pet();\n                    String[] split = source.split(<span class=\"hljs-string\">\",\"</span>);\n                    pet.setName(split[<span class=\"hljs-number\">0</span>]);\n                    pet.setAge(split[<span class=\"hljs-number\">1</span>]);\n                    <span class=\"hljs-keyword\">return</span> pet;\n                }\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n            }\n        });\n    }\n}\n</code></div></pre>\n<p>这样，如果发起请求后，是需要 <code>String</code> 转 <code>Pet</code> 类型的，都会由这个转换器处理。</p>\n<blockquote>\n<p><strong>注意</strong>：</p>\n<p>这种javaBean中嵌套另一个JavaBean的方式SpringMVC也考虑到了，SpringMVC默认为我们提供的是级联赋值的方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\">宠物姓名：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"pet.name\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"旺财\"</span>/&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n宠物年龄：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"pet.age\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"3\"</span>/&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n</code></div></pre>\n<p>这样也可以实现我们的需求，只不过使用转换器后，我们可以更加灵活的定制化我们的项目。</p>\n</blockquote>\n<h1><a id=\"_974\"></a>内容协商</h1>\n<p>每次浏览器像服务器发起请求的时候，请求头中默认都会携带 <code>Accept</code> 参数，这个参数定义了浏览器可以接受哪中类型的参数，默认值如下：</p>\n<pre><code class=\"lang-\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n</code></pre>\n<p>同时服务端返回数据的时候，也会有能返回的数据类型，那么服务端返回的数据类型和浏览器能够接受的类型之间，就会产生内容协商。</p>\n<p>我们可以引入不同的第三方包来丰富服务端可以返回的数据类型：</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-comment\">&lt;!-- 服务端返回json数据的依赖 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- SpringBoot导入web环境后已经帮我们导入了这个依赖 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-json<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 服务端返回xml数据的依赖 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>jackson-dataformat-xml<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>注意：xml 的优先级在默认情况下是比 json 高的，所以没有特别设置的情况下，浏览器会接受到 xml 类型的数据。</p>\n<h2><a id=\"_1005\"></a>开启浏览器参数方式内容协商功能</h2>\n<p>浏览器默认是不能修改请求头中的 <code>Accept</code> 参数的，我们使用 <code>Ajax</code> 技术可以实现这个功能，但是如果不使用这个方式，我们应该怎么设置响应类型呢？</p>\n<p>SpringBoot为我们提供了很方便的功能，我们只需要在SpringBoot的核心配置文件中，添加如下内容即可：</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">spring:</span>\n<span class=\"hljs-attr\">  mvc:</span>\n<span class=\"hljs-attr\">    contentnegotiation:</span>\n<span class=\"hljs-attr\">      favor-parameter:</span> <span class=\"hljs-literal\">true</span>		<span class=\"hljs-comment\"># 开启请求参数内容协商模式</span>\n</code></div></pre>\n<p>此时我们只要请求参数中携带 <code>format</code> 参数，参数值就是真实的响应类型，如 <code>http://localhost:8080/person?format=json</code> 。</p>\n<p><strong>那么其底层是怎么实现的呢？</strong></p>\n<p>SpringBoot为了确定客户端能够接受的媒体类型，其内部使用的是 <strong><code>contentNegotiationManager</code> (内容协商管理器)</strong>，内容协商管理器会基于不同的策略，来确定客户端能接受多少哪些内容，默认是 <strong><code>HeaderContentNegotiationStrategy</code> (请求头协商策略)</strong>。</p>\n<p>也就是根据请求头中的 <code>Accept</code> 字段值来确定客户端能够接受哪些内容。</p>\n<p>开启请求参数内容协商后，内容协商管理器中会增加一个 <strong><code>ParameterContentNegotiationStrategy</code> (参数内容协商策略)</strong>。这就允许我们以请求参数的形式来指定获取的内容。</p>\n<p><code>ParameterContentNegotiationStrategy</code> 类中有如下方法，就是用来从请求参数中获取浏览器接受的内容类型。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Nullable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> String <span class=\"hljs-title\">getMediaTypeKey</span><span class=\"hljs-params\">(NativeWebRequest request)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> request.getParameter(<span class=\"hljs-keyword\">this</span>.getParameterName());\n}\n</code></div></pre>\n<h2><a id=\"_1041\"></a>内容协商原理</h2>\n<ul>\n<li>判断当前响应头中是否已经有确定的媒体类型。</li>\n<li>获取客户端支持接受的类型。(获取 <code>Accept</code> 请求头字段值，使用内容协商管理器，基于请求头协商或者基于参数内容协商)</li>\n<li>循环获取所有当前系统的 <code>MessageConverter</code> ，看谁支持操作控制器方法返回的对象。</li>\n<li>找到支持操作这个对象的 <code>converter</code> ，把 <code>converter</code> 支持的媒体类型统计出来。</li>\n<li>把客户端需要的媒体类型，和服务端支持的媒体类型查找出来。</li>\n<li>确定内容协商的最佳匹配的媒体类型。</li>\n<li>把支持的对象转为最佳匹配媒体类型的 <code>converter</code> ，调用它进行转化。(比如把 <code>Person</code> 对象转化为 <code>json</code> 还是转化为 <code>xml</code> )</li>\n</ul>\n<h2><a id=\"_MessageConverter_1053\"></a>自定义 <code>MessageConverter</code></h2>\n<p>因为 SpringBoot 提供了内容协商的功能，所以我们可以自己创建消息转换器，而不使用默认的 <code>json</code> 格式或者 <code>xml</code> 格式。</p>\n<p><strong>范例</strong></p>\n<p>访问 <code>/person</code> 资源时，控制器方法返回一个 <code>Person</code> 对象。</p>\n<ul>\n<li>如果浏览器请求的资源是 <code>application/json</code> ，则返回 <code>json</code> 格式的数据。</li>\n<li>如果浏览器请求的资源是 <code>application/xml</code> ，则返回 <code>xml</code> 格式的数据。</li>\n<li>如果浏览器请求的资源是 <code>application/x-hello</code> ，则返回自定义格式的数据。(如 <code>“name: jack; age: 18”</code>)</li>\n</ul>\n<p>实现消息转换器至少需要两步，第三步根据需要选择，如果使用参数内容协商，则需要加上第三步，如果是安卓客户端，或者使用 <code>ajax</code> 则可以省略第三步。</p>\n<p><strong>第一步：创建内容转换器</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloMsgConverter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HttpMessageConverter</span>&lt;<span class=\"hljs-title\">Person</span>&gt; </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">canRead</span><span class=\"hljs-params\">(Class&lt;?&gt; clazz, MediaType mediaType)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 是否能写，此处表示只要内容为Person对象即可写\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">canWrite</span><span class=\"hljs-params\">(Class&lt;?&gt; clazz, MediaType mediaType)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> clazz.isAssignableFrom(Person.class);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 此消息转换器能够支持的媒体类型列表\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;MediaType&gt; <span class=\"hljs-title\">getSupportedMediaTypes</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> MediaType.parseMediaTypes(<span class=\"hljs-string\">\"application/x-hello\"</span>);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Person <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(Class&lt;? extends Person&gt; clazz, HttpInputMessage inputMessage)</span> <span class=\"hljs-keyword\">throws</span> IOException, HttpMessageNotReadableException </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 怎么写入给浏览器，Spring会调用这个方法将控制器方法的返回值写给浏览器\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">write</span><span class=\"hljs-params\">(Person person, MediaType contentType, HttpOutputMessage outputMessage)</span> <span class=\"hljs-keyword\">throws</span> IOException, HttpMessageNotWritableException </span>{\n        String data = <span class=\"hljs-string\">\"name: \"</span> + person.getName() + <span class=\"hljs-string\">\"; age: \"</span> + person.getAge();\n        outputMessage.getBody().write(data.getBytes());\n    }\n}\n</code></div></pre>\n<p>但是这个时候只是创建了消息转换器，但是没有在在容器中添加这个消息转换器，所以我们还需要在配置类中，添加这个消息转换器到容器中。</p>\n<p><strong>第二步：配置消息转换器</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>   <span class=\"hljs-comment\">// 自定义消息转换器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">extendMessageConverters</span><span class=\"hljs-params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>{\n        converters.add(<span class=\"hljs-keyword\">new</span> HelloMsgConverter());\n    }\n\n    <span class=\"hljs-meta\">@Override</span>	<span class=\"hljs-comment\">// 配置消息转换器(这会覆盖原来的所有消息转换器，谨慎使用!)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configureMessageConverters</span><span class=\"hljs-params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>{\n        WebMvcConfigurer.<span class=\"hljs-keyword\">super</span>.configureMessageConverters(converters);\n    }\n}\n</code></div></pre>\n<p>配置完这一步之后，虽然服务器支持 <code>application/x-hello</code> 消息类型的转换，但是浏览器默认没法儿发起请求此类型的消息。我们可以配置基于参数内容的策略，让浏览器可以通过 <code>format</code> 字段来指定消息类型。</p>\n<p>但是使用参数内容策略，但是参数内容中默认只能支持 <code>json</code> 和 <code>xml</code> 格式的解析，如果其他格式，就无法通过参数内容来指定。所以我们还需要在配置文件中添加如下内容。</p>\n<p><strong>第三步：配置文件中添加消息类型</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">spring:</span>\n<span class=\"hljs-attr\">  mvc:</span>\n<span class=\"hljs-attr\">    contentnegotiation:</span>\n<span class=\"hljs-attr\">      favor-parameter:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">      media-types:</span>\n<span class=\"hljs-attr\">        hello:</span> <span class=\"hljs-string\">application/x-hello</span>\n</code></div></pre>\n<p>使用 <code>http://localhost:8080/person?format=hello</code> 即可以 <code>application/x-hello</code> 的格式获取内容。</p>\n<p>除了修改配置文件这种方式，还有一种方式就是重新配置内容协商管理器。但是需要注意，这种方式会覆盖原来的内容协商管理器，所以我们必须自己重新配置上参数内容策略和请求头协商策略：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>(proxyBeanMethods = <span class=\"hljs-keyword\">false</span>)\n<span class=\"hljs-comment\">// 配置类需要实现 WebMvcConfigurer 接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>   <span class=\"hljs-comment\">// 自定义消息转换器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">extendMessageConverters</span><span class=\"hljs-params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>{\n        converters.add(<span class=\"hljs-keyword\">new</span> HelloMsgConverter());\n    }\n\n    <span class=\"hljs-meta\">@Override</span>   <span class=\"hljs-comment\">// 自定义内容协商管理器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configureContentNegotiation</span><span class=\"hljs-params\">(ContentNegotiationConfigurer configurer)</span> </span>{\n        <span class=\"hljs-comment\">// 自定义基于参数协商策略</span>\n        Map&lt;String, MediaType&gt; map = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;&gt;();\n        map.put(<span class=\"hljs-string\">\"json\"</span>, MediaType.APPLICATION_JSON);\n        map.put(<span class=\"hljs-string\">\"xml\"</span>, MediaType.APPLICATION_XML);\n        map.put(<span class=\"hljs-string\">\"hello\"</span>, MediaType.parseMediaType(<span class=\"hljs-string\">\"application/x-hello\"</span>));\n        ParameterContentNegotiationStrategy paramStrategy = <span class=\"hljs-keyword\">new</span> ParameterContentNegotiationStrategy(map);\n\n        <span class=\"hljs-comment\">// 默认的基于请求头协商策略也需要添加</span>\n        HeaderContentNegotiationStrategy headerStrategy = <span class=\"hljs-keyword\">new</span> HeaderContentNegotiationStrategy();\n        <span class=\"hljs-comment\">// 向内容协商管理器添加策略，注意，这种方式会覆盖原来的所有策略</span>\n        configurer.strategies(Arrays.asList(paramStrategy, headerStrategy));\n    }\n    \n}\n</code></div></pre>\n<h1><a id=\"_1182\"></a>视图解析和模板引擎</h1>\n<p>SpringBoot 默认不支持 <code>JSP</code> ，所以我们需要引入第三方的模板引擎技术实现渲染。</p>\n<p>在不使用前后端分离的架构下，推荐使用 <code>thymeleaf</code> 作为模板引擎。</p>\n<h2><a id=\"_Thymeleaf_1190\"></a>整合 <code>Thymeleaf</code></h2>\n<h3><a id=\"_1192\"></a>基本介绍</h3>\n<p><code>Thymeleaf </code> 是新一代 Java 模板引擎，支持 HTML 原型，以直接被浏览器打开，此时浏览器会忽略未定义的 <code>Thymeleaf </code> 标签属性，展示 <code>Thymeleaf </code> 模板的静态页面效果。当在应用程序中会动态地替换掉页面设置的标签属性。</p>\n<p>对于 <code>thymeleaf</code> 的使用，可以参考<a href=\"https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#introducing-thymeleaf\" target=\"_blank\">官方文档</a>，具体的如何使用，此处不做介绍。</p>\n<h3><a id=\"_1200\"></a>基本使用</h3>\n<p><strong>引入依赖</strong>：除了默认的 <code>web</code> 场景启动器外，我们还需要引入 <code>thymeleaf</code> 的场景启动器。</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><code>thymeleaf</code> 的视图解析器默认解析的前缀是 <code>resources/templates</code> ，后缀是 <code>.html</code> 。所以需要在 <code>resources</code> 目录下创建 <code>templates</code> 目录，然后创建任何 <code>.html</code> 文件即可。</p>\n<p><strong>创建 <code>index.html</code> 文件</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 每个html文件都需要引入thymeleaf的名称空间 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span> <span class=\"hljs-attr\">xmlns:th</span>=<span class=\"hljs-string\">\"http://www.thymeleaf.org\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>成功<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>访问域对象数据: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">th:text</span>=<span class=\"hljs-string\">\"${msg}\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">th:href</span>=<span class=\"hljs-string\">\"@{/target}\"</span>&gt;</span>跳转目标页面<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></div></pre>\n<p><strong>创建控制器</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Controller</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThymeleafTestController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"/index\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">success</span><span class=\"hljs-params\">(Model model)</span> </span>{\n        model.addAttribute(<span class=\"hljs-string\">\"msg\"</span>, <span class=\"hljs-string\">\"HelloWorld\"</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"index\"</span>;\n    }\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"/target\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">target</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"target\"</span>;\n    }\n}\n</code></div></pre>\n<p>控制器方法中，我们只需要返回文件名即可，文件的路径前缀和文件名后缀 <code>thymeleaf</code> 的视图解析器会自动帮我们补全。</p>\n<h2><a id=\"_1254\"></a>视图解析原理流程</h2>\n<ol>\n<li>\n<p>在控制器方法处理的过程中，所有的数据都会被放在 <code>ModelAndViewContainer</code> 里面，包括数据和视图地址。</p>\n</li>\n<li>\n<p>方法的参数如果是自定义类型对象(从请求参数中确定的)，把他重新放在 <code>ModelAndViewContainer</code> 。</p>\n</li>\n<li>\n<p>任何控制器方法执行完成后返回值都会被封装为 <code>ModelAndView</code> (数据和视图地址)。</p>\n</li>\n<li>\n<p>在 <code>DispatcherServlet</code> 类的 <code>doDispatch()</code> 方法内，还会调用  <code>processDispatcheResule()</code> 方法，这个方法会根据 <code>ModelAndView</code> 处理派发结果(页面如何响应)</p>\n<ul>\n<li>内部调用 <code>render()</code> 进行页面渲染逻辑。</li>\n<li>根据方法的 <code>String</code> 返回值得到 <code>View</code> 对象(定义了页面的渲染逻辑)</li>\n<li>比如得到了 <code>“redirect:/main”</code> 最终会 <code>Thymeleaf</code> 被解析为 <code>RedirectView</code> 对象。</li>\n<li><code>ContentNegotiationViewResolver </code> 里面包含了所有的视图解析器，内部列用视图解析器解析得到视图对象。</li>\n<li>视图对象调用自定义的 <code>render()</code> 方法进行页面渲染工作。</li>\n</ul>\n</li>\n</ol>\n<h1><a id=\"_1269\"></a>拦截器</h1>\n<p>拦截器可以对网页一些非法的请求进行拦截，比如用户未登录，拦截其进行主页。</p>\n<p>关于拦截器的具体解析和原理，在我之前的文档中已经写过，可以参考之前的<a href=\"https://www.yuque.com/u12581613/zozp7f/upocgs#f7ae864d\" target=\"_blank\">文档</a>。</p>\n<p><strong>创建拦截器</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoginInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HandlerInterceptor</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>   <span class=\"hljs-comment\">// 在控制器方法之前执行，true表示放行，false表示拦截，对于拦截的请求我们通常进行转发或者重定向</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">preHandle</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        HttpSession session = request.getSession();\n        Object attribute = session.getAttribute(Constant.SESSION_USER);\n        <span class=\"hljs-keyword\">if</span> (attribute != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            response.sendRedirect(request.getContextPath() + <span class=\"hljs-string\">\"/login\"</span>);\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n    }\n\n    <span class=\"hljs-meta\">@Override</span>   <span class=\"hljs-comment\">// 在控制器方法之后执行</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">postHandle</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        HandlerInterceptor.<span class=\"hljs-keyword\">super</span>.postHandle(request, response, handler, modelAndView);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>   <span class=\"hljs-comment\">// 页面完成渲染之前抛出了任何异常，都会执行此方法，若无异常，则页面完成渲染后执行此方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">afterCompletion</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        HandlerInterceptor.<span class=\"hljs-keyword\">super</span>.afterCompletion(request, response, handler, ex);\n    }\n}\n</code></div></pre>\n<p><strong>添加拦截器到Web环境</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addInterceptors</span><span class=\"hljs-params\">(InterceptorRegistry registry)</span> </span>{\n        registry.addInterceptor(<span class=\"hljs-keyword\">new</span> LoginInterceptor()) <span class=\"hljs-comment\">// 添加拦截器</span>\n                .addPathPatterns(<span class=\"hljs-string\">\"/**\"</span>)     <span class=\"hljs-comment\">// 拦截的请求</span>\n                .excludePathPatterns(<span class=\"hljs-string\">\"/\"</span>, <span class=\"hljs-string\">\"/login\"</span>, <span class=\"hljs-string\">\"/css/**\"</span>, <span class=\"hljs-string\">\"/js/**\"</span>, <span class=\"hljs-string\">\"/images/**\"</span>, <span class=\"hljs-string\">\"/fonts/**\"</span>);    <span class=\"hljs-comment\">// 不拦截的请求</span>\n    }\n}\n</code></div></pre>\n<h1><a id=\"_1323\"></a>文件上传</h1>\n<p>SpringBoot中文件上传特别简单，在 <code>web</code> 场景启动器中已经配置了文件上传所需要的包，并且由于自动配置的特性，我们也不需要自定义文件上传解析器了。</p>\n<p>由于有之前MVC阶段的基础，所以此处简单展示一下代码：</p>\n<p><strong>前端页面</strong>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>文件上传演示<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 需要配置enctype属性 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">th:action</span>=<span class=\"hljs-string\">\"@{/upload}\"</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span> <span class=\"hljs-attr\">enctype</span>=<span class=\"hljs-string\">\"multipart/form-data\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>用户名:&amp;nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"username\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"请输入用户名...\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 如果需要选择多个文件，可以为文件输入框添加 multiple --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>上传文件:&amp;nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"file\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"file\"</span> <span class=\"hljs-attr\">multiple</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"上传\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></div></pre>\n<p><strong>后端代码</strong>：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Controller</span>\n<span class=\"hljs-meta\">@Slf</span>4j\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FormController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"/upload\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">uploadPage</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"form/upload_file\"</span>;\n    }\n\n    <span class=\"hljs-meta\">@ResponseBody</span>\n    <span class=\"hljs-meta\">@PostMapping</span>(<span class=\"hljs-string\">\"/upload\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">upload</span><span class=\"hljs-params\">(String username, @RequestPart(<span class=\"hljs-string\">\"file\"</span>)</span> MultipartFile file, HttpServletRequest req) <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-comment\">// 获取源文件后缀</span>\n        String originalFilename = file.getOriginalFilename();\n        String suffix = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">if</span> (originalFilename != <span class=\"hljs-keyword\">null</span>) {\n            suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(<span class=\"hljs-string\">\".\"</span>));\n        }\n        <span class=\"hljs-comment\">// 文件名随机生成</span>\n        String filename = UUID.randomUUID() + suffix;\n        <span class=\"hljs-comment\">// 获取服务器路径</span>\n        String serverPath = req.getSession().getServletContext().getRealPath(File.separator + <span class=\"hljs-string\">\"uploadFile\"</span>);\n        <span class=\"hljs-comment\">// 拼接得到文件所在的完成路径</span>\n        File realFilePath = <span class=\"hljs-keyword\">new</span> File(serverPath + File.separator + filename);\n        <span class=\"hljs-comment\">// 如果文件夹不存在则创建</span>\n        File serverPathDir = <span class=\"hljs-keyword\">new</span> File(serverPath);\n        <span class=\"hljs-keyword\">if</span> (!serverPathDir.exists()) serverPathDir.mkdirs();\n        <span class=\"hljs-comment\">// 写入到磁盘</span>\n        file.transferTo(realFilePath);\n        \n        log.info(<span class=\"hljs-string\">\"上传用户: \"</span> + username);\n        log.info(<span class=\"hljs-string\">\"realPath: \"</span> + serverPath + File.separator + filename);\n\n        <span class=\"hljs-comment\">// 返回json数据</span>\n        Map&lt;String, String&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;(<span class=\"hljs-number\">2</span>);\n        map.put(<span class=\"hljs-string\">\"code\"</span>, <span class=\"hljs-string\">\"200\"</span>);\n        map.put(<span class=\"hljs-string\">\"msg\"</span>, <span class=\"hljs-string\">\"success\"</span>);\n        <span class=\"hljs-keyword\">return</span> map;\n    }\n}\n</code></div></pre>\n<p>SpringBoot 的核心配置文件中，我们可以修改一些参数来改变默认的配置，文件上传的自动配置都是以 <code>spring.servlet.multipart</code> 为前缀。</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">spring:</span>\n<span class=\"hljs-attr\">  servlet:</span>\n<span class=\"hljs-attr\">    multipart:</span>\n<span class=\"hljs-attr\">      max-file-size:</span> <span class=\"hljs-number\">10</span><span class=\"hljs-string\">MB</span>       <span class=\"hljs-comment\"># 最大文件大小</span>\n<span class=\"hljs-attr\">      max-request-size:</span> <span class=\"hljs-number\">100</span><span class=\"hljs-string\">MB</span>   <span class=\"hljs-comment\"># 单次请求最大上传的文件大小(因为可能是多文件上传)</span>\n</code></div></pre>\n<p>文件上传的自动配置类为 <code>MultipartAutoConfiguration</code> ，读取配置文件的类为 <code>MultipartProperties</code> ，我们也可以查看其源码了解配置信息。</p>\n<p><strong>文件上传原理</strong></p>\n<ul>\n<li>在 <code>DispatcherServlet</code> 中的 <code>doDispatch()</code> 方法中，会调用 <code>this.checkMultipart(request);</code> 方法判断请求是否为文件上传请求，并获取到一个新的请求。</li>\n<li>内部会调用 <code>multipartResolver</code> 的 <code>isMultipart(request)</code> 方法判断是否为文件上传请求，主要就是判断是否含有 <code>multipart/form-data</code> 。</li>\n<li>判断新的请求和原来的请求是否相同，如果不相同则说明是文件上传请求。</li>\n<li>如果是文件上传的请求，则会调用 <code>RequestPartMethodArgumentResolver</code> 参数解析器解析控制器方法的参数，最终会把文件内容封装成一个 <code>MultipartFile</code> 。</li>\n</ul>\n<h1><a id=\"_1410\"></a>异常处理</h1>\n<h2><a id=\"SpringBoot__1412\"></a>SpringBoot 默认异常处理规则</h2>\n<p>默认情况下，SpringBoot 提供 <code>/error</code> 处理所有错误的映射。对于机器客户端，它生成 JSON 响应，其中包含错误信息、HTTP状态码和异常的详细信息等。对于浏览器客户端，响应一个 <code>whiteabel</code> 视图，以HTML格式呈现相同的数据。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220412201750407.png\" alt=\"image-20220412201750407\" /></p>\n<p>我们可以在 <code>resources/templates</code> 下，创建一个 <code>error</code> 目录，其中可以存放对应各种状态码的页面：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220412201818574.png\" alt=\"image-20220412201818574\" /></p>\n<p>注：SpringBoot 支持状态码的模糊匹配，<mark><code>5xx.html</code> 表示以 <code>500</code> 开头的错误码会转发到这个页面展示，而 <code>404.html</code> 则仅表示页面404时展示的页面。</mark></p>\n<p>在错误页面中，我们也可以正常使用 <code>thymeleaf</code> 获取域对象中的数据：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span> <span class=\"hljs-attr\">xmlns:th</span>=<span class=\"hljs-string\">\"http://www.thymeleaf.org\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>500<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>500<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- error: 出现的错误 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">th:text</span>=<span class=\"hljs-string\">\"${error}\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- message: 错误的相关信息 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">th:text</span>=<span class=\"hljs-string\">\"${message}\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- trace: 错误的堆栈信息 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">th:text</span>=<span class=\"hljs-string\">\"${trace}\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"_1447\"></a>自动配置原理</h2>\n<p><code>ErrorMvcAutoConfiguration</code> 类是 SpringBoot 中负责异常处理的自动配置类。</p>\n<p>容器中有一些组件：<code>DefaultErrorAttributes</code> 、<code>BasicErrorController</code> 、<code>DefaultErrorViewResolver</code> ，分别实现了异常自动配置的一些功能。</p>\n<ul>\n<li>\n<p><code>DefaultErrorAttributes</code> 类配置了一些异常参数，定义了错误页面中域对象可以取到哪些数据，如上方的 <code>error</code> 、<code>message</code> 等异常信息，都是这个类帮我们自动配置的，查看这个类的源码还可以发现更多的异常参数。</p>\n</li>\n<li>\n<p><code>BasicErrorController</code> 类配置了出现错误时响应的页面，比如浏览器的白页和json数据，都是这个配置类进行的配置。其类的头部标注了 <code>@RequestMapping({&quot;${server.error.path:${error.path:/error}}&quot;})</code> 注解，所以我们可以修改 <code>server.error.path</code> 来配置错误路径。</p>\n</li>\n<li>\n<p><code>DefaultErrorViewResolver</code> 类定义如果发生错误，会以 <code>HTTP</code> 状态码作为视图页地址( <code>viewName</code> ) ，找到真正的页面。如 <code>4xx.html</code> 、<code>5xx.html</code> 。</p>\n</li>\n</ul>\n<p><code>ErrorMvcAutoConfiguration</code> 类的 <code>StaticView</code> 定义了白页中内容。</p>\n<h2><a id=\"_1463\"></a>自定义异常处理</h2>\n<p>如果我们不想使用SpringBoot默认给我们提供的异常处理规则，我们也可以自定义异常处理的功能，Spring为我们提供了三种方式，我们可以根据情况自行选择。</p>\n<p><strong>方式一：使用 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 注解</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Slf</span>4j\n<span class=\"hljs-meta\">@ControllerAdvice</span>	<span class=\"hljs-comment\">// 表示这是一个控制器增强类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GlobalExceptionHandler</span> </span>{\n	<span class=\"hljs-comment\">// 表示处理空指针异常和算术异常</span>\n    <span class=\"hljs-meta\">@ExceptionHandler</span>({NullPointerException.class, ArithmeticException.class})\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">exceptionHandler</span><span class=\"hljs-params\">(Exception e)</span> </span>{\n        log.error(<span class=\"hljs-string\">\"error is \"</span> + e);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"login\"</span>;\n    }\n}\n</code></div></pre>\n<p>这种异常处理方式底层是 <code>ExceptionHandlerExceptionResolver</code> 支持的。</p>\n<p><strong>方式二：使用 <code>@ResponseStatus</code> 注解</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@ResponseStatus</span>(value = HttpStatus.FORBIDDEN, reason = <span class=\"hljs-string\">\"用户人数过多\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserToManyException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RuntimeException</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">UserToManyException</span><span class=\"hljs-params\">()</span> </span>{\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">UserToManyException</span><span class=\"hljs-params\">(String message)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(message);\n    }\n}\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Controller</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserController</span> </span>{\n    \n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"/user\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">user</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 其他操作...</span>\n        \n        <span class=\"hljs-keyword\">if</span> (users.size() &gt; <span class=\"hljs-number\">10000</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UserToManyException();\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"user\"</span>;\n    }\n    \n}\n</code></div></pre>\n<p>这种方式和之前的方式不同，这种方式需要定义一个异常类，异常类通过标注 <code>@ResponseStatus</code> 注解来处理异常页面，然后必须要在控制器方法中抛出这个异常。<code>value</code> 属性表示的是抛出这个异常后的响应状态码，<code>reason</code> 属性表示在浏览器中显示的异常信息是什么。</p>\n<p><strong>方式三：实现 <code>HandlerExceptionResolver</code> 注解</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">// 这种方式建议设置优先级，数值越小越优</span>\n<span class=\"hljs-meta\">@Order</span>(Ordered.HIGHEST_PRECEDENCE)\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomerHandlerExceptionResolver</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HandlerExceptionResolver</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ModelAndView <span class=\"hljs-title\">resolveException</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 让 tomcat 发送一个 `/error` 请求</span>\n            response.sendError(<span class=\"hljs-number\">500</span>, <span class=\"hljs-string\">\"服务器错误\"</span>);\n        } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n            e.printStackTrace();\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ModelAndView();\n    }\n}\n</code></div></pre>\n<p>实现 <code>HandlerExceptionResolver</code> 注解可以直接定义一个异常处理器，不过建议声明优先级，不然异常可能会被其他异常处理器优先处理。使用 <code>senError()</code> 方法可以让tomcat发起一个 <code>/error</code> 请求，这个请求会被 <code>DispatcherServlet</code> 解析，然后默认交给 <code>BasicErrorController</code> 解析。</p>\n<p>我们也可以使用如下的方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Order</span>(Ordered.HIGHEST_PRECEDENCE)\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomerHandlerExceptionResolver</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HandlerExceptionResolver</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ModelAndView <span class=\"hljs-title\">resolveException</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (ex <span class=\"hljs-keyword\">instanceof</span> ArithmeticException) {\n            ModelAndView mv = <span class=\"hljs-keyword\">new</span> ModelAndView();\n            mv.setViewName(<span class=\"hljs-string\">\"main\"</span>);\n            <span class=\"hljs-keyword\">return</span> mv;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n    }\n}\n</code></div></pre>\n<h1><a id=\"Web__1569\"></a>Web 原生组件注入</h1>\n<p>在兼容一些老Web项目的时候，如果我们想更新到SpringBoot的框架，可能会遇到一些不方便，就是项目中的 <code>Servlet</code> 、<code>Filter</code>、<code>Listener</code> 不方便注册到IOC容器中。</p>\n<p>使用SpringBoot之后，我们有两种方式将原生的Web组件注册到IOC容器中。</p>\n<h2><a id=\"_1577\"></a>方式一</h2>\n<p><strong>使用 <code>@WebXxx</code> + <code>@ServletComponentScan</code> 注解</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">// 注解的value值表示这个servlet处理的路径</span>\n<span class=\"hljs-meta\">@WebServlet</span>(<span class=\"hljs-string\">\"/hello/*\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloServlet</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">HttpServlet</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>{\n        resp.setContentType(<span class=\"hljs-string\">\"text/html\"</span>);\n        resp.getWriter().write(<span class=\"hljs-string\">\"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;\"</span>);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"hljs-keyword\">throws</span> ServletException, IOException </span>{\n        doGet(req, resp);\n    }\n}\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@ServletComponentScan</span>(<span class=\"hljs-string\">\"com.example.springbootthymeleaf\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>  <span class=\"hljs-title\">SpringBootThymeleafApplication</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(SpringBootThymeleafApplication.class, args);\n    }\n\n}\n</code></div></pre>\n<p>这种方式我们需要在 <code>Servlet</code> 上方添加 <code>@WebServlet</code> 注解，并且还需要在主程序类或者配置类中添加原生组件的包扫描路径，这种方式比较方便，所以也推荐这种方式。</p>\n<h2><a id=\"_1614\"></a>方式二</h2>\n<p>使用 <code>@WebXxx</code> + <code>@ServletComponentScan</code> 注解</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(FilterConfig filterConfig)</span> <span class=\"hljs-keyword\">throws</span> ServletException </span>{\n        Filter.<span class=\"hljs-keyword\">super</span>.init(filterConfig);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doFilter</span><span class=\"hljs-params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"hljs-keyword\">throws</span> IOException, ServletException </span>{\n        System.out.println(<span class=\"hljs-string\">\"执行HelloFilter过滤器\"</span>);\n        filterChain.doFilter(servletRequest, servletResponse);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span> </span>{\n        Filter.<span class=\"hljs-keyword\">super</span>.destroy();\n    }\n}\n\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>{\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ServletRegistrationBean&lt;HelloServlet&gt; <span class=\"hljs-title\">helloServlet</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ServletRegistrationBean&lt;&gt;(<span class=\"hljs-keyword\">new</span> HelloServlet(), <span class=\"hljs-string\">\"/hello/*\"</span>);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> FilterRegistrationBean&lt;HelloFilter&gt; <span class=\"hljs-title\">helloFilter</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 第一个参数是注册的过滤器，第二个参数可以选择拦截某个servlet下的所有路径</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> FilterRegistrationBean&lt;&gt;(<span class=\"hljs-keyword\">new</span> HelloFilter(), <span class=\"hljs-keyword\">this</span>.helloServlet());\n        <span class=\"hljs-comment\">// 上面方式等价于: </span>\n        <span class=\"hljs-comment\">// FilterRegistrationBean&lt;HelloFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(new HelloFilter());</span>\n        <span class=\"hljs-comment\">// registrationBean.addUrlPatterns(\"/hello/*\");</span>\n    }\n}\n</code></div></pre>\n<p>这种方式我们只需要在配置类中使用各种注册器注册对应的原生组件即可，不需要在原来的位置添加任何代码。</p>\n<p>至于 <code>Listener</code> 的注册方式和上面基本一致，就不再进行演示。</p>\n<blockquote>\n<p><strong>注意：使用原生 <code>servlet</code> 处理的路径不会被Spring的拦截器所拦截，只会被其自带的过滤器拦截。</strong></p>\n</blockquote>\n<h2><a id=\"DispatcherServlet__1667\"></a>DispatcherServlet 自动配置</h2>\n<p>在 <code>DispatcherServletAutoConfiguration</code> 类中，定义了 <code>DispatcherServlet</code> 的自动配置信息。</p>\n<p>其中定义了 <code>DispatcherServlet</code> 的属性会绑定到 <code>WebMvcProperties</code> 这个配置文件类中，这个类对应的以 <code>spring.mvc</code> 为前缀的配置路径。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220413214857725.png\" alt=\"image-20220413214857725\" /></p>\n<p>然后是通过 <code>DispatcherServletRegistrationBean</code> 将 <code>DispatcherServlet</code> 注册进来的。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220413215148379.png\" alt=\"image-20220413215148379\" /></p>\n<p>我们可以修改配置文件中 <code>spring.mvc.servlet.path</code> 为其他路径来修改 <code>DispatcherServlet</code> 的映射路径，不过我们一般不这么做。</p>\n<h1><a id=\"_Servlet__1683\"></a>嵌入式 <code>Servlet</code> 容器</h1>\n<p>SpringBoot 默认支持的WebServer有三种，就是 <code>Tomcat</code>、<code>Jetty</code> 和 <code>Undertow</code> 。<code>ServletWebServerApplicationContext </code> 容器启动寻找 <code>ServletWebServerFactory </code> 并引导创建服务器。</p>\n<h2><a id=\"_1689\"></a>切换服务器</h2>\n<p>以 <code>jetty</code> 服务器为例，我们只需要在 <code>pom.xml</code> 文件中排除 <code>tomcat</code> 的 <code>jar</code> 包，并引入 <code>jetty</code> 服务器的相关 <code>jar</code> 包即可。</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclusions</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">exclusion</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclusion</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">exclusions</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<h2><a id=\"_Servlet__1712\"></a>定制 Servlet 容器</h2>\n<p>如果需要修改服务器的配置，可以在服务器中直接修改 <code>server</code> 为前缀的配置，如修改端口：</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">server:</span>\n<span class=\"hljs-attr\">  port:</span> <span class=\"hljs-number\">8080</span>\n</code></div></pre>\n<p>不过还有一种方式就是使用 SpringBoot 为我们提供的定制化器，特定的定制化器可以改变特定的默认规则。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomizationBean</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebServerFactoryCustomizer</span>&lt;<span class=\"hljs-title\">ConfigurableServletWebServerFactory</span>&gt; </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">customize</span><span class=\"hljs-params\">(ConfigurableServletWebServerFactory factory)</span> </span>{\n        factory.setPort(<span class=\"hljs-number\">8080</span>);\n    }\n}\n</code></div></pre>\n<p>如果不想使用定制化器，最后一种方式就是自定义 <code>webServer</code> 的工厂：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WebConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>{\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ConfigurableServletWebServerFactory <span class=\"hljs-title\">webServerFactory</span><span class=\"hljs-params\">()</span> </span>{\n        TomcatServletWebServerFactory factory = <span class=\"hljs-keyword\">new</span> TomcatServletWebServerFactory();\n        factory.setPort(<span class=\"hljs-number\">8000</span>);\n        <span class=\"hljs-keyword\">return</span> factory;\n    }\n}\n</code></div></pre>\n<p>这三种方式都可以自定义的修改 <code>servlet</code> 容器的配置，按需要选择即可。</p>\n<h1><a id=\"_1751\"></a>定制化原理</h1>\n<h2><a id=\"_1753\"></a>定制化常见方式</h2>\n<ol>\n<li>修改配置文件，可以查看官网，或者查看 <code>xxxAutoConfiguration</code> 自动配置类自动注入的配置文件前缀了解。</li>\n<li>编写自定义配置类，如 <code>xxxConfiguration</code> + <code>@Bean</code> 添加为组件，即可替换、添加容器中的默认组件。</li>\n<li>如果要全面接管 <code>mvc</code> ，可以使用 <code>@EnableMVC</code> 注解，这个注解会让 SpringBoot 自动配置的内容全部失效，由我们自定定制。</li>\n</ol>\n<h2><a id=\"_1761\"></a>固定套路</h2>\n<p><strong>导入场景依赖 <code>starter</code></strong> -&gt; xxxxAutoConfiguration -&gt; 导入 <code>xxx</code> 组件 -&gt; 绑定 <code>xxxProperties</code> -&gt; <strong>绑定配置文件项</strong></p>\n<hr />\n<p><strong>本章完。</strong></p>\n',1534441901578596354),(1405916999854342214,'# 基本介绍\n\n由于后续学习Vue的需要，所以需要先了解一些node的知识。node是什么呢？简单的说 Node.js 就是运行在服务端的 JavaScript。和JavaWeb一样，可以执行一些后端操作，如操作文件之类的操作。\n\n但是如果是后端程序员，则不需要了解很多node.js的内容，只需要了解一些基础和它的npm工具满足我们的使用即可。\n\nnode.js 的安装在之前的笔记中有记录过，可以去翻之前的笔记查看：https://www.yuque.com/u12581613/sr444s/gyxuc5#MkrsZ。\n\n\n\n# HelloWorld\n\n在合适位置创建一个文件夹，用于存放node相关的代码，这个文件夹我们需要执行初始化操作，打开cmd界面，在文件夹所在位置，输入：`nmp init` 执行初始化。\n\n![image-20220403162155275](http://img.liubaiblog.top/img/image-20220403162155275.png)\n\n初始化过程中，可能需要填入一些参数，按需求填写即可。初始化完成之后，在项目所在文件夹，就会出现一个 `package.json` 文件，这个文件有我们刚刚在初始化过程中输入的参数，这个文件的作用类似于 `pom.xml ` 文件。\n\n![image-20220403162346822](http://img.liubaiblog.top/img/image-20220403162346822.png)\n\n新建一个index.js文件，编写以下内容，即可构建一个极简的服务端代码：\n\n```js\nconst http = require(\'http\')\n\nconst hostname = \'127.0.0.1\'\nconst port = 3000\n\nconst server = http.createServer((req, resp) => {\n    resp.statusCode = 200;\n    resp.setHeader(\'Content-Type\', \'text/html\')\n    resp.end(\'<h1>Hello World</h1>\')\n})\n\nserver.listen(port, hostname, () => {\n    console.log(`服务器已启动，地址: http://${hostname}:${port}`)\n})\n```\n\n代码编写完成之后，输入 `node ./index.js` 开启服务端：\n\n![image-20220403162554385](http://img.liubaiblog.top/img/image-20220403162554385.png)\n\n最后访问指定url，就可以看到我们搭建的网页了。\n\n![image-20220403162641101](http://img.liubaiblog.top/img/image-20220403162641101.png)\n\n但是现在的url路径是全都会被捕获，所以我们可以和JavaWeb一样，根据不同的url返回不同的页面内容：\n\n```js\nconst server = http.createServer((req, resp) => {\n    resp.statusCode = 200;\n    resp.setHeader(\'Content-Type\', \'text/html\')\n    if (req.url === \'/hello\')\n        resp.end(\'<h1>Hello World</h1>\')\n    else\n        resp.end(\'<h1>Hello Node</h1>\')\n})\n```\n\n这样之后访问 `/hello` 路径的时候，才会显示 `Hello World` 。和JavaWeb的逻辑是不是很相似？\n\n\n\n# nmp常用命令\n\n## 构建项目\n\n上面已经简单介绍，初始化一个基于node的项目，会创建一个配置文件  `package.json` ，以下两种方式皆可：\n\n```sh\n// 1. 按需求添加配置参数\n$ npm init\n\n// 2. 全部使用默认配置\n$ nmp init --yes\n```\n\n\n\n## 安装模块(包)\n\n```sh\n// 全局安装\n$ npm install 模块名 -g\n\n// 本地安装\n$ npm install 模块名\n\n// 一次性安装多个\n$ npm install 模块1 模块2 --save\n\n// 安装运行时依赖包\n$ npm install 模块名 --save\n```\n\n`install` 也可以简写成 `i`。\n\n\n\n## 查看安装目录\n\n```sh\n// 查看本地安装的目录\n$ npm root\n\n// 查看全局安装的目录\n$ npm root -g\n```\n\n\n\n## 卸载模块(包)\n\n```sh\n// 卸载本地模块\n$ npm uninstall 模块名\n\n// 卸载全局模块\n$ npm uninstall -g 模块名\n```\n\n\n\n## 更新模块(包)\n\n```sh\n// 更新本地模块\n$ npm update 模块名\n\n// 更新全局模块\n$ npm update 模块名 -g\n```\n\n\n\n## 查看当前安装的模块(包)\n\n```sh\n// 查看本地模块\n$ npm ls\n\n// 查看全局模块\n$ npm ls -g\n```\n\n\n\n## package.json 文件配置说明\n\n```json\n{\n  \"name\": \"learn\",					// 项目名称\n  \"version\": \"1.0.0\",				// 版本\n  \"description\": \"node项目初始化\",		// 项目描述\n  \"main\": \"index.js\",				// 入口文件\n  \"scripts\": {						// 配置一些通用的命令脚本\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keyword\": [],					// 项目的关键字\n  \"author\": \"liubai\",				// 作者\n  \"license\": \"ISC\",					// 许可\n  \"dependencies\": {					// 开发时的依赖\n    \"express\": \"^4.17.3\"\n  },\n  \"devDependencies\": {				// 运行时的依赖\n      \n  }\n}\n```\n\n\n\n## 命令配置\n\n```json\n\"script\": {\n    \"命令\": \"执行代码\",\n    // ...\n}\n```\n\n> **执行配置的命令**\n\n```sh\n// 必须加run\n$ npm run 命令\n\n// 特殊的命令 start 可以不加run\n$ npm start\n```\n\n\n\n## 使用国内npm镜像源\n\n和maven等依赖管理工具一样，默认使用的都是国外的镜像源，可能下载速度会比较慢，所以建议换到国内镜像源。\n\n**方式一：使用配置**\n\n```sh\n// 配置命令\n$ npm config set registry http://registry.npmmirror.com\n\n// 验证配置\n$ npm config get registry\n```\n\n如果显示 `http://registry.npmmirror.com/` 则表示配置成功。\n\n\n\n**方式二：使用cnpm**\n\n```sh\n// 安装cnpm工具，可以全局安装，随处都可以使用\n$ npm install -g cnpm --registry=http://registry.npmmirror.com\n\n// 之后使用cnpm代替npm下载模块\n$ cnpm install 模块\n```\n\n如果 cnpm 安装后遇到不可以使用的问题，参考：https://blog.csdn.net/bxllove/article/details/84784091\n\n\n\n## 使用yarn\n\n```sh\n// 先安装nrm工具\n$ npm install -g yarn --registry=http://registry.npmmirror.com\n```\n\n\n\n---\n\n**本章完。**\n\n','<h1><a id=\"_0\"></a>基本介绍</h1>\n<p>由于后续学习Vue的需要，所以需要先了解一些node的知识。node是什么呢？简单的说 Node.js 就是运行在服务端的 JavaScript。和JavaWeb一样，可以执行一些后端操作，如操作文件之类的操作。</p>\n<p>但是如果是后端程序员，则不需要了解很多node.js的内容，只需要了解一些基础和它的npm工具满足我们的使用即可。</p>\n<p>node.js 的安装在之前的笔记中有记录过，可以去翻之前的笔记查看：https://www.yuque.com/u12581613/sr444s/gyxuc5#MkrsZ。</p>\n<h1><a id=\"HelloWorld_10\"></a>HelloWorld</h1>\n<p>在合适位置创建一个文件夹，用于存放node相关的代码，这个文件夹我们需要执行初始化操作，打开cmd界面，在文件夹所在位置，输入：<code>nmp init</code> 执行初始化。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403162155275.png\" alt=\"image-20220403162155275\" /></p>\n<p>初始化过程中，可能需要填入一些参数，按需求填写即可。初始化完成之后，在项目所在文件夹，就会出现一个 <code>package.json</code> 文件，这个文件有我们刚刚在初始化过程中输入的参数，这个文件的作用类似于 <code>pom.xml </code> 文件。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403162346822.png\" alt=\"image-20220403162346822\" /></p>\n<p>新建一个index.js文件，编写以下内容，即可构建一个极简的服务端代码：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'http\'</span>)\n\n<span class=\"hljs-keyword\">const</span> hostname = <span class=\"hljs-string\">\'127.0.0.1\'</span>\n<span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">3000</span>\n\n<span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, resp</span>) =&gt;</span> {\n    resp.statusCode = <span class=\"hljs-number\">200</span>;\n    resp.setHeader(<span class=\"hljs-string\">\'Content-Type\'</span>, <span class=\"hljs-string\">\'text/html\'</span>)\n    resp.end(<span class=\"hljs-string\">\'&lt;h1&gt;Hello World&lt;/h1&gt;\'</span>)\n})\n\nserver.listen(port, hostname, () =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`服务器已启动，地址: http://<span class=\"hljs-subst\">${hostname}</span>:<span class=\"hljs-subst\">${port}</span>`</span>)\n})\n</code></div></pre>\n<p>代码编写完成之后，输入 <code>node ./index.js</code> 开启服务端：</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403162554385.png\" alt=\"image-20220403162554385\" /></p>\n<p>最后访问指定url，就可以看到我们搭建的网页了。</p>\n<p><img src=\"http://img.liubaiblog.top/img/image-20220403162641101.png\" alt=\"image-20220403162641101\" /></p>\n<p>但是现在的url路径是全都会被捕获，所以我们可以和JavaWeb一样，根据不同的url返回不同的页面内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> server = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, resp</span>) =&gt;</span> {\n    resp.statusCode = <span class=\"hljs-number\">200</span>;\n    resp.setHeader(<span class=\"hljs-string\">\'Content-Type\'</span>, <span class=\"hljs-string\">\'text/html\'</span>)\n    <span class=\"hljs-keyword\">if</span> (req.url === <span class=\"hljs-string\">\'/hello\'</span>)\n        resp.end(<span class=\"hljs-string\">\'&lt;h1&gt;Hello World&lt;/h1&gt;\'</span>)\n    <span class=\"hljs-keyword\">else</span>\n        resp.end(<span class=\"hljs-string\">\'&lt;h1&gt;Hello Node&lt;/h1&gt;\'</span>)\n})\n</code></div></pre>\n<p>这样之后访问 <code>/hello</code> 路径的时候，才会显示 <code>Hello World</code> 。和JavaWeb的逻辑是不是很相似？</p>\n<h1><a id=\"nmp_64\"></a>nmp常用命令</h1>\n<h2><a id=\"_66\"></a>构建项目</h2>\n<p>上面已经简单介绍，初始化一个基于node的项目，会创建一个配置文件  <code>package.json</code> ，以下两种方式皆可：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 1. 按需求添加配置参数\n$ npm init\n\n// 2. 全部使用默认配置\n$ nmp init --yes\n</code></div></pre>\n<h2><a id=\"_80\"></a>安装模块(包)</h2>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 全局安装\n$ npm install 模块名 -g\n\n// 本地安装\n$ npm install 模块名\n\n// 一次性安装多个\n$ npm install 模块1 模块2 --save\n\n// 安装运行时依赖包\n$ npm install 模块名 --save\n</code></div></pre>\n<p><code>install</code> 也可以简写成 <code>i</code>。</p>\n<h2><a id=\"_100\"></a>查看安装目录</h2>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 查看本地安装的目录\n$ npm root\n\n// 查看全局安装的目录\n$ npm root -g\n</code></div></pre>\n<h2><a id=\"_112\"></a>卸载模块(包)</h2>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 卸载本地模块\n$ npm uninstall 模块名\n\n// 卸载全局模块\n$ npm uninstall -g 模块名\n</code></div></pre>\n<h2><a id=\"_124\"></a>更新模块(包)</h2>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 更新本地模块\n$ npm update 模块名\n\n// 更新全局模块\n$ npm update 模块名 -g\n</code></div></pre>\n<h2><a id=\"_136\"></a>查看当前安装的模块(包)</h2>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 查看本地模块\n$ npm ls\n\n// 查看全局模块\n$ npm ls -g\n</code></div></pre>\n<h2><a id=\"packagejson__148\"></a>package.json 文件配置说明</h2>\n<pre><div class=\"hljs\"><code class=\"lang-json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"learn\"</span>,					// 项目名称\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"1.0.0\"</span>,				// 版本\n  <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"node项目初始化\"</span>,		// 项目描述\n  <span class=\"hljs-attr\">\"main\"</span>: <span class=\"hljs-string\">\"index.js\"</span>,				// 入口文件\n  <span class=\"hljs-attr\">\"scripts\"</span>: {						// 配置一些通用的命令脚本\n    <span class=\"hljs-attr\">\"test\"</span>: <span class=\"hljs-string\">\"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"</span>\n  },\n  <span class=\"hljs-attr\">\"keyword\"</span>: [],					// 项目的关键字\n  <span class=\"hljs-attr\">\"author\"</span>: <span class=\"hljs-string\">\"liubai\"</span>,				// 作者\n  <span class=\"hljs-attr\">\"license\"</span>: <span class=\"hljs-string\">\"ISC\"</span>,					// 许可\n  <span class=\"hljs-attr\">\"dependencies\"</span>: {					// 开发时的依赖\n    <span class=\"hljs-attr\">\"express\"</span>: <span class=\"hljs-string\">\"^4.17.3\"</span>\n  },\n  <span class=\"hljs-attr\">\"devDependencies\"</span>: {				// 运行时的依赖\n      \n  }\n}\n</code></div></pre>\n<h2><a id=\"_173\"></a>命令配置</h2>\n<pre><div class=\"hljs\"><code class=\"lang-json\"><span class=\"hljs-string\">\"script\"</span>: {\n    <span class=\"hljs-attr\">\"命令\"</span>: <span class=\"hljs-string\">\"执行代码\"</span>,\n    // ...\n}\n</code></div></pre>\n<blockquote>\n<p><strong>执行配置的命令</strong></p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 必须加run\n$ npm run 命令\n\n// 特殊的命令 start 可以不加run\n$ npm start\n</code></div></pre>\n<h2><a id=\"npm_194\"></a>使用国内npm镜像源</h2>\n<p>和maven等依赖管理工具一样，默认使用的都是国外的镜像源，可能下载速度会比较慢，所以建议换到国内镜像源。</p>\n<p><strong>方式一：使用配置</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 配置命令\n$ npm config <span class=\"hljs-built_in\">set</span> registry http://registry.npmmirror.com\n\n// 验证配置\n$ npm config get registry\n</code></div></pre>\n<p>如果显示 <code>http://registry.npmmirror.com/</code> 则表示配置成功。</p>\n<p><strong>方式二：使用cnpm</strong></p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 安装cnpm工具，可以全局安装，随处都可以使用\n$ npm install -g cnpm --registry=http://registry.npmmirror.com\n\n// 之后使用cnpm代替npm下载模块\n$ cnpm install 模块\n</code></div></pre>\n<p>如果 cnpm 安装后遇到不可以使用的问题，参考：https://blog.csdn.net/bxllove/article/details/84784091</p>\n<h2><a id=\"yarn_226\"></a>使用yarn</h2>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">// 先安装nrm工具\n$ npm install -g yarn --registry=http://registry.npmmirror.com\n</code></div></pre>\n<hr />\n<p><strong>本章完。</strong></p>\n',1534442912082898945),(1405916999854342215,'## 二级标题\n\ndsdasASD','<h2><a id=\"_0\"></a>二级标题</h2>\n<p>dsdasASD</p>\n',1534899357920333826),(1405916999854342216,'# gsdgdfsg\n\ndasdasda\ndasdasdsa\nfsagsdf\nhhdfghdfgh','<h1><a id=\"gsdgdfsg_0\"></a>gsdgdfsg</h1>\n<p>dasdasda<br />\ndasdasdsa<br />\nfsagsdf<br />\nhhdfghdfgh</p>\n',1534900336099155970),(1405916999854342217,'31313123123\n# 啊大苏打撒旦\n\n大大萨达萨达\n\n大大大大大\n\n大大大发射点发射点归属感','<p>31313123123</p>\n<h1><a id=\"_1\"></a>啊大苏打撒旦</h1>\n<p>大大萨达萨达</p>\n<p>大大大大大</p>\n<p>大大大发射点发射点归属感</p>\n',1534900541058015234),(1405916999854342219,'31313131231','<p>31313131231</p>\n',1534901421555671041),(1405916999854342220,'二啊大苏打撒旦\n恶气恶气恶气\n\n恶气恶气恶气\n1412','<p>二啊大苏打撒旦<br />\n恶气恶气恶气</p>\n<p>恶气恶气恶气<br />\n1412</p>\n',1534901629047889922),(1405916999854342221,'31321442','<p>31321442</p>\n',1534903377091194881);
/*!40000 ALTER TABLE `ms_article_body` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_article_tag`
--

DROP TABLE IF EXISTS `ms_article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_article_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `article_id` bigint NOT NULL,
  `tag_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE,
  KEY `tag_id` (`tag_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1405916999787233410 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_article_tag`
--

LOCK TABLES `ms_article_tag` WRITE;
/*!40000 ALTER TABLE `ms_article_tag` DISABLE KEYS */;
INSERT INTO `ms_article_tag` VALUES (1405916999787233387,1534438376886841346,1534439061695049730),(1405916999787233389,1534439635018657793,1534440335668752385),(1405916999787233391,1534440888750649346,1534441432076595202),(1405916999787233392,1534441901578596354,5),(1405916999787233393,1534441901578596354,6),(1405916999787233394,1534441901578596354,7),(1405916999787233396,1534442912082898945,1534441432076595202),(1405916999787233397,1534899357920333826,6),(1405916999787233398,1534900336099155970,7),(1405916999787233399,1534900336099155970,1534439061695049730),(1405916999787233400,1534900541058015234,5),(1405916999787233401,1534900541058015234,6),(1405916999787233404,1534901421555671041,5),(1405916999787233405,1534901421555671041,6),(1405916999787233406,1534901629047889922,7),(1405916999787233407,1534901629047889922,1534439061695049730),(1405916999787233408,1534903377091194881,5),(1405916999787233409,1534903377091194881,6);
/*!40000 ALTER TABLE `ms_article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_category`
--

DROP TABLE IF EXISTS `ms_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_category` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1534447267523637251 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_category`
--

LOCK TABLES `ms_category` WRITE;
/*!40000 ALTER TABLE `ms_category` DISABLE KEYS */;
INSERT INTO `ms_category` VALUES (1,'/static/category/front.png','前端','前端是什么，大前端'),(2,'/static/category/back.png','后端','后端最牛叉'),(3,'/static/category/lift.jpg','生活','生活趣事'),(4,'/static/category/database.png','数据库','没数据库，啥也不管用'),(5,'/static/category/language.png','编程语言','好多语言，该学哪个？'),(1534447267523637250,'http://blog.liubaiblog.top/blog/2022-06-08/f520f9b4-1a74-4a60-9de4-3f09f48f30de.png','全栈','全栈，也就是全干');
/*!40000 ALTER TABLE `ms_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_comment`
--

DROP TABLE IF EXISTS `ms_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint NOT NULL,
  `article_id` bigint NOT NULL,
  `author_id` bigint NOT NULL,
  `parent_id` bigint NOT NULL,
  `to_uid` bigint NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `deleted` int NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1534903437602418690 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_comment`
--

LOCK TABLES `ms_comment` WRITE;
/*!40000 ALTER TABLE `ms_comment` DISABLE KEYS */;
INSERT INTO `ms_comment` VALUES (1534439173246758914,'感谢大家的支持，哈哈哈',1654673782066,1534438376886841346,1,0,0,'1',0),(1534440457894965250,'很有收获',1654674088347,1534439635018657793,1404446129264832513,0,0,'1',0),(1534443140571803650,'很好呀',1654674727944,1534442912082898945,1,0,0,'1',1),(1534443185165643777,'感谢支持',1654674738578,1534442912082898945,1404446129264832513,1534443140571803650,1,'2',0),(1534446269505777666,'希望对大家有所帮助',1654675473935,1534442912082898945,1404446129264832513,0,0,'1',0),(1534900630782566402,'很有收获',1654783802109,1534441901578596354,1,0,0,'1',0),(1534901675541749761,'有些道理啊',1654784051201,1534901629047889922,1,0,0,'1',0),(1534903437602418689,'312312312',1654784471309,1534903377091194881,1,0,0,'1',1);
/*!40000 ALTER TABLE `ms_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_permission`
--

DROP TABLE IF EXISTS `ms_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_permission`
--

LOCK TABLES `ms_permission` WRITE;
/*!40000 ALTER TABLE `ms_permission` DISABLE KEYS */;
INSERT INTO `ms_permission` VALUES (1,'查询权限列表','/admin/permission/permissionList','查询权限列表'),(2,'增加权限列表','/admin/permission/add','增加权限'),(10,'编辑','/admin/edit','编辑权限');
/*!40000 ALTER TABLE `ms_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_role`
--

DROP TABLE IF EXISTS `ms_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_role` (
  `rid` bigint NOT NULL COMMENT '主键id',
  `role_mark` varchar(20) NOT NULL COMMENT '角色标记',
  `role_name` varchar(20) NOT NULL DEFAULT '' COMMENT '角色名',
  `description` varchar(200) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`rid`),
  UNIQUE KEY `role_mark` (`role_mark`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='角色表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_role`
--

LOCK TABLES `ms_role` WRITE;
/*!40000 ALTER TABLE `ms_role` DISABLE KEYS */;
INSERT INTO `ms_role` VALUES (1,'admin','系统管理员','系统最高权限所有者'),(2,'tester','测试人员','负责测试');
/*!40000 ALTER TABLE `ms_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_role_permission`
--

DROP TABLE IF EXISTS `ms_role_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_role_permission` (
  `rpid` bigint NOT NULL COMMENT '主键id',
  `rid` bigint DEFAULT NULL COMMENT '角色id',
  `pid` bigint DEFAULT NULL COMMENT '权限id',
  PRIMARY KEY (`rpid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='角色权限关联表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_role_permission`
--

LOCK TABLES `ms_role_permission` WRITE;
/*!40000 ALTER TABLE `ms_role_permission` DISABLE KEYS */;
INSERT INTO `ms_role_permission` VALUES (1,1,1),(2,1,2),(3,2,1),(4,2,10);
/*!40000 ALTER TABLE `ms_role_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_sys_log`
--

DROP TABLE IF EXISTS `ms_sys_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_sys_log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `create_date` bigint DEFAULT NULL,
  `ip` varchar(15) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `method` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `module` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `nickname` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `operation` varchar(25) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `params` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `time` bigint DEFAULT NULL,
  `userid` bigint DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=292 DEFAULT CHARSET=utf8mb3 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_sys_log`
--

LOCK TABLES `ms_sys_log` WRITE;
/*!40000 ALTER TABLE `ms_sys_log` DISABLE KEYS */;
INSERT INTO `ms_sys_log` VALUES (35,1654410348741,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',47,-1),(36,1654410371207,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"12313123\",\"contentHtml\":\"<p>12313123</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":null,\"categoryName\":\"后端\",\"description\":null},\"summary\":\"dafds\",\"tags\":[{\"id\":\"6\",\"avatar\":null,\"tagName\":null}],\"title\":\"hello\",\"search\":null}]',69,1),(37,1654411085454,'0:0:0:0:0:0:0:1','login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',1472,-1),(38,1654413029894,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"articleId\":1533086205004058626,\"content\":\"哈哈哈\",\"parent\":null,\"toUserId\":null}]',43,1),(39,1654413054977,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"articleId\":1533086205004058626,\"content\":\"了了了了了了了了\",\"parent\":null,\"toUserId\":null}]',12,1),(40,1654413062907,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"articleId\":1533086205004058626,\"content\":\"打打打打打死对方公司是否\",\"parent\":1533345604553424897,\"toUserId\":1}]',10,1),(41,1654413086274,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"articleId\":1533086205004058626,\"content\":\"打发范德萨归属感\",\"parent\":null,\"toUserId\":null}]',11,1),(42,1654413092618,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"articleId\":1533086205004058626,\"content\":\"广东富豪的规范化积分\",\"parent\":1533345735835140098,\"toUserId\":1}]',10,1),(43,1654413506808,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"articleId\":1533086765971222529,\"content\":\"你好\",\"parent\":null,\"toUserId\":null}]',28,1),(44,1654413511933,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ0OTc0ODQsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDExMDg0LCJhY2NvdW50IjoiYWRtaW4ifQ.v-uh2G1Adj0kBDq9WnpAzqfxpUL1MODTSgxFl2jF7hqsqXpOIRPkV2eg4I4qg4AINAv31ojM0bN1L8IwDZPw2w\"]',2,-1),(45,1654413518181,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',29,-1),(46,1654413608645,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ0OTk5MTgsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NDEzNTE4LCJhY2NvdW50IjoibGlzaSJ9.OROmAuXrCgCY5hySXDosPnZnKPut6NbS_VhGu1qPIIiwyxe0938tmL2y-xhjN1Y8EBbEMMa6a0ir1pwWhQ2jzA\"]',1,-1),(47,1654413613795,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(48,1654414203234,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"articleId\":1533086765971222529,\"content\":\"大大\",\"parent\":null,\"toUserId\":null}]',12,1),(49,1654415109895,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533086765971222529,\"content\":\"大撒是否\",\"parent\":null,\"toUserId\":null}]',35,1),(50,1654415441146,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"测试\",\"parent\":null,\"toUserId\":null}]',36,1),(51,1654417376827,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MDAwMTMsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDEzNjEzLCJhY2NvdW50IjoiYWRtaW4ifQ.jgKnhOvQTmMVbkoLCyodreD0VJ-SG9O6e2dPrILTnqxwmptio93hnWiVx7LrusQtAshR1Wd7g0eI1krsJ8Q1Jg\"]',4,-1),(52,1654417391250,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',28,-1),(53,1654419844236,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MDM3OTEsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDE3MzkxLCJhY2NvdW50IjoiYWRtaW4ifQ.rEQQ84VIq3pZRl2_BynhFWiziOUSr25BgG7Im_GkTiPmEMLUkA79OSGmowEpz-Uqzz6DTG6AFGZaVgTdi1_jEQ\"]',4,-1),(54,1654419851863,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"1234565\",\"nickname\":null}]',5,-1),(55,1654419855071,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',34,-1),(56,1654419991918,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MDYyNTUsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDE5ODU1LCJhY2NvdW50IjoiYWRtaW4ifQ.T2K0XENlIvX9lncMBUxlZKCxg5Uh60b1WbqtoptNwJ3vyafyZ2TqRDYwxTJuVwQTpDb7G6gp_pqj_CBdFKK4fw\"]',1,-1),(57,1654419997320,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',5,-1),(58,1654420010273,'0:0:0:0:0:0:0:1','publish','文章','李四','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"31312414\",\"contentHtml\":\"<p>31312414</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":null,\"categoryName\":\"后端\",\"description\":null},\"summary\":\"大苏打分隔符的\",\"tags\":[{\"id\":\"5\",\"avatar\":null,\"tagName\":null}],\"title\":\"哈哈啊哈\",\"search\":null}]',48,1404446129264832513),(59,1654421702307,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MDYzOTcsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NDE5OTk3LCJhY2NvdW50IjoibGlzaSJ9.aH7t3ouC55BBddzIUlq9UrOKybPWODF_zy3DSFYQvV7ACuVMCMY58_NOWII8dK0lC9K4xHUKyf7T13uaZhElQg\"]',5,-1),(60,1654421709390,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',36,-1),(61,1654424225510,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MDgxMDksInVzZXJJZCI6MSwiaWF0IjoxNjU0NDIxNzA5LCJhY2NvdW50IjoiYWRtaW4ifQ.XI-VI8g3bLxLTj0HgFhp8UbTCRlPUiCE2eP9Ph6Hj0NLbCFFuvpjEz3RupyDFAeEUwC8kG8Aj3fmvmUb2KlZlQ\"]',5,-1),(62,1654424231173,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',30,-1),(63,1654424604692,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"哈哈哈哈\",\"parent\":null,\"toUserId\":null}]',43,1),(64,1654433236093,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章\",\"contentHtml\":\"<p>这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章这是最新的文章</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":null,\"...',36,1),(65,1654433293539,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1531262420512784386,\"content\":\"受益颇深\",\"parent\":null,\"toUserId\":null}]',13,1),(66,1654433298275,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1531262420512784386,\"content\":\"感谢感谢\",\"parent\":null,\"toUserId\":null}]',8,1),(67,1654435079008,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"哈哈哈哈\",\"parent\":null,\"toUserId\":null}]',44,1),(68,1654435083734,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"你好呀\",\"parent\":1533437979950944258,\"toUserId\":1}]',12,1),(69,1654435779295,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"大大大发顺丰\",\"parent\":null,\"toUserId\":null}]',59,1),(70,1654435782955,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"发声方法\",\"parent\":1533440917226229762,\"toUserId\":1}]',11,1),(71,1654436011502,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"有点道理\",\"parent\":1533437979950944258,\"toUserId\":1}]',32,1),(72,1654436082469,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MTA2MzEsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDI0MjMxLCJhY2NvdW50IjoiYWRtaW4ifQ.3wlX5tF_4ITa-RlI6b6PVD5wu629D5GKrR5EyEE89fddgVXN80fipEmwlkCxjOW42frcyLrLSma-mebc4Kcirw\"]',3,-1),(73,1654436159816,'0:0:0:0:0:0:0:1','login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',75,-1),(74,1654436174896,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"什么时候能回家\",\"parent\":null,\"toUserId\":null}]',28,1404446129264832513),(75,1654436185700,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"有趣\",\"parent\":1533442576496988161,\"toUserId\":1404446129264832513}]',12,1404446129264832513),(76,1654436187106,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MjI1NTksInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NDM2MTU5LCJhY2NvdW50IjoibGlzaSJ9.RkTvPB059ehRoqsjSU1NGMxcpJ5cBX9gESN9D-JXlwjGBsawMzvgcOVnc_0ok1SQ_0NXMTVa_8qkXK8dHE2c6w\"]',2,-1),(77,1654436194425,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(78,1654436205337,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"我也想回家\",\"parent\":1533442576496988161,\"toUserId\":1404446129264832513}]',14,1),(79,1654497711972,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"笑得好\",\"parent\":1533394047435034625,\"toUserId\":1}]',62,1),(80,1654497716964,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"6666\",\"parent\":null,\"toUserId\":null}]',5,1),(81,1654497722358,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"非常的棒啊\",\"parent\":null,\"toUserId\":null}]',7,1),(82,1654497727692,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"牛逼\",\"parent\":null,\"toUserId\":null}]',9,1),(83,1654497737109,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533086205004058626,\"content\":\"日志haoyongm\",\"parent\":null,\"toUserId\":null}]',7,1),(84,1654497753234,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533086205004058626,\"content\":\"嗨嗨嗨\",\"parent\":1533700787124940801,\"toUserId\":1}]',7,1),(85,1654497994238,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"很棒哦\",\"parent\":null,\"toUserId\":null}]',6,1),(86,1654498052516,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1MjI1OTQsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDM2MTk0LCJhY2NvdW50IjoiYWRtaW4ifQ.w9tutxOZq94qQ8OZm7Kzeb7gblbbf0ktAFO3RzKDplBkjbPavr-oVMq_yU-rXqBVFt79shGi7x1-nY0BdkuS-A\"]',2,-1),(87,1654498058242,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',42,-1),(88,1654498068570,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1ODQ0NTgsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NDk4MDU4LCJhY2NvdW50IjoibGlzaSJ9.hkyUDieKoEFt8emMZh3HqbJ6TZoFkue6EuNbQM0calv5bOxAo-XCLYBQvBOTR4UEhlXmkb6Nqp6UioU1SrLDJQ\"]',1,-1),(89,1654498073900,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(90,1654498396855,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533430250150621185,\"content\":\"hello\",\"parent\":null,\"toUserId\":null}]',39,1),(91,1654498610546,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1ODQ0NzMsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDk4MDczLCJhY2NvdW50IjoiYWRtaW4ifQ.BmoyfuiJsm4xj75S3Zjf5SaSGi2UtguiSuOE2As6BQRnP6yj5BgnUe2NnReZqaZ_dPmsDY17efb4cX4ojObEFQ\"]',2,-1),(92,1654498618199,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',29,-1),(93,1654498635339,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"[原内容已删除]\",\"parent\":null,\"toUserId\":null}]',13,1404446129264832513),(94,1654498645591,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"哈哈哈哈\",\"parent\":null,\"toUserId\":null}]',14,1404446129264832513),(95,1654498646941,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1ODUwMTgsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NDk4NjE4LCJhY2NvdW50IjoibGlzaSJ9.-BBSxRBmo_ZvyYBUE9iRAt-HMArOzA9otx7_d7LuRsooId4Z5Uv8RjhnD-Ki-8u-OK93LqmUsFq5xp6_r9n-KA\"]',0,-1),(96,1654498653443,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(97,1654498673519,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"哈哈哈\",\"parent\":1533704554599677953,\"toUserId\":1404446129264832513}]',10,1),(98,1654498844190,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"666\",\"parent\":1533704554599677953,\"toUserId\":1404446129264832513}]',9,1),(99,1654499439055,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"你好呀\",\"parent\":null,\"toUserId\":null}]',34,1),(100,1654499440719,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1ODUwNTMsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDk4NjUzLCJhY2NvdW50IjoiYWRtaW4ifQ.PTZYF-G6vFhxulSmIfv7a0ztUlRUySnyZLNxu5CKtXhBYtyS0g4Ujtjuj5cjDygDJ2wKEXxXhva_RBVNauzPbQ\"]',2,-1),(101,1654499446287,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',28,-1),(102,1654499454920,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"我觉得很好\",\"parent\":null,\"toUserId\":null}]',12,1404446129264832513),(103,1654499457811,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1ODU4NDYsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NDk5NDQ2LCJhY2NvdW50IjoibGlzaSJ9.jKUhqyXpCYDxPZB3sXMPGaYC2k8-VkRzBbGEFNKQGmnpfsmMKp8E92llHsI6c0Ip01i_7zkiOUJGAkmA3V25NA\"]',1,-1),(104,1654499463099,'0:0:0:0:0:0:0:1','login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(105,1654499478065,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(106,1654499491076,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"确实\",\"parent\":1533707992138100737,\"toUserId\":1404446129264832513}]',11,1),(107,1654499534192,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"666\",\"parent\":1533707992138100737,\"toUserId\":1404446129264832513}]',17,1),(108,1654499709786,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"44444\",\"parent\":null,\"toUserId\":null}]',31,1404446129264832513),(109,1654500829061,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"666\",\"parent\":null,\"toUserId\":null}]',6,1),(110,1654500844289,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"确实很6\",\"parent\":1533713755770306562,\"toUserId\":1}]',8,1),(111,1654500859431,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533430250150621185,\"content\":\"最新的文章噢\",\"parent\":null,\"toUserId\":null}]',5,1),(112,1654500872855,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533430250150621185,\"content\":\"支持支持\",\"parent\":1533713883117764609,\"toUserId\":1}]',8,1404446129264832513),(113,1654500880417,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533430250150621185,\"content\":\"哈哈哈\",\"parent\":null,\"toUserId\":null}]',7,1404446129264832513),(114,1654500894410,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"hello哈哈哈\",\"parent\":null,\"toUserId\":null}]',5,1404446129264832513),(115,1654500904190,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533334347851096066,\"content\":\"sixsix\",\"parent\":1533714029826129921,\"toUserId\":1404446129264832513}]',8,1),(116,1654500986799,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533430250150621185,\"content\":\"原本的内容是哈哈哈\",\"parent\":1533713971147816962,\"toUserId\":1404446129264832513}]',7,1),(117,1654501189835,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533430250150621185,\"content\":\"原本的内容是哈哈哈\",\"parent\":1533713971147816962,\"toUserId\":1404446129264832513}]',5,1),(118,1654506491827,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1ODU4NjMsInVzZXJJZCI6MSwiaWF0IjoxNjU0NDk5NDYzLCJhY2NvdW50IjoiYWRtaW4ifQ.9RjrzS3b_dqeLPHS44tq5XKBdjknHb2bvEAt1ou1wtz87C35upG7BVwNGATsySMF5inu1nqkKTxEGxJHuA-Ekg\"]',1284,-1),(119,1654506499749,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"mayun\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(120,1654506507675,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',44,-1),(121,1654506524123,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTI5MDcsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA2NTA3LCJhY2NvdW50IjoibGlzaSJ9.ZyyNIjK0tWeOSg1OaI8abmWfx-VaOWxhdEfJCJLXJGq_lr0-5Bj4lZRTh1g88zYYXwBH3wElbYCwaRG4a6aNaw\"]',1,-1),(122,1654506536097,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123321\",\"nickname\":null}]',3,-1),(123,1654506552394,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTI5MzYsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA2NTM2LCJhY2NvdW50IjoibGlzaSJ9.RcdYparYU6QhgsuRFYIzHdMx5rl-nSI52vECtY7ekSKSOqJWN-ndP3U1UflVQajVUCMLEXDMMejPTbHgo_kpSA\"]',1,-1),(124,1654506563374,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(125,1654506940480,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',35,-1),(126,1654506943702,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123321\",\"nickname\":null}]',3,-1),(127,1654507051307,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTMzNDMsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA2OTQzLCJhY2NvdW50IjoibGlzaSJ9.jCX2ivoYzKKRLGBPjs1TqBH97NzGfrTQ3KQUoQ4DMfoRphOhfIGoHTouJSiNZmAGuTLdSoThALsnlyWkfByrAQ\"]',5,-1),(128,1654507081527,'0:0:0:0:0:0:0:1','login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',36,-1),(129,1654507090463,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTM0ODEsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA3MDgxLCJhY2NvdW50IjoibGlzaSJ9.V7DBsvMQ5_6Xqb3VcNqayPUEbvxElXPy5aYR2Kih4eubBANOHWYiwAIXW4pWZL1is2Iy6n2pDaJkZbLRSQttAA\"]',1,-1),(130,1654507097986,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123123\",\"nickname\":null}]',3,-1),(131,1654507108155,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTM0OTcsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA3MDk3LCJhY2NvdW50IjoibGlzaSJ9.W9Z-AtcIm-KBz6h4kWk87GYI7HNzZnC_yrZkInjA-e1k6UjF9r54IYoFVuI7ulZzttemOr5ks6ckDAn7Qql58g\"]',0,-1),(132,1654507120575,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123321\",\"nickname\":null}]',3,-1),(133,1654507181061,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTM1MjAsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA3MTIwLCJhY2NvdW50IjoibGlzaSJ9.z9leMcfRXDcXx7crhyN755WSzKqUK16r-a3ourG0RSgKYsadmgccy5Y1OUXKvE965IgfJVV_pWNGpTtoDUmMYg\"]',1,-1),(134,1654507186455,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123123\",\"nickname\":null}]',3,-1),(135,1654507189735,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123321\",\"nickname\":null}]',3,-1),(136,1654507648793,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTM1ODksInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA3MTg5LCJhY2NvdW50IjoibGlzaSJ9.A7rBWKyrAQjQGGKX1PDJ3Mx8kCw0727i9a4sRq8RxMcBQpFg9X5FN7y71tBMiDlvXg6UziunrXU7ZT439xdxdw\"]',1,-1),(137,1654507660537,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',4,-1),(138,1654510578884,'0:0:0:0:0:0:0:1','save','文章分类','李四','添加文章分类','[{\"id\":1533754649370279937,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-06/1d42b835-6c34-405a-97e5-a2a97b73f8ba.png\",\"categoryName\":\"全栈\",\"description\":\"全栈啥都干\"}]',10,1404446129264832513),(139,1654510584070,'0:0:0:0:0:0:0:1','delete','文章分类','李四','删除文章分类','[]',16,1404446129264832513),(140,1654510594727,'0:0:0:0:0:0:0:1','save','文章标签','李四','添加文章标签','[{\"id\":1533754715900329986,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-06/52b95922-18fe-4494-bbde-f622a0a74253.png\",\"tagName\":\"hello\"}]',3,1404446129264832513),(141,1654510623682,'0:0:0:0:0:0:0:1','delete','文章标签','李四','删除没有文章引用的空标签','[]',8,1404446129264832513),(142,1654510773190,'0:0:0:0:0:0:0:1','save','文章分类','李四','添加文章分类','[{\"id\":1533755464420016129,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-06/f8319629-6194-4691-8397-bf02d51af987.png\",\"categoryName\":\"测试\",\"description\":\"哈哈哈\"}]',5,1404446129264832513),(143,1654519272854,'0:0:0:0:0:0:0:1','publish','文章','李四','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"# 一级标题\\n\\n哈哈，，，大大大大\\n![image.png](http://blog.liubaiblog.top/blog/2022-06-06/e4de2d53-979e-4262-a7e9-c72cbcec6911.png)\\n\\n```python\\ndef fun(a, b):\\n\\treturn a + b\\n\\nfun(10, 20)\\n```\\n\\n---\\n**本章完。**\",\"contentHtml\":\"<h...',70,1404446129264832513),(144,1654519397267,'0:0:0:0:0:0:0:1','save','文章分类','李四','添加文章分类','[{\"id\":1533791636445818882,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-06/cccc6a7d-ea20-4a3b-8864-94818263af97.png\",\"categoryName\":\"全栈\",\"description\":\"全栈就是全干\"}]',5,1404446129264832513),(145,1654519763993,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ1OTQwNjAsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NTA3NjYwLCJhY2NvdW50IjoibGlzaSJ9.trrEeADbpQhYKErh58K7aPydWYJ5Bu0dyeOvYO3QZ05lO3aVzqdO_iIagpvIziX93R5Zw3MLMjTIWocbiZZReg\"]',3,-1),(146,1654519769823,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',29,-1),(147,1654586037923,'0:0:0:0:0:0:0:1','delete','文章分类','系统管理员','删除文章分类','[]',13,1),(148,1654586041975,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2MDYxNjksInVzZXJJZCI6MSwiaWF0IjoxNjU0NTE5NzY5LCJhY2NvdW50IjoiYWRtaW4ifQ.jAn7C4HIRG_5M99_SdcR875JgzJ-38UFEi1inyPz4kpTfbltYepVxGSIwlavP8tgesY8GSg4H-CGKxOrOyrXjw\"]',4,-1),(149,1654586064272,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',42,-1),(150,1654586337842,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',43,-1),(151,1654592590495,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2NzI3MzcsInVzZXJJZCI6MSwiaWF0IjoxNjU0NTg2MzM3LCJhY2NvdW50IjoiYWRtaW4ifQ.MBL18SDZXP4CYOL-czzE393ZxIhQfgalua7SRpoQatrGOcMdrkYeMVZK72v1iQXZWikUiBptjfvGe1yYhKKQPg\"]',5,-1),(152,1654592600971,'0:0:0:0:0:0:0:1','login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',26,-1),(153,1654597069110,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',55,-1),(154,1654597324986,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2ODM0NjksInVzZXJJZCI6MSwiaWF0IjoxNjU0NTk3MDY5LCJhY2NvdW50IjoiYWRtaW4ifQ.FE9p6U_BaQfe-Wk7zS9M4xlJXVAfSB4CUAZmrNfH7VYtM6gbKTAkTjERXolJ5buwXVG0YYxnA85ZelmbTrZbJQ\"]',3,-1),(155,1654597367823,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(156,1654597447118,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2ODM3NjcsInVzZXJJZCI6MSwiaWF0IjoxNjU0NTk3MzY3LCJhY2NvdW50IjoiYWRtaW4ifQ.n2DJycZSbtYPFGHTXF1KBKnaQLul62gT6gTOrQIrthB5k5Dv53YFqkfFrL78wX4-iRcU-n8TWW22GHSvBVgR7g\"]',0,-1),(157,1654597505066,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',4,-1),(158,1654597537321,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533430250150621185,\"content\":\"hahaha\",\"parent\":null,\"toUserId\":null}]',31,1),(159,1654597547934,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533791114460504066,\"content\":\"写得好\",\"parent\":null,\"toUserId\":null}]',8,1),(160,1654597593500,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533791114460504066,\"content\":\"6666\",\"parent\":null,\"toUserId\":null}]',8,1),(161,1654601448977,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"很好啊\",\"parent\":null,\"toUserId\":null}]',7,1),(162,1654601452565,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"继续加油\",\"parent\":null,\"toUserId\":null}]',7,1),(163,1654601463013,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533791114460504066,\"content\":\"实现是6\",\"parent\":null,\"toUserId\":null}]',8,1),(164,1654601613957,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2ODM5MDUsInVzZXJJZCI6MSwiaWF0IjoxNjU0NTk3NTA1LCJhY2NvdW50IjoiYWRtaW4ifQ.IfER2SyoiVcrdLMk8bgFOom4OiIYWKaYs2XGbRC2T9O1Rt4TEyr9yb5mUB_-GJIvERUpGgXdBmSXr_Och2pWiw\"]',1,-1),(165,1654601722002,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',1,-1),(166,1654603236830,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2ODgxMjIsInVzZXJJZCI6MSwiaWF0IjoxNjU0NjAxNzIyLCJhY2NvdW50IjoiYWRtaW4ifQ.ufOhVra9cJQu29YXtVuCDTodDa7tLqXI3EbLJQYhqbpCIDwF6VB04FcGwDB432ujV5MpCmOOHM6PA055ZHeXXA\"]',1,-1),(167,1654603249600,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(168,1654603251298,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2ODk2NDksInVzZXJJZCI6MSwiaWF0IjoxNjU0NjAzMjQ5LCJhY2NvdW50IjoiYWRtaW4ifQ.mPFbdXGFG_pO6skeQJ3MGe1g4I48BX5DN9HOeLzvueV47nPlnIlbkv0frgF46ytusRrYj3URNPTuI96NN9DAug\"]',1,-1),(169,1654603836693,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(170,1654603842068,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2OTAyMzYsInVzZXJJZCI6MSwiaWF0IjoxNjU0NjAzODM2LCJhY2NvdW50IjoiYWRtaW4ifQ.Ho2iKH8HOfCDMs0JAn4msOmMHvYjeOFrkNGX-ye-OpNWWifz0QSDgS2Ae2pox_s2mNtTdXs3hrYLjBvp3tZN0Q\"]',0,-1),(171,1654612113639,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',45,-1),(172,1654612161349,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2OTg1MTMsInVzZXJJZCI6MSwiaWF0IjoxNjU0NjEyMTEzLCJhY2NvdW50IjoiYWRtaW4ifQ.J0E3PFzwSHkH3O2zyHE95cR3AyFm3bQUpRve6zqVI0YztPl8rqS9bj9D2hqM-vTcHLReCyhY7WWZWqWm9aDhMA\"]',3,-1),(173,1654612170483,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123321\",\"nickname\":null}]',4,-1),(174,1654612186813,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2OTg1NzAsInVzZXJJZCI6MSwiaWF0IjoxNjU0NjEyMTcwLCJhY2NvdW50IjoiYWRtaW4ifQ._yVYdzJR8rdWIDrUTHbVoKyqP6qJCuzDiNlLKwHrnEBEzLqjL_TenHml8cKnIXoOCZ6bddj0X44iVfk4ZPvrqw\"]',1,-1),(175,1654612194068,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(176,1654612961586,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"哈哈哈哈\\n# 你认为\\n\\n哒哒哒我法师\\n发生发射点发生官方·1\",\"contentHtml\":\"<p>哈哈哈哈</p>\\n<h1><a id=\\\"_1\\\"></a>你认为</h1>\\n<p>哒哒哒我法师<br />\\n发生发射点发生官方·1</p>\\n\"},\"category\":{\"id\":\"3\",\"avatar\":null,\"categoryName\":\"生活\",\"description\":null},\"summary\":\"这...',49,1),(177,1654612971195,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"我的评论\",\"parent\":null,\"toUserId\":null}]',21,1),(178,1654612995300,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"哈哈哈\",\"parent\":1534184113895903234,\"toUserId\":1}]',9,1),(179,1654613016821,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建龙岩\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟\",\"info\":\"Java工程师\",\"avatar\":null}]',15,1),(180,1654613086023,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福州\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟\",\"info\":\"Java工程师\",\"avatar\":null}]',4,1),(181,1654613188493,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福州\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟\",\"info\":\"Java工程师\",\"avatar\":null}]',34,1),(182,1654613204454,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,568,1),(183,1654613286356,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福州\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟\",\"info\":\"Java工程师\",\"avatar\":null}]',23,1),(184,1654613292535,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福州11111\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟\",\"info\":\"Java工程师\",\"avatar\":null}]',5,1),(185,1654613323799,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,416,1),(186,1654613346888,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟.。\",\"info\":\"Java工程师\",\"avatar\":null}]',5,1),(187,1654613361956,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,296,1),(188,1654613381147,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,324,1),(189,1654613400652,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,481,1),(190,1654613417282,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,304,1),(191,1654613450986,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,392,1),(192,1654613567334,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,348,1),(193,1654613608825,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福州\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟\",\"info\":\"Java工程师\",\"avatar\":null}]',3,1),(194,1654613618893,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,428,1),(195,1654613652341,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,329,1),(196,1654613669738,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533086205004058626,\"content\":\"66666啊\",\"parent\":null,\"toUserId\":null}]',8,1),(197,1654613709009,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ2OTg1OTQsInVzZXJJZCI6MSwiaWF0IjoxNjU0NjEyMTk0LCJhY2NvdW50IjoiYWRtaW4ifQ.mUx4zUOvM09FXBDvld6TBFa1AujtxRfCIpxJiHvVvWOpsbsj5RrkVGKUwlZwBcUiVEevXDnooauMgZ430_5UBQ\"]',3,-1),(198,1654613716508,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',23,-1),(199,1654613865671,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ3MDAxMTYsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0NjEzNzE2LCJhY2NvdW50IjoibGlzaSJ9.CyrdONigm5dMcuPBA9OrK6Q5ZNirnIIbRGE6XBEOLHrnckQN96_Ouqx4HlmfGG5qtCMu97J3-lKob9i1V7qupg\"]',0,-1),(200,1654613879795,NULL,'register','注册','游客','前台新用户注册','[{\"account\":\"liubei\",\"password\":\"123321\",\"nickname\":\"刘备\"}]',8,-1),(201,1654613909231,'0:0:0:0:0:0:0:1','uploadData','用户操作','刘备','用户更新个人信息未更换头像','[{\"nickname\":\"刘备\",\"address\":\"北京市\",\"email\":\"13131@qq.com\",\"description\":\"哈哈哈，三国\",\"info\":\"Java工程师\",\"avatar\":null}]',3,1534187924911820801),(202,1654613916365,'0:0:0:0:0:0:0:1','logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ3MDAyNzksInVzZXJJZCI6MTUzNDE4NzkyNDkxMTgyMDgwMSwiaWF0IjoxNjU0NjEzODc5LCJhY2NvdW50IjoibGl1YmVpIn0.o7a_xRph2GgE7oZZJiZktcCBWtxueLSOBknQDO6johRuQth3Av2inKxyq9ciTaddHqfVwmlVVsnkyA0n5I8R8w\"]',0,-1),(203,1654613922891,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(204,1654614455455,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1531262420512784386,\"content\":\"无敌的Java\",\"parent\":null,\"toUserId\":null}]',6,1),(205,1654614478338,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,448,1),(206,1654614478348,'0:0:0:0:0:0:0:1','save','文章分类','系统管理员','添加文章分类','[{\"id\":1534190435395702786,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-07/03e6bbc1-5d15-4a07-9806-6fe5fc6b0b6b.png\",\"categoryName\":\"全栈\",\"description\":\"全栈就是啥都干\"}]',2,1),(207,1654656005251,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',27,-1),(208,1654656037861,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福州\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟，梦想终会启航。\",\"info\":\"Java工程师\",\"avatar\":null}]',40,1),(209,1654659302378,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"哈哈哈\",\"parent\":null,\"toUserId\":null}]',43,1),(210,1654659508341,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"5555\",\"parent\":1534378440936980482,\"toUserId\":1}]',59,1),(211,1654660509832,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"有道理\",\"parent\":null,\"toUserId\":null}]',33,1),(212,1654660527517,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"确实\",\"parent\":1534383505340985346,\"toUserId\":1}]',8,1),(213,1654660563579,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"6666\",\"parent\":null,\"toUserId\":null}]',9,1),(214,1654660625080,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"哈哈哈\",\"parent\":1534383730851934209,\"toUserId\":1}]',11,1),(215,1654660706632,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"独一无二\",\"parent\":null,\"toUserId\":null}]',48,1),(216,1654660715873,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"独一无二子评论\",\"parent\":1534384330842927106,\"toUserId\":1}]',9,1),(217,1654660979410,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"哈哈哈\",\"parent\":null,\"toUserId\":null}]',36,1),(218,1654660984292,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"有道理\",\"parent\":1534385474893885442,\"toUserId\":1}]',12,1),(219,1654661034744,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"很好呀\",\"parent\":null,\"toUserId\":null}]',7,1),(220,1654661038240,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"饿呢呢\",\"parent\":null,\"toUserId\":null}]',8,1),(221,1654661050574,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"哈哈哈哈\",\"parent\":1534385707073777665,\"toUserId\":1}]',10,1),(222,1654661055435,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"继续加油\",\"parent\":1534385707073777665,\"toUserId\":1}]',10,1),(223,1654661197164,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"哈哈哈4444\",\"parent\":null,\"toUserId\":null}]',47,1),(224,1654661275445,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534184073454424066,\"content\":\"hello\",\"parent\":null,\"toUserId\":null}]',12,1),(225,1654661352499,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1533374777049305090,\"content\":\"hahaha\",\"parent\":null,\"toUserId\":null}]',32,1),(226,1654668898082,'0:0:0:0:0:0:0:1','uploadData','用户操作','系统管理员','用户更新个人信息未更换头像','[{\"nickname\":\"系统管理员\",\"address\":\"福建福州\",\"email\":\"10086@qq.com\",\"description\":\"一个立志成为大佬的菜鸟。\",\"info\":\"Java工程师\",\"avatar\":null}]',22,1),(227,1654670785305,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,679,1),(228,1654670833397,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,498,1),(229,1654672351567,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,554,1),(230,1654672820962,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,503,1),(231,1654673130028,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,1,1),(232,1654673241846,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,0,1),(233,1654673275164,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,1,1),(234,1654673351544,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','系统管理员','用户更新个人信息且更换头像',NULL,40,1),(235,1654673496559,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',42,-1),(236,1654673592247,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"# 引入\\n\\n在学习这门课程之前，大家可能或多或少了解过 Redis，它是一门 NoSQL 数据库，在引入部分，我们可以先了解以下这么技术是做什么的。\\n\\n## Web 1.0 时代\\n\\nWeb1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。\\n\\n![image-20220428161938450](http://img.liubaiblog.top/img/image-20220428161...',94,1),(237,1654673755443,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,643,1),(238,1654673755473,'0:0:0:0:0:0:0:1','save','文章标签','系统管理员','添加文章标签','[{\"id\":1534439061695049730,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-08/c04f4426-dd07-4212-8e2e-567c6a81d04b.png\",\"tagName\":\"redis\"}]',4,1),(239,1654673768952,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":1534438376886841346,\"body\":{\"content\":\"# 引入\\n\\n在学习这门课程之前，大家可能或多或少了解过 Redis，它是一门 NoSQL 数据库，在引入部分，我们可以先了解以下这么技术是做什么的。\\n\\n## Web 1.0 时代\\n\\nWeb1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。\\n\\n![image-20220428161938450](http://img.liubaiblog.top/img/im...',31,1),(240,1654673782084,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534438376886841346,\"content\":\"感谢大家的支持，哈哈哈\",\"parent\":null,\"toUserId\":null}]',17,1),(241,1654673892167,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"# MQ 简介\\n\\nMQ 全称 Message Queue，也就是消息队列，遵循 FIFO 原则(先进先出)，消息队列，顾名思义，这个队列中存放的就是各种消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦“的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。\\n\\n\\n\\n## MQ 的作用\\n\\n### 流量消峰\\n\\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力...',32,1),(242,1654674059207,'0:0:0:0:0:0:0:1','upload','文件','系统管理员','文件上传操作',NULL,359,1),(243,1654674059233,'0:0:0:0:0:0:0:1','save','文章标签','系统管理员','添加文章标签','[{\"id\":1534440335668752385,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-08/b171ed14-56fc-4b6d-b79b-bd6a2062f716.png\",\"tagName\":\"rabbitmq\"}]',19,1),(244,1654674070386,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":1534439635018657793,\"body\":{\"content\":\"# MQ 简介\\n\\nMQ 全称 Message Queue，也就是消息队列，遵循 FIFO 原则(先进先出)，消息队列，顾名思义，这个队列中存放的就是各种消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦“的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。\\n\\n\\n\\n## MQ 的作用\\n\\n### 流量消峰\\n\\n举个例子，如果订单系统最多...',18,1),(245,1654674071924,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ3NTk4OTYsInVzZXJJZCI6MSwiaWF0IjoxNjU0NjczNDk2LCJhY2NvdW50IjoiYWRtaW4ifQ.WDpkuZvRgH5c3Z-ahQW7FclylL2Zznu5JyohV6jSYixCg6-4tg2hPnM3HGNO_VqoWTmKpz5I1mrC07Wo1pfhtA\"]',3,-1),(246,1654674077123,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(247,1654674088355,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1534439635018657793,\"content\":\"很有收获\",\"parent\":null,\"toUserId\":null}]',8,1404446129264832513),(248,1654674102472,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',3,-1),(249,1654674191102,'0:0:0:0:0:0:0:1','publish','文章','李四','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"# 应用 & 组件实例\\n\\n## 创建一个应用实例\\n\\n每个 Vue 应用都是通过用 `createApp` 函数创建一个新的**应用实例**开始的：\\n\\n```js\\ndadaconst app = Vue.createApp({\\n  /* 选项 */\\n})\\n```\\n\\n该应用实例是用来在应用中注册“全局”组件的。应用实例暴露的大多数方法都会返回该同一实例，允许链式：\\n\\n```js\\nVue.createApp({...',32,1404446129264832513),(250,1654674320604,'0:0:0:0:0:0:0:1','upload','文件','李四','文件上传操作',NULL,463,1404446129264832513),(251,1654674320633,'0:0:0:0:0:0:0:1','save','文章标签','李四','添加文章标签','[{\"id\":1534441432076595202,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-08/ea1db6eb-ff56-4d07-89fc-048a2e6841c2.png\",\"tagName\":\"vue\"}]',20,1404446129264832513),(252,1654674336493,'0:0:0:0:0:0:0:1','publish','文章','李四','创建/修改文章','[{\"id\":1534440888750649346,\"body\":{\"content\":\"# 应用 & 组件实例\\n\\n## 创建一个应用实例\\n\\n每个 Vue 应用都是通过用 `createApp` 函数创建一个新的**应用实例**开始的：\\n\\n```js\\ndadaconst app = Vue.createApp({\\n  /* 选项 */\\n})\\n```\\n\\n该应用实例是用来在应用中注册“全局”组件的。应用实例暴露的大多数方法都会返回该同一实例，允许链式：\\n\\n```js\\n...',32,1404446129264832513),(253,1654674432578,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"# SpringMVC 自动配置概览\\n\\nSpringMVC中的大多数场景都可以自动配置，所以大多数场景都无需自动配置。\\n\\n- 内容协商视图解析器和BeanName视图解析器\\n- 静态资源 (包括webjars)\\n- 自动注册 ( `Converter`、`GenericConverter`、`Formatter` )\\n- 支持 `HttpMessageConverters`\\n- 静态 `index.html` 支持\\n...',47,1),(254,1654674563944,'0:0:0:0:0:0:0:1','uploadCarryAvatar','用户操作','李四','用户更新个人信息且更换头像',NULL,561,1404446129264832513),(255,1654674673487,'0:0:0:0:0:0:0:1','publish','文章','李四','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"# 基本介绍\\n\\n由于后续学习Vue的需要，所以需要先了解一些node的知识。node是什么呢？简单的说 Node.js 就是运行在服务端的 JavaScript。和JavaWeb一样，可以执行一些后端操作，如操作文件之类的操作。\\n\\n但是如果是后端程序员，则不需要了解很多node.js的内容，只需要了解一些基础和它的npm工具满足我们的使用即可。\\n\\nnode.js 的安装在之前的笔记中有记录过，可以去翻之前的笔记查看：htt...',35,1404446129264832513),(256,1654674683322,'0:0:0:0:0:0:0:1','publish','文章','李四','创建/修改文章','[{\"id\":1534442912082898945,\"body\":{\"content\":\"# 基本介绍\\n\\n由于后续学习Vue的需要，所以需要先了解一些node的知识。node是什么呢？简单的说 Node.js 就是运行在服务端的 JavaScript。和JavaWeb一样，可以执行一些后端操作，如操作文件之类的操作。\\n\\n但是如果是后端程序员，则不需要了解很多node.js的内容，只需要了解一些基础和它的npm工具满足我们的使用即可。\\n\\nnode.js 的安装在之前的笔记中有记录过，...',18,1404446129264832513),(257,1654674727953,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534442912082898945,\"content\":\"很好呀\",\"parent\":null,\"toUserId\":null}]',8,1),(258,1654674738586,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1534442912082898945,\"content\":\"感谢支持\",\"parent\":1534443140571803650,\"toUserId\":1}]',7,1404446129264832513),(259,1654674778747,'0:0:0:0:0:0:0:1','changePwd','用户操作','李四','用户修改密码','[{\"oldPwd\":\"123456\",\"newPwd\":\"123123\"}]',2,1404446129264832513),(260,1654674778752,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ3NjA0NzcsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0Njc0MDc3LCJhY2NvdW50IjoibGlzaSJ9.BGfDkDIPI5sk_vLqoqIGV1VS5lGV_58DutYT3fHLxZBofD5_lrpo9O2blHxRLXHvk_2bXrgOLgatf-hUxjgJGQ\"]',0,-1),(261,1654674784828,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123123\",\"nickname\":null}]',2,-1),(262,1654674795277,'0:0:0:0:0:0:0:1','changePwd','用户操作','李四','用户修改密码','[{\"oldPwd\":\"123111\",\"newPwd\":\"123456\"}]',1,1404446129264832513),(263,1654674801233,'0:0:0:0:0:0:0:1','changePwd','用户操作','李四','用户修改密码','[{\"oldPwd\":\"123123\",\"newPwd\":\"123456\"}]',2,1404446129264832513),(264,1654674801239,NULL,'logout','登出','游客','前台用户登出','[\"eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NTQ3NjExODQsInVzZXJJZCI6MTQwNDQ0NjEyOTI2NDgzMjUxMywiaWF0IjoxNjU0Njc0Nzg0LCJhY2NvdW50IjoibGlzaSJ9.KpVWP1iHePl8TlMRpWAGYfiZPnHH2ECs8Fat_ZpzGss6fwOSQsjPAvJMpZMaG7W4HFi-FZymBeGQ7ZSndoz1TQ\"]',1,-1),(265,1654674806924,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"lisi\",\"password\":\"123456\",\"nickname\":null}]',2,-1),(266,1654675473972,'0:0:0:0:0:0:0:1','create','文章评论','李四','添加文章评论','[{\"commentId\":null,\"articleId\":1534442912082898945,\"content\":\"希望对大家有所帮助\",\"parent\":null,\"toUserId\":null}]',30,1404446129264832513),(267,1654675711878,'0:0:0:0:0:0:0:1','upload','文件','李四','文件上传操作',NULL,718,1404446129264832513),(268,1654675711905,'0:0:0:0:0:0:0:1','save','文章分类','李四','添加文章分类','[{\"id\":1534447267523637250,\"avatar\":\"http://blog.liubaiblog.top/blog/2022-06-08/f520f9b4-1a74-4a60-9de4-3f09f48f30de.png\",\"categoryName\":\"全栈\",\"description\":\"全栈，也就是全干\"}]',17,1404446129264832513),(269,1654783483619,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',48,-1),(270,1654783498674,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"## 二级标题\\n\\ndsdasASD\",\"contentHtml\":\"<h2><a id=\\\"_0\\\"></a>二级标题</h2>\\n<p>dsdasASD</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":null,\"categoryName\":\"后端\",\"description\":null},\"summary\":\"dadasdas\",\"tags\":[{\"id\":\"6\",\"avatar\":null,\"ta...',47,1),(271,1654783643984,NULL,'login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',60,-1),(272,1654783660859,'0:0:0:0:0:0:0:1','delete','文章','系统管理员','删除文章','[1534899357920333826]',9,1),(273,1654783731886,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"# gsdgdfsg\\n\\ndasdasda\\ndasdasdsa\\nfsagsdf\\nhhdfghdfgh\",\"contentHtml\":\"<h1><a id=\\\"gsdgdfsg_0\\\"></a>gsdgdfsg</h1>\\n<p>dasdasda<br />\\ndasdasdsa<br />\\nfsagsdf<br />\\nhhdfghdfgh</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":null...',46,1),(274,1654783744305,'0:0:0:0:0:0:0:1','delete','文章','系统管理员','删除文章','[1534900336099155970]',13,1),(275,1654783780731,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"31313123123\\n# 啊大苏打撒旦\\n\\n大大萨达萨达\\n\\n大大大大大\\n\\n大大大发射点发射点归属感\",\"contentHtml\":\"<p>31313123123</p>\\n<h1><a id=\\\"_1\\\"></a>啊大苏打撒旦</h1>\\n<p>大大萨达萨达</p>\\n<p>大大大大大</p>\\n<p>大大大发射点发射点归属感</p>\\n\"},\"category\":{\"id\":\"3\",\"avatar\":null,\"cat...',12,1),(276,1654783802119,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534441901578596354,\"content\":\"很有收获\",\"parent\":null,\"toUserId\":null}]',8,1),(277,1654783810753,'0:0:0:0:0:0:0:1','delete','文章','系统管理员','删除文章','[1534900541058015234]',4,1),(278,1654783990707,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"31313131231\",\"contentHtml\":\"<p>31313131231</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":null,\"categoryName\":\"后端\",\"description\":null},\"summary\":\"恶气恶气恶气\",\"tags\":[{\"id\":\"5\",\"avatar\":null,\"tagName\":null},{\"id\":\"6\",\"avatar\":null,\"t...',52,1),(279,1654784013453,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":1534901421555671041,\"body\":{\"content\":\"31313131231\",\"contentHtml\":\"<p>31313131231</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":\"/static/category/back.png\",\"categoryName\":\"后端\",\"description\":\"后端最牛叉\"},\"summary\":\"恶气恶气恶气\",\"tags\":[{\"id\":\"5\",\"avatar\":null,\"...',18,1),(280,1654784021129,'0:0:0:0:0:0:0:1','delete','文章','系统管理员','删除文章','[1534901421555671041]',16,1),(281,1654784040138,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"二啊大苏打撒旦\\n恶气恶气恶气\\n\\n恶气恶气恶气\\n1412\",\"contentHtml\":\"<p>二啊大苏打撒旦<br />\\n恶气恶气恶气</p>\\n<p>恶气恶气恶气<br />\\n1412</p>\\n\"},\"category\":{\"id\":\"3\",\"avatar\":null,\"categoryName\":\"生活\",\"description\":null},\"summary\":\"色大叔梵蒂冈地方是各个地方\",\"tags\":[{\"...',15,1),(282,1654784051213,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534901629047889922,\"content\":\"有些道理啊\",\"parent\":null,\"toUserId\":null}]',9,1),(283,1654784069692,'0:0:0:0:0:0:0:1','delete','文章','系统管理员','删除文章','[1534901629047889922]',4,1),(284,1654784456935,'0:0:0:0:0:0:0:1','publish','文章','系统管理员','创建/修改文章','[{\"id\":null,\"body\":{\"content\":\"31321442\",\"contentHtml\":\"<p>31321442</p>\\n\"},\"category\":{\"id\":\"2\",\"avatar\":null,\"categoryName\":\"后端\",\"description\":null},\"summary\":\"dsfafs\",\"tags\":[{\"id\":\"5\",\"avatar\":null,\"tagName\":null},{\"id\":\"6\",\"avatar\":null,\"tagName...',50,1),(285,1654784471328,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":1534903377091194881,\"content\":\"312312312\",\"parent\":null,\"toUserId\":null}]',16,1),(286,1654784483802,'0:0:0:0:0:0:0:1','delete','文章','系统管理员','删除文章','[1534903377091194881]',8,1),(287,1654785145208,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":null,\"content\":\"123123\",\"parent\":null,\"toUserId\":null}]',192,1),(288,1654785164279,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":null,\"content\":\"hdhdfhgf\",\"parent\":null,\"toUserId\":null}]',3,1),(289,1654785176598,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":null,\"content\":\"fghgdjhgkg\",\"parent\":null,\"toUserId\":null}]',3,1),(290,1654785189165,'0:0:0:0:0:0:0:1','create','文章评论','系统管理员','添加文章评论','[{\"commentId\":null,\"articleId\":null,\"content\":\"fghgdjhgkg\",\"parent\":null,\"toUserId\":null}]',3,1),(291,1654952439592,'0:0:0:0:0:0:0:1','login','登录','游客','前台用户登录','[{\"account\":\"admin\",\"password\":\"123456\",\"nickname\":null}]',73,-1);
/*!40000 ALTER TABLE `ms_sys_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_sys_user`
--

DROP TABLE IF EXISTS `ms_sys_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_sys_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '账号',
  `admin` bit(1) DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '头像',
  `create_date` bigint DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '邮箱',
  `info` varchar(10) DEFAULT NULL,
  `address` varchar(10) DEFAULT NULL,
  `description` varchar(20) DEFAULT NULL,
  `last_login` bigint DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1534187924911820802 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_sys_user`
--

LOCK TABLES `ms_sys_user` WRITE;
/*!40000 ALTER TABLE `ms_sys_user` DISABLE KEYS */;
INSERT INTO `ms_sys_user` VALUES (1,'admin',_binary '','http://blog.liubaiblog.top/blog/2022-06-07/151272f1-f2cd-4bfa-b6d8-6e579052e822.jpg',20210622223122,_binary '\0','10086@qq.com','Java工程师','福建福州','一个立志成为大佬的菜鸟。',20210630223130,'12','系统管理员','9f2bc4480ffeb0ca67f33e899ae37c53','mszlu!@###','1'),(1404446129264832513,'lisi',_binary '\0','http://blog.liubaiblog.top/blog/2022-06-08/ba93f232-c446-4ccd-a261-55ff533a4118.png',1623681025218,_binary '\0','123321009@qq.com','测试工程师','北京市','我是一个测试工程师',1623681025218,NULL,'李四','9f2bc4480ffeb0ca67f33e899ae37c53','mszlu!@###','1'),(1404448463944462338,'12213',_binary '','/static/img/logo.b3a48c0.png',1623681581855,_binary '\0','','Java工程师','福建福州','一个立志成为大佬的菜鸟',1623681581855,NULL,'123','e10adc3949ba59abbe56e057f20f883e','','1'),(1404448588146192386,'123',_binary '','/static/img/logo.b3a48c0.png',1623681611474,_binary '\0','','Java工程师','福建福州','一个立志成为大佬的菜鸟',1623681611474,NULL,'123','e10adc3949ba59abbe56e057f20f883e','','1'),(1530103770389778433,'mary',_binary '\0','',1653640141470,_binary '\0','','Java工程师','福建福州','一个立志成为大佬的菜鸟',1653640141470,'','玛丽','3b4f238a6264a6c501a824d8101ea4c2','dad8b562022d45738b359d93371b3fff','1'),(1532985728379731969,'jack',_binary '\0','',1654327253794,_binary '\0','','Java工程师','福建福州','一个立志成为大佬的菜鸟',1654327253794,'','杰克','0fd112f3f93223d8ad7e2146b720f9ab','f882e8738564496bb75902db117ec74b','1'),(1532989809815048193,'lucy',_binary '\0','http://blog.liubaiblog.top/blog/default_avatar.png',1654328226885,_binary '\0','','Java工程师','福建福州','一个立志成为大佬的菜鸟',1654328226885,'','露西','c23507f73cdb71d0fbd4ede904261b03','3358fa61f5c54b7097ee010ce8e5faaf','1'),(1533012812531589121,'mayun',_binary '\0','http://blog.liubaiblog.top/blog/default_avatar.png',1654333711160,_binary '\0','',NULL,NULL,NULL,1654333711160,'','马云','63c89b15bb8bd84dcf6bfe6cee653e3d','44e9a3bb31434534bed38caaf39a01b4','1'),(1534187924911820801,'liubei',_binary '\0','http://blog.liubaiblog.top/blog/default_avatar.png',1654613879790,_binary '\0','13131@qq.com','Java工程师','北京市','哈哈哈，三国',1654613879790,'','刘备','f16dd1814f157740f38e6bec3f6231bf','b87eb6ce47b74c0c8d0b6f4933359487','1');
/*!40000 ALTER TABLE `ms_sys_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_tag`
--

DROP TABLE IF EXISTS `ms_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1534441432076595203 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_tag`
--

LOCK TABLES `ms_tag` WRITE;
/*!40000 ALTER TABLE `ms_tag` DISABLE KEYS */;
INSERT INTO `ms_tag` VALUES (5,'/static/tag/java.png','springboot'),(6,'/static/tag/java.png','spring'),(7,'/static/tag/java.png','springmvc'),(1534439061695049730,'http://blog.liubaiblog.top/blog/2022-06-08/c04f4426-dd07-4212-8e2e-567c6a81d04b.png','redis'),(1534440335668752385,'http://blog.liubaiblog.top/blog/2022-06-08/b171ed14-56fc-4b6d-b79b-bd6a2062f716.png','rabbitmq'),(1534441432076595202,'http://blog.liubaiblog.top/blog/2022-06-08/ea1db6eb-ff56-4d07-89fc-048a2e6841c2.png','vue');
/*!40000 ALTER TABLE `ms_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ms_user_role`
--

DROP TABLE IF EXISTS `ms_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ms_user_role` (
  `urid` bigint NOT NULL COMMENT '主键id',
  `uid` bigint DEFAULT NULL COMMENT '用户id',
  `rid` bigint DEFAULT NULL COMMENT '角色id',
  PRIMARY KEY (`urid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户角色关联表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ms_user_role`
--

LOCK TABLES `ms_user_role` WRITE;
/*!40000 ALTER TABLE `ms_user_role` DISABLE KEYS */;
INSERT INTO `ms_user_role` VALUES (1,1,1),(2,1,2),(3,3,2);
/*!40000 ALTER TABLE `ms_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-06-13 17:01:03
